{
  "google": {
    "adk": {
      "agents": {
        "active_streaming_tool": {
          "__members__": {
            "ActiveStreamingTool": {
              "type": "class",
              "signature": "(*, task: Optional[_asyncio.Task] = None, stream: Optional[google.adk.agents.live_request_queue.LiveRequestQueue] = None) -> None",
              "doc": "Manages streaming tool related resources during invocation."
            }
          }
        },
        "agent_config": {
          "__members__": {
            "AgentConfig": {
              "type": "class",
              "signature": "(root: 'RootModelRootType' = PydanticUndefined) -> None",
              "doc": "The config for the YAML schema to create an agent."
            },
            "agent_config_discriminator": {
              "type": "function",
              "signature": "(v: 'Any')",
              "doc": ""
            }
          }
        },
        "base_agent": {
          "__members__": {
            "BaseAgent": {
              "type": "class",
              "signature": "(*, name: str, description: str = '', parent_agent: Optional[google.adk.agents.base_agent.BaseAgent] = None, sub_agents: list[google.adk.agents.base_agent.BaseAgent] = <factory>, before_agent_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]]], NoneType] = None, after_agent_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]]], NoneType] = None) -> None",
              "doc": "Base class for all agents in Agent Development Kit."
            }
          }
        },
        "base_agent_config": {
          "__members__": {
            "BaseAgentConfig": {
              "type": "class",
              "signature": "(*, agent_class: Union[Literal['BaseAgent'], str] = 'BaseAgent', name: str, description: str = '', sub_agents: Optional[List[google.adk.agents.common_configs.AgentRefConfig]] = None, before_agent_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None, after_agent_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None, **extra_data: Any) -> None",
              "doc": "The config for the YAML schema of a BaseAgent.\n\nDo not use this class directly. It's the base class for all agent configs."
            }
          }
        },
        "callback_context": {
          "__members__": {
            "CallbackContext": {
              "type": "class",
              "signature": "(invocation_context: 'InvocationContext', *, event_actions: 'Optional[EventActions]' = None) -> 'None'",
              "doc": "The context of various callbacks within an agent run."
            }
          }
        },
        "common_configs": {
          "__members__": {
            "AgentRefConfig": {
              "type": "class",
              "signature": "(*, config_path: Optional[str] = None, code: Optional[str] = None) -> None",
              "doc": "The config for the reference to another agent."
            },
            "ArgumentConfig": {
              "type": "class",
              "signature": "(*, name: Optional[str] = None, value: Any) -> None",
              "doc": "An argument passed to a function or a class's constructor."
            },
            "CodeConfig": {
              "type": "class",
              "signature": "(*, name: str, args: Optional[List[google.adk.agents.common_configs.ArgumentConfig]] = None) -> None",
              "doc": "Code reference config for a variable, a function, or a class.\n\nThis config is used for configuring callbacks and tools."
            }
          }
        },
        "config_agent_utils": {
          "__members__": {
            "_load_config_from_path": {
              "type": "function",
              "signature": "(config_path: 'str') -> 'AgentConfig'",
              "doc": "Load an agent's configuration from a YAML file.\n\nArgs:\n  config_path: Path to the YAML config file. Both relative and absolute\n    paths are accepted.\n\nReturns:\n  The loaded and validated AgentConfig object.\n\nRaises:\n  FileNotFoundError: If config file doesn't exist.\n  ValidationError: If config file's content is invalid YAML."
            },
            "_resolve_agent_class": {
              "type": "function",
              "signature": "(agent_class: 'str') -> 'type[BaseAgent]'",
              "doc": "Resolve the agent class from its fully qualified name."
            },
            "_resolve_agent_code_reference": {
              "type": "function",
              "signature": "(code: 'str') -> 'Any'",
              "doc": "Resolve a code reference to an actual agent instance.\n\nArgs:\n  code: The fully-qualified path to an agent instance.\n\nReturns:\n  The resolved agent instance.\n\nRaises:\n  ValueError: If the agent reference cannot be resolved."
            },
            "_resolve_fully_qualified_name": {
              "type": "function",
              "signature": "(name: 'str') -> 'Any'",
              "doc": ""
            },
            "from_config": {
              "type": "function",
              "signature": "(config_path: 'str') -> 'BaseAgent'",
              "doc": "Build agent from a configfile path.\n\nArgs:\n  config: the path to a YAML config file.\n\nReturns:\n  The created agent instance.\n\nRaises:\n  FileNotFoundError: If config file doesn't exist.\n  ValidationError: If config file's content is invalid YAML.\n  ValueError: If agent type is unsupported."
            },
            "resolve_agent_reference": {
              "type": "function",
              "signature": "(ref_config: 'AgentRefConfig', referencing_agent_config_abs_path: 'str') -> 'BaseAgent'",
              "doc": "Build an agent from a reference.\n\nArgs:\n  ref_config: The agent reference configuration (AgentRefConfig).\n  referencing_agent_config_abs_path: The absolute path to the agent config\n  that contains the reference.\n\nReturns:\n  The created agent instance."
            },
            "resolve_callbacks": {
              "type": "function",
              "signature": "(callbacks_config: 'List[CodeConfig]') -> 'Any'",
              "doc": "Resolve callbacks from configuration.\n\nArgs:\n  callbacks_config: List of callback configurations (CodeConfig objects).\n\nReturns:\n  List of resolved callback objects."
            },
            "resolve_code_reference": {
              "type": "function",
              "signature": "(code_config: 'CodeConfig') -> 'Any'",
              "doc": "Resolve a code reference to actual Python object.\n\nArgs:\n  code_config: The code configuration (CodeConfig).\n\nReturns:\n  The resolved Python object.\n\nRaises:\n  ValueError: If the code reference cannot be resolved."
            }
          }
        },
        "invocation_context": {
          "__members__": {
            "InvocationContext": {
              "type": "class",
              "signature": "(*, artifact_service: Optional[google.adk.artifacts.base_artifact_service.BaseArtifactService] = None, session_service: google.adk.sessions.base_session_service.BaseSessionService, memory_service: Optional[google.adk.memory.base_memory_service.BaseMemoryService] = None, credential_service: Optional[google.adk.auth.credential_service.base_credential_service.BaseCredentialService] = None, invocation_id: str, branch: Optional[str] = None, agent: google.adk.agents.base_agent.BaseAgent, user_content: Optional[google.genai.types.Content] = None, session: google.adk.sessions.session.Session, end_invocation: bool = False, live_request_queue: Optional[google.adk.agents.live_request_queue.LiveRequestQueue] = None, active_streaming_tools: Optional[dict[str, google.adk.agents.active_streaming_tool.ActiveStreamingTool]] = None, transcription_cache: Optional[list[google.adk.agents.transcription_entry.TranscriptionEntry]] = None, live_session_resumption_handle: Optional[str] = None, run_config: Optional[google.adk.agents.run_config.RunConfig] = None, plugin_manager: google.adk.plugins.plugin_manager.PluginManager = <factory>) -> None",
              "doc": "An invocation context represents the data of a single invocation of an agent.\n\nAn invocation:\n  1. Starts with a user message and ends with a final response.\n  2. Can contain one or multiple agent calls.\n  3. Is handled by runner.run_async().\n\nAn invocation runs an agent until it does not request to transfer to another\nagent.\n\nAn agent call:\n  1. Is handled by agent.run().\n  2. Ends when agent.run() ends.\n\nAn LLM agent call is an agent with a BaseLLMFlow.\nAn LLM agent call can contain one or multiple steps.\n\nAn LLM agent runs steps in a loop until:\n  1. A final response is generated.\n  2. The agent transfers to another agent.\n  3. The end_invocation is set to true by any callbacks or tools.\n\nA step:\n  1. Calls the LLM only once and yields its response.\n  2. Calls the tools and yields their responses if requested.\n\nThe summarization of the function response is considered another step, since\nit is another llm call.\nA step ends when it's done calling llm and tools, or if the end_invocation\nis set to true at any time.\n\n```\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 invocation \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 llm_agent_call_1 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500 agent_call_2 \u2500\u2510\n   \u250c\u2500\u2500\u2500\u2500 step_1 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500 step_2 \u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   [call_llm] [call_tool] [call_llm] [transfer]\n```"
            },
            "LlmCallsLimitExceededError": {
              "type": "class",
              "signature": null,
              "doc": "Error thrown when the number of LLM calls exceed the limit."
            },
            "_InvocationCostManager": {
              "type": "class",
              "signature": "() -> None",
              "doc": "A container to keep track of the cost of invocation.\n\nWhile we don't expect the metrics captured here to be a direct\nrepresentative of monetary cost incurred in executing the current\ninvocation, they in some ways have an indirect effect."
            },
            "new_invocation_context_id": {
              "type": "function",
              "signature": "() -> 'str'",
              "doc": ""
            }
          }
        },
        "live_request_queue": {
          "__members__": {
            "LiveRequest": {
              "type": "class",
              "signature": "(*, content: Optional[google.genai.types.Content] = None, blob: Optional[google.genai.types.Blob] = None, activity_start: Optional[google.genai.types.ActivityStart] = None, activity_end: Optional[google.genai.types.ActivityEnd] = None, close: bool = False) -> None",
              "doc": "Request send to live agents."
            },
            "LiveRequestQueue": {
              "type": "class",
              "signature": "()",
              "doc": "Queue used to send LiveRequest in a live(bidirectional streaming) way."
            }
          }
        },
        "llm_agent": {
          "__members__": {
            "Agent": {
              "type": "class",
              "signature": "(*, name: str, description: str = '', parent_agent: Optional[google.adk.agents.base_agent.BaseAgent] = None, sub_agents: list[google.adk.agents.base_agent.BaseAgent] = <factory>, before_agent_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]]], NoneType] = None, after_agent_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]]], NoneType] = None, model: Union[str, google.adk.models.base_llm.BaseLlm] = '', instruction: Union[str, Callable[[google.adk.agents.readonly_context.ReadonlyContext], Union[str, Awaitable[str]]]] = '', global_instruction: Union[str, Callable[[google.adk.agents.readonly_context.ReadonlyContext], Union[str, Awaitable[str]]]] = '', tools: list[typing.Union[typing.Callable, google.adk.tools.base_tool.BaseTool, google.adk.tools.base_toolset.BaseToolset]] = <factory>, generate_content_config: Optional[google.genai.types.GenerateContentConfig] = None, disallow_transfer_to_parent: bool = False, disallow_transfer_to_peers: bool = False, include_contents: Literal['default', 'none'] = 'default', input_schema: Optional[type[pydantic.main.BaseModel]] = None, output_schema: Optional[type[pydantic.main.BaseModel]] = None, output_key: Optional[str] = None, planner: Optional[google.adk.planners.base_planner.BasePlanner] = None, code_executor: Optional[google.adk.code_executors.base_code_executor.BaseCodeExecutor] = None, before_model_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext, google.adk.models.llm_request.LlmRequest], Union[Awaitable[Optional[google.adk.models.llm_response.LlmResponse]], google.adk.models.llm_response.LlmResponse, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext, google.adk.models.llm_request.LlmRequest], Union[Awaitable[Optional[google.adk.models.llm_response.LlmResponse]], google.adk.models.llm_response.LlmResponse, NoneType]]], NoneType] = None, after_model_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext, google.adk.models.llm_response.LlmResponse], Union[Awaitable[Optional[google.adk.models.llm_response.LlmResponse]], google.adk.models.llm_response.LlmResponse, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext, google.adk.models.llm_response.LlmResponse], Union[Awaitable[Optional[google.adk.models.llm_response.LlmResponse]], google.adk.models.llm_response.LlmResponse, NoneType]]], NoneType] = None, before_tool_callback: Union[Callable[[google.adk.tools.base_tool.BaseTool, dict[str, Any], google.adk.tools.tool_context.ToolContext], Union[Awaitable[Optional[dict]], dict, NoneType]], list[Callable[[google.adk.tools.base_tool.BaseTool, dict[str, Any], google.adk.tools.tool_context.ToolContext], Union[Awaitable[Optional[dict]], dict, NoneType]]], NoneType] = None, after_tool_callback: Union[Callable[[google.adk.tools.base_tool.BaseTool, dict[str, Any], google.adk.tools.tool_context.ToolContext, dict], Union[Awaitable[Optional[dict]], dict, NoneType]], list[Callable[[google.adk.tools.base_tool.BaseTool, dict[str, Any], google.adk.tools.tool_context.ToolContext, dict], Union[Awaitable[Optional[dict]], dict, NoneType]]], NoneType] = None) -> None",
              "doc": "LLM-based Agent."
            },
            "LlmAgent": {
              "type": "class",
              "signature": "(*, name: str, description: str = '', parent_agent: Optional[google.adk.agents.base_agent.BaseAgent] = None, sub_agents: list[google.adk.agents.base_agent.BaseAgent] = <factory>, before_agent_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]]], NoneType] = None, after_agent_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]]], NoneType] = None, model: Union[str, google.adk.models.base_llm.BaseLlm] = '', instruction: Union[str, Callable[[google.adk.agents.readonly_context.ReadonlyContext], Union[str, Awaitable[str]]]] = '', global_instruction: Union[str, Callable[[google.adk.agents.readonly_context.ReadonlyContext], Union[str, Awaitable[str]]]] = '', tools: list[typing.Union[typing.Callable, google.adk.tools.base_tool.BaseTool, google.adk.tools.base_toolset.BaseToolset]] = <factory>, generate_content_config: Optional[google.genai.types.GenerateContentConfig] = None, disallow_transfer_to_parent: bool = False, disallow_transfer_to_peers: bool = False, include_contents: Literal['default', 'none'] = 'default', input_schema: Optional[type[pydantic.main.BaseModel]] = None, output_schema: Optional[type[pydantic.main.BaseModel]] = None, output_key: Optional[str] = None, planner: Optional[google.adk.planners.base_planner.BasePlanner] = None, code_executor: Optional[google.adk.code_executors.base_code_executor.BaseCodeExecutor] = None, before_model_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext, google.adk.models.llm_request.LlmRequest], Union[Awaitable[Optional[google.adk.models.llm_response.LlmResponse]], google.adk.models.llm_response.LlmResponse, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext, google.adk.models.llm_request.LlmRequest], Union[Awaitable[Optional[google.adk.models.llm_response.LlmResponse]], google.adk.models.llm_response.LlmResponse, NoneType]]], NoneType] = None, after_model_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext, google.adk.models.llm_response.LlmResponse], Union[Awaitable[Optional[google.adk.models.llm_response.LlmResponse]], google.adk.models.llm_response.LlmResponse, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext, google.adk.models.llm_response.LlmResponse], Union[Awaitable[Optional[google.adk.models.llm_response.LlmResponse]], google.adk.models.llm_response.LlmResponse, NoneType]]], NoneType] = None, before_tool_callback: Union[Callable[[google.adk.tools.base_tool.BaseTool, dict[str, Any], google.adk.tools.tool_context.ToolContext], Union[Awaitable[Optional[dict]], dict, NoneType]], list[Callable[[google.adk.tools.base_tool.BaseTool, dict[str, Any], google.adk.tools.tool_context.ToolContext], Union[Awaitable[Optional[dict]], dict, NoneType]]], NoneType] = None, after_tool_callback: Union[Callable[[google.adk.tools.base_tool.BaseTool, dict[str, Any], google.adk.tools.tool_context.ToolContext, dict], Union[Awaitable[Optional[dict]], dict, NoneType]], list[Callable[[google.adk.tools.base_tool.BaseTool, dict[str, Any], google.adk.tools.tool_context.ToolContext, dict], Union[Awaitable[Optional[dict]], dict, NoneType]]], NoneType] = None) -> None",
              "doc": "LLM-based Agent."
            },
            "_convert_tool_union_to_tools": {
              "type": "function",
              "signature": "(tool_union: 'ToolUnion', ctx: 'ReadonlyContext') -> 'list[BaseTool]'",
              "doc": ""
            }
          }
        },
        "llm_agent_config": {
          "__members__": {
            "LlmAgentConfig": {
              "type": "class",
              "signature": "(*, agent_class: Literal['LlmAgent', ''] = 'LlmAgent', name: str, description: str = '', sub_agents: Optional[List[google.adk.agents.common_configs.AgentRefConfig]] = None, before_agent_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None, after_agent_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None, model: Optional[str] = None, instruction: str, disallow_transfer_to_parent: Optional[bool] = None, disallow_transfer_to_peers: Optional[bool] = None, input_schema: Optional[google.adk.agents.common_configs.CodeConfig] = None, output_schema: Optional[google.adk.agents.common_configs.CodeConfig] = None, output_key: Optional[str] = None, include_contents: Literal['default', 'none'] = 'default', tools: Optional[list[google.adk.tools.base_tool.ToolConfig]] = None, before_model_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None, after_model_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None, before_tool_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None, after_tool_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None, generate_content_config: Optional[google.genai.types.GenerateContentConfig] = None) -> None",
              "doc": "The config for the YAML schema of a LlmAgent."
            }
          }
        },
        "loop_agent": {
          "__members__": {
            "LoopAgent": {
              "type": "class",
              "signature": "(*, name: str, description: str = '', parent_agent: Optional[google.adk.agents.base_agent.BaseAgent] = None, sub_agents: list[google.adk.agents.base_agent.BaseAgent] = <factory>, before_agent_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]]], NoneType] = None, after_agent_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]]], NoneType] = None, max_iterations: Optional[int] = None) -> None",
              "doc": "A shell agent that run its sub-agents in a loop.\n\nWhen sub-agent generates an event with escalate or max_iterations are\nreached, the loop agent will stop."
            }
          }
        },
        "loop_agent_config": {
          "__members__": {
            "LoopAgentConfig": {
              "type": "class",
              "signature": "(*, agent_class: Literal['LoopAgent'] = 'LoopAgent', name: str, description: str = '', sub_agents: Optional[List[google.adk.agents.common_configs.AgentRefConfig]] = None, before_agent_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None, after_agent_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None, max_iterations: Optional[int] = None) -> None",
              "doc": "The config for the YAML schema of a LoopAgent."
            }
          }
        },
        "parallel_agent": {
          "__members__": {
            "ParallelAgent": {
              "type": "class",
              "signature": "(*, name: str, description: str = '', parent_agent: Optional[google.adk.agents.base_agent.BaseAgent] = None, sub_agents: list[google.adk.agents.base_agent.BaseAgent] = <factory>, before_agent_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]]], NoneType] = None, after_agent_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]]], NoneType] = None) -> None",
              "doc": "A shell agent that run its sub-agents in parallel in isolated manner.\n\nThis approach is beneficial for scenarios requiring multiple perspectives or\nattempts on a single task, such as:\n\n- Running different algorithms simultaneously.\n- Generating multiple responses for review by a subsequent evaluation agent."
            },
            "_create_branch_ctx_for_sub_agent": {
              "type": "function",
              "signature": "(agent: 'BaseAgent', sub_agent: 'BaseAgent', invocation_context: 'InvocationContext') -> 'InvocationContext'",
              "doc": "Create isolated branch for every sub-agent."
            },
            "_merge_agent_run": {
              "type": "function",
              "signature": "(agent_runs: 'list[AsyncGenerator[Event, None]]') -> 'AsyncGenerator[Event, None]'",
              "doc": "Merges the agent run event generator.\n\nThis implementation guarantees for each agent, it won't move on until the\ngenerated event is processed by upstream runner.\n\nArgs:\n    agent_runs: A list of async generators that yield events from each agent.\n\nYields:\n    Event: The next event from the merged generator."
            }
          }
        },
        "parallel_agent_config": {
          "__members__": {
            "ParallelAgentConfig": {
              "type": "class",
              "signature": "(*, agent_class: Literal['ParallelAgent'] = 'ParallelAgent', name: str, description: str = '', sub_agents: Optional[List[google.adk.agents.common_configs.AgentRefConfig]] = None, before_agent_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None, after_agent_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None) -> None",
              "doc": "The config for the YAML schema of a ParallelAgent."
            }
          }
        },
        "readonly_context": {
          "__members__": {
            "ReadonlyContext": {
              "type": "class",
              "signature": "(invocation_context: 'InvocationContext') -> 'None'",
              "doc": ""
            }
          }
        },
        "run_config": {
          "__members__": {
            "RunConfig": {
              "type": "class",
              "signature": "(*, speech_config: Optional[google.genai.types.SpeechConfig] = None, response_modalities: Optional[list[str]] = None, save_input_blobs_as_artifacts: bool = False, support_cfc: bool = False, streaming_mode: google.adk.agents.run_config.StreamingMode = <StreamingMode.NONE: None>, output_audio_transcription: Optional[google.genai.types.AudioTranscriptionConfig] = None, input_audio_transcription: Optional[google.genai.types.AudioTranscriptionConfig] = None, realtime_input_config: Optional[google.genai.types.RealtimeInputConfig] = None, enable_affective_dialog: Optional[bool] = None, proactivity: Optional[google.genai.types.ProactivityConfig] = None, session_resumption: Optional[google.genai.types.SessionResumptionConfig] = None, max_llm_calls: int = 500) -> None",
              "doc": "Configs for runtime behavior of agents."
            },
            "StreamingMode": {
              "type": "class",
              "signature": "(*values)",
              "doc": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
            }
          }
        },
        "sequential_agent": {
          "__members__": {
            "SequentialAgent": {
              "type": "class",
              "signature": "(*, config_type: Type[google.adk.agents.base_agent_config.BaseAgentConfig] = <class 'google.adk.agents.sequential_agent_config.SequentialAgentConfig'>, name: str, description: str = '', parent_agent: Optional[google.adk.agents.base_agent.BaseAgent] = None, sub_agents: list[google.adk.agents.base_agent.BaseAgent] = <factory>, before_agent_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]]], NoneType] = None, after_agent_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]]], NoneType] = None) -> None",
              "doc": "A shell agent that runs its sub-agents in sequence."
            }
          }
        },
        "sequential_agent_config": {
          "__members__": {
            "SequentialAgentConfig": {
              "type": "class",
              "signature": "(*, agent_class: Literal['SequentialAgent'] = 'SequentialAgent', name: str, description: str = '', sub_agents: Optional[List[google.adk.agents.common_configs.AgentRefConfig]] = None, before_agent_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None, after_agent_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None) -> None",
              "doc": "The config for the YAML schema of a SequentialAgent."
            }
          }
        },
        "transcription_entry": {
          "__members__": {
            "TranscriptionEntry": {
              "type": "class",
              "signature": "(*, role: Optional[str] = None, data: Union[google.genai.types.Blob, google.genai.types.Content]) -> None",
              "doc": "Store the data that can be used for transcription."
            }
          }
        }
      },
      "artifacts": {
        "base_artifact_service": {
          "__members__": {
            "BaseArtifactService": {
              "type": "class",
              "signature": "()",
              "doc": "Abstract base class for artifact services."
            }
          }
        },
        "gcs_artifact_service": {
          "__members__": {
            "GcsArtifactService": {
              "type": "class",
              "signature": "(bucket_name: 'str', **kwargs)",
              "doc": "An artifact service implementation using Google Cloud Storage (GCS)."
            }
          }
        },
        "in_memory_artifact_service": {
          "__members__": {
            "InMemoryArtifactService": {
              "type": "class",
              "signature": "(*, artifacts: dict[str, list[google.genai.types.Part]] = <factory>) -> None",
              "doc": "An in-memory implementation of the artifact service.\n\nIt is not suitable for multi-threaded production environments. Use it for\ntesting and development only."
            }
          }
        }
      },
      "auth": {
        "auth_credential": {
          "__members__": {
            "AuthCredential": {
              "type": "class",
              "signature": "(*, authType: google.adk.auth.auth_credential.AuthCredentialTypes, resourceRef: Optional[str] = None, apiKey: Optional[str] = None, http: Optional[google.adk.auth.auth_credential.HttpAuth] = None, serviceAccount: Optional[google.adk.auth.auth_credential.ServiceAccount] = None, oauth2: Optional[google.adk.auth.auth_credential.OAuth2Auth] = None, **extra_data: Any) -> None",
              "doc": "Data class representing an authentication credential.\n\nTo exchange for the actual credential, please use\nCredentialExchanger.exchange_credential().\n\nExamples: API Key Auth\nAuthCredential(\n    auth_type=AuthCredentialTypes.API_KEY,\n    api_key=\"1234\",\n)\n\nExample: HTTP Auth\nAuthCredential(\n    auth_type=AuthCredentialTypes.HTTP,\n    http=HttpAuth(\n        scheme=\"basic\",\n        credentials=HttpCredentials(username=\"user\", password=\"password\"),\n    ),\n)\n\nExample: OAuth2 Bearer Token in HTTP Header\nAuthCredential(\n    auth_type=AuthCredentialTypes.HTTP,\n    http=HttpAuth(\n        scheme=\"bearer\",\n        credentials=HttpCredentials(token=\"eyAkaknabna....\"),\n    ),\n)\n\nExample: OAuth2 Auth with Authorization Code Flow\nAuthCredential(\n    auth_type=AuthCredentialTypes.OAUTH2,\n    oauth2=OAuth2Auth(\n        client_id=\"1234\",\n        client_secret=\"secret\",\n    ),\n)\n\nExample: OpenID Connect Auth\nAuthCredential(\n    auth_type=AuthCredentialTypes.OPEN_ID_CONNECT,\n    oauth2=OAuth2Auth(\n        client_id=\"1234\",\n        client_secret=\"secret\",\n        redirect_uri=\"https://example.com\",\n        scopes=[\"scope1\", \"scope2\"],\n    ),\n)\n\nExample: Auth with resource reference\nAuthCredential(\n    auth_type=AuthCredentialTypes.API_KEY,\n    resource_ref=\"projects/1234/locations/us-central1/resources/resource1\",\n)"
            },
            "AuthCredentialTypes": {
              "type": "class",
              "signature": "(*values)",
              "doc": "Represents the type of authentication credential."
            },
            "BaseModelWithConfig": {
              "type": "class",
              "signature": "(**extra_data: Any) -> None",
              "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
            },
            "HttpAuth": {
              "type": "class",
              "signature": "(*, scheme: str, credentials: google.adk.auth.auth_credential.HttpCredentials, **extra_data: Any) -> None",
              "doc": "The credentials and metadata for HTTP authentication."
            },
            "HttpCredentials": {
              "type": "class",
              "signature": "(*, username: Optional[str] = None, password: Optional[str] = None, token: Optional[str] = None, **extra_data: Any) -> None",
              "doc": "Represents the secret token value for HTTP authentication, like user name, password, oauth token, etc."
            },
            "OAuth2Auth": {
              "type": "class",
              "signature": "(*, clientId: Optional[str] = None, clientSecret: Optional[str] = None, authUri: Optional[str] = None, state: Optional[str] = None, redirectUri: Optional[str] = None, authResponseUri: Optional[str] = None, authCode: Optional[str] = None, accessToken: Optional[str] = None, refreshToken: Optional[str] = None, expiresAt: Optional[int] = None, expiresIn: Optional[int] = None, **extra_data: Any) -> None",
              "doc": "Represents credential value and its metadata for a OAuth2 credential."
            },
            "ServiceAccount": {
              "type": "class",
              "signature": "(*, serviceAccountCredential: Optional[google.adk.auth.auth_credential.ServiceAccountCredential] = None, scopes: List[str], useDefaultCredential: Optional[bool] = False, **extra_data: Any) -> None",
              "doc": "Represents Google Service Account configuration."
            },
            "ServiceAccountCredential": {
              "type": "class",
              "signature": "(*, type: str = '', projectId: str, privateKeyId: str, privateKey: str, clientEmail: str, clientId: str, authUri: str, tokenUri: str, authProviderX509CertUrl: str, clientX509CertUrl: str, universeDomain: str, **extra_data: Any) -> None",
              "doc": "Represents Google Service Account configuration.\n\nAttributes:\n  type: The type should be \"service_account\".\n  project_id: The project ID.\n  private_key_id: The ID of the private key.\n  private_key: The private key.\n  client_email: The client email.\n  client_id: The client ID.\n  auth_uri: The authorization URI.\n  token_uri: The token URI.\n  auth_provider_x509_cert_url: URL for auth provider's X.509 cert.\n  client_x509_cert_url: URL for the client's X.509 cert.\n  universe_domain: The universe domain.\n\nExample:\n\n    config = ServiceAccountCredential(\n        type_=\"service_account\",\n        project_id=\"your_project_id\",\n        private_key_id=\"your_private_key_id\",\n        private_key=\"-----BEGIN PRIVATE KEY-----...\",\n        client_email=\"...@....iam.gserviceaccount.com\",\n        client_id=\"your_client_id\",\n        auth_uri=\"https://accounts.google.com/o/oauth2/auth\",\n        token_uri=\"https://oauth2.googleapis.com/token\",\n        auth_provider_x509_cert_url=\"https://www.googleapis.com/oauth2/v1/certs\",\n        client_x509_cert_url=\"https://www.googleapis.com/robot/v1/metadata/x509/...\",\n        universe_domain=\"googleapis.com\"\n    )\n\n\n    config = ServiceAccountConfig.model_construct(**{\n        ...service account config dict\n    })"
            }
          }
        },
        "auth_handler": {
          "__members__": {
            "AuthHandler": {
              "type": "class",
              "signature": "(auth_config: 'AuthConfig')",
              "doc": "A handler that handles the auth flow in Agent Development Kit to help\norchestrate the credential request and response flow (e.g. OAuth flow)\nThis class should only be used by Agent Development Kit."
            }
          }
        },
        "auth_preprocessor": {
          "__members__": {
            "_AuthLlmRequestProcessor": {
              "type": "class",
              "signature": "()",
              "doc": "Handles auth information to build the LLM request."
            }
          }
        },
        "auth_schemes": {
          "__members__": {
            "OAuthGrantType": {
              "type": "class",
              "signature": "(*values)",
              "doc": "Represents the OAuth2 flow (or grant type)."
            },
            "OpenIdConnectWithConfig": {
              "type": "class",
              "signature": "(*, type: fastapi.openapi.models.SecuritySchemeType = <SecuritySchemeType.openIdConnect: 'openIdConnect'>, description: Optional[str] = None, authorization_endpoint: str, token_endpoint: str, userinfo_endpoint: Optional[str] = None, revocation_endpoint: Optional[str] = None, token_endpoint_auth_methods_supported: Optional[List[str]] = None, grant_types_supported: Optional[List[str]] = None, scopes: Optional[List[str]] = None, **extra_data: Any) -> None",
              "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
            }
          }
        },
        "auth_tool": {
          "__members__": {
            "AuthConfig": {
              "type": "class",
              "signature": "(*, authScheme: Union[fastapi.openapi.models.APIKey, fastapi.openapi.models.HTTPBase, fastapi.openapi.models.OAuth2, fastapi.openapi.models.OpenIdConnect, fastapi.openapi.models.HTTPBearer, google.adk.auth.auth_schemes.OpenIdConnectWithConfig], rawAuthCredential: Optional[google.adk.auth.auth_credential.AuthCredential] = None, exchangedAuthCredential: Optional[google.adk.auth.auth_credential.AuthCredential] = None, credentialKey: Optional[str] = None, **data) -> None",
              "doc": "The auth config sent by tool asking client to collect auth credentials and\n\nadk and client will help to fill in the response"
            },
            "AuthToolArguments": {
              "type": "class",
              "signature": "(*, functionCallId: str, authConfig: google.adk.auth.auth_tool.AuthConfig, **extra_data: Any) -> None",
              "doc": "the arguments for the special long running function tool that is used to\n\nrequest end user credentials."
            }
          }
        },
        "credential_manager": {
          "__members__": {
            "CredentialManager": {
              "type": "class",
              "signature": "(auth_config: 'AuthConfig')",
              "doc": "Manages authentication credentials through a structured workflow.\n\nThe CredentialManager orchestrates the complete lifecycle of authentication\ncredentials, from initial loading to final preparation for use. It provides\na centralized interface for handling various credential types and authentication\nschemes while maintaining proper credential hygiene (refresh, exchange, caching).\n\nThis class is only for use by Agent Development Kit.\n\nArgs:\n    auth_config: Configuration containing authentication scheme and credentials\n\nExample:\n    ```python\n    auth_config = AuthConfig(\n        auth_scheme=oauth2_scheme,\n        raw_auth_credential=service_account_credential\n    )\n    manager = CredentialManager(auth_config)\n\n    # Register custom exchanger if needed\n    manager.register_credential_exchanger(\n        AuthCredentialTypes.CUSTOM_TYPE,\n        CustomCredentialExchanger()\n    )\n\n    # Register custom refresher if needed\n    manager.register_credential_refresher(\n        AuthCredentialTypes.CUSTOM_TYPE,\n        CustomCredentialRefresher()\n    )\n\n    # Load and prepare credential\n    credential = await manager.load_auth_credential(callback_context)\n    ```"
            }
          }
        },
        "credential_service": {
          "base_credential_service": {
            "__members__": {
              "BaseCredentialService": {
                "type": "class",
                "signature": "()",
                "doc": "Abstract class for Service that loads / saves tool credentials from / to\nthe backend credential store."
              }
            }
          },
          "in_memory_credential_service": {
            "__members__": {
              "InMemoryCredentialService": {
                "type": "class",
                "signature": "()",
                "doc": "Class for in memory implementation of credential service(Experimental)"
              }
            }
          },
          "session_state_credential_service": {
            "__members__": {
              "SessionStateCredentialService": {
                "type": "class",
                "signature": "()",
                "doc": "Class for implementation of credential service using session state as the\nstore.\nNote: store credential in session may not be secure, use at your own risk."
              }
            }
          }
        },
        "exchanger": {
          "base_credential_exchanger": {
            "__members__": {
              "BaseCredentialExchanger": {
                "type": "class",
                "signature": "()",
                "doc": "Base interface for credential exchangers.\n\nCredential exchangers are responsible for exchanging credentials from\none format or scheme to another."
              },
              "CredentialExchangError": {
                "type": "class",
                "signature": null,
                "doc": "Base exception for credential exchange errors."
              }
            }
          },
          "credential_exchanger_registry": {
            "__members__": {
              "CredentialExchangerRegistry": {
                "type": "class",
                "signature": "()",
                "doc": "Registry for credential exchanger instances."
              }
            }
          },
          "oauth2_credential_exchanger": {
            "__members__": {
              "OAuth2CredentialExchanger": {
                "type": "class",
                "signature": "()",
                "doc": "Exchanges OAuth2 credentials from authorization responses."
              }
            }
          }
        },
        "oauth2_credential_util": {
          "__members__": {
            "create_oauth2_session": {
              "type": "function",
              "signature": "(auth_scheme: 'AuthScheme', auth_credential: 'AuthCredential') -> 'Tuple[Optional[OAuth2Session], Optional[str]]'",
              "doc": "Create an OAuth2 session for token operations.\n\nArgs:\n    auth_scheme: The authentication scheme configuration.\n    auth_credential: The authentication credential.\n\nReturns:\n    Tuple of (OAuth2Session, token_endpoint) or (None, None) if cannot create session."
            },
            "update_credential_with_tokens": {
              "type": "function",
              "signature": "(auth_credential: 'AuthCredential', tokens: 'OAuth2Token') -> 'None'",
              "doc": "Update the credential with new tokens.\n\nArgs:\n    auth_credential: The authentication credential to update.\n    tokens: The OAuth2Token object containing new token information."
            }
          }
        },
        "refresher": {
          "base_credential_refresher": {
            "__members__": {
              "BaseCredentialRefresher": {
                "type": "class",
                "signature": "()",
                "doc": "Base interface for credential refreshers.\n\nCredential refreshers are responsible for checking if a credential is expired\nor needs to be refreshed, and for refreshing it if necessary."
              },
              "CredentialRefresherError": {
                "type": "class",
                "signature": null,
                "doc": "Base exception for credential refresh errors."
              }
            }
          },
          "credential_refresher_registry": {
            "__members__": {
              "CredentialRefresherRegistry": {
                "type": "class",
                "signature": "()",
                "doc": "Registry for credential refresher instances."
              }
            }
          },
          "oauth2_credential_refresher": {
            "__members__": {
              "OAuth2CredentialRefresher": {
                "type": "class",
                "signature": "()",
                "doc": "Refreshes OAuth2 credentials including Google OAuth2 JSON credentials."
              }
            }
          }
        }
      },
      "code_executors": {
        "base_code_executor": {
          "__members__": {
            "BaseCodeExecutor": {
              "type": "class",
              "signature": "(*, optimize_data_file: bool = False, stateful: bool = False, error_retry_attempts: int = 2, code_block_delimiters: List[tuple[str, str]] = [('```tool_code\\n', '\\n```'), ('```python\\n', '\\n```')], execution_result_delimiters: tuple[str, str] = ('```tool_output\\n', '\\n```')) -> None",
              "doc": "Abstract base class for all code executors.\n\nThe code executor allows the agent to execute code blocks from model responses\nand incorporate the execution results into the final response.\n\nAttributes:\n  optimize_data_file: If true, extract and process data files from the model\n    request and attach them to the code executor. Supported data file\n    MimeTypes are [text/csv]. Default to False.\n  stateful: Whether the code executor is stateful. Default to False.\n  error_retry_attempts: The number of attempts to retry on consecutive code\n    execution errors. Default to 2.\n  code_block_delimiters: The list of the enclosing delimiters to identify the\n    code blocks.\n  execution_result_delimiters: The delimiters to format the code execution\n    result."
            }
          }
        },
        "built_in_code_executor": {
          "__members__": {
            "BuiltInCodeExecutor": {
              "type": "class",
              "signature": "(*, optimize_data_file: bool = False, stateful: bool = False, error_retry_attempts: int = 2, code_block_delimiters: List[tuple[str, str]] = [('```tool_code\\n', '\\n```'), ('```python\\n', '\\n```')], execution_result_delimiters: tuple[str, str] = ('```tool_output\\n', '\\n```')) -> None",
              "doc": "A code executor that uses the Model's built-in code executor.\n\nCurrently only supports Gemini 2.0+ models, but will be expanded to\nother models."
            }
          }
        },
        "code_execution_utils": {
          "__members__": {
            "CodeExecutionInput": {
              "type": "class",
              "signature": "(code: str, input_files: list[google.adk.code_executors.code_execution_utils.File] = <factory>, execution_id: Optional[str] = None) -> None",
              "doc": "A structure that contains the input of code execution."
            },
            "CodeExecutionResult": {
              "type": "class",
              "signature": "(stdout: str = '', stderr: str = '', output_files: list[google.adk.code_executors.code_execution_utils.File] = <factory>) -> None",
              "doc": "A structure that contains the result of code execution."
            },
            "CodeExecutionUtils": {
              "type": "class",
              "signature": "()",
              "doc": "Utility functions for code execution."
            },
            "File": {
              "type": "class",
              "signature": "(name: str, content: str, mime_type: str = 'text/plain') -> None",
              "doc": "A structure that contains a file name and its content."
            }
          }
        },
        "code_executor_context": {
          "__members__": {
            "CodeExecutorContext": {
              "type": "class",
              "signature": "(session_state: google.adk.sessions.state.State)",
              "doc": "The persistent context used to configure the code executor."
            }
          }
        },
        "unsafe_local_code_executor": {
          "__members__": {
            "UnsafeLocalCodeExecutor": {
              "type": "class",
              "signature": "(*, optimize_data_file: bool = False, stateful: bool = False, error_retry_attempts: int = 2, code_block_delimiters: List[tuple[str, str]] = [('```tool_code\\n', '\\n```'), ('```python\\n', '\\n```')], execution_result_delimiters: tuple[str, str] = ('```tool_output\\n', '\\n```')) -> None",
              "doc": "A code executor that unsafely execute code in the current local context."
            },
            "_prepare_globals": {
              "type": "function",
              "signature": "(code: 'str', globals_: 'dict[str, Any]') -> 'None'",
              "doc": "Prepare globals for code execution, injecting __name__ if needed."
            }
          }
        },
        "vertex_ai_code_executor": {
          "__members__": {
            "VertexAiCodeExecutor": {
              "type": "class",
              "signature": "(resource_name: 'str' = None, *, optimize_data_file: bool = False, stateful: bool = False, error_retry_attempts: int = 2, code_block_delimiters: List[tuple[str, str]] = [('```tool_code\\n', '\\n```'), ('```python\\n', '\\n```')], execution_result_delimiters: tuple[str, str] = ('```tool_output\\n', '\\n```')) -> None",
              "doc": "A code executor that uses Vertex Code Interpreter Extension to execute code.\n\nAttributes:\n  resource_name: If set, load the existing resource name of the code\n    interpreter extension instead of creating a new one. Format:\n    projects/123/locations/us-central1/extensions/456"
            },
            "_get_code_interpreter_extension": {
              "type": "function",
              "signature": "(resource_name: 'str' = None)",
              "doc": "Returns: Load or create the code interpreter extension."
            }
          }
        }
      },
      "errors": {
        "not_found_error": {
          "__members__": {
            "NotFoundError": {
              "type": "class",
              "signature": "(message='The requested item was not found.')",
              "doc": "Represents an error that occurs when an entity is not found."
            }
          }
        }
      },
      "events": {
        "event": {
          "__members__": {
            "Event": {
              "type": "class",
              "signature": "(*, content: Optional[google.genai.types.Content] = None, groundingMetadata: Optional[google.genai.types.GroundingMetadata] = None, partial: Optional[bool] = None, turnComplete: Optional[bool] = None, errorCode: Optional[str] = None, errorMessage: Optional[str] = None, interrupted: Optional[bool] = None, customMetadata: Optional[dict[str, Any]] = None, usageMetadata: Optional[google.genai.types.GenerateContentResponseUsageMetadata] = None, liveSessionResumptionUpdate: Optional[google.genai.types.LiveServerSessionResumptionUpdate] = None, invocationId: str = '', author: str, actions: google.adk.events.event_actions.EventActions = <factory>, longRunningToolIds: Optional[set[str]] = None, branch: Optional[str] = None, id: str = '', timestamp: float = <factory>) -> None",
              "doc": "Represents an event in a conversation between agents and users.\n\nIt is used to store the content of the conversation, as well as the actions\ntaken by the agents like function calls, etc.\n\nAttributes:\n  invocation_id: Required. The invocation ID of the event. Should be non-empty\n    before appending to a session.\n  author: Required. \"user\" or the name of the agent, indicating who appended\n    the event to the session.\n  actions: The actions taken by the agent.\n  long_running_tool_ids: The ids of the long running function calls.\n  branch: The branch of the event.\n  id: The unique identifier of the event.\n  timestamp: The timestamp of the event.\n  get_function_calls: Returns the function calls in the event."
            }
          }
        },
        "event_actions": {
          "__members__": {
            "EventActions": {
              "type": "class",
              "signature": "(*, skipSummarization: Optional[bool] = None, stateDelta: dict[str, object] = <factory>, artifactDelta: dict[str, int] = <factory>, transferToAgent: Optional[str] = None, escalate: Optional[bool] = None, requestedAuthConfigs: dict[str, google.adk.auth.auth_tool.AuthConfig] = <factory>) -> None",
              "doc": "Represents the actions attached to an event."
            }
          }
        }
      },
      "examples": {
        "base_example_provider": {
          "__members__": {
            "BaseExampleProvider": {
              "type": "class",
              "signature": "()",
              "doc": "Base class for example providers.\n\nThis class defines the interface for providing examples for a given query."
            }
          }
        },
        "example": {
          "__members__": {
            "Example": {
              "type": "class",
              "signature": "(*, input: google.genai.types.Content, output: list[google.genai.types.Content]) -> None",
              "doc": "A few-shot example.\n\nAttributes:\n  input: The input content for the example.\n  output: The expected output content for the example."
            }
          }
        },
        "example_util": {
          "__members__": {
            "_get_latest_message_from_user": {
              "type": "function",
              "signature": "(session: 'Session') -> str",
              "doc": "Gets the latest message from the user.\n\nReturns:\n  The latest message from the user. If not found, returns an empty string."
            },
            "build_example_si": {
              "type": "function",
              "signature": "(examples: Union[list[google.adk.examples.example.Example], google.adk.examples.base_example_provider.BaseExampleProvider], query: str, model: Optional[str]) -> str",
              "doc": ""
            },
            "convert_examples_to_text": {
              "type": "function",
              "signature": "(examples: list[google.adk.examples.example.Example], model: Optional[str]) -> str",
              "doc": "Converts a list of examples to a string that can be used in a system instruction."
            }
          }
        },
        "vertex_ai_example_store": {
          "__members__": {
            "VertexAiExampleStore": {
              "type": "class",
              "signature": "(examples_store_name: str)",
              "doc": "Provides examples from Vertex example store."
            }
          }
        }
      },
      "memory": {
        "_utils": {
          "__members__": {
            "format_timestamp": {
              "type": "function",
              "signature": "(timestamp: 'float') -> 'str'",
              "doc": "Formats the timestamp of the memory entry."
            }
          }
        },
        "base_memory_service": {
          "__members__": {
            "BaseMemoryService": {
              "type": "class",
              "signature": "()",
              "doc": "Base class for memory services.\n\nThe service provides functionalities to ingest sessions into memory so that\nthe memory can be used for user queries."
            },
            "SearchMemoryResponse": {
              "type": "class",
              "signature": "(*, memories: list[google.adk.memory.memory_entry.MemoryEntry] = <factory>) -> None",
              "doc": "Represents the response from a memory search.\n\nAttributes:\n    memories: A list of memory entries that relate to the search query."
            }
          }
        },
        "in_memory_memory_service": {
          "__members__": {
            "InMemoryMemoryService": {
              "type": "class",
              "signature": "()",
              "doc": "An in-memory memory service for prototyping purpose only.\n\nUses keyword matching instead of semantic search.\n\nThis class is thread-safe, however, it should be used for testing and\ndevelopment only."
            },
            "_extract_words_lower": {
              "type": "function",
              "signature": "(text: 'str') -> 'set[str]'",
              "doc": "Extracts words from a string and converts them to lowercase."
            },
            "_user_key": {
              "type": "function",
              "signature": "(app_name: 'str', user_id: 'str')",
              "doc": ""
            }
          }
        },
        "memory_entry": {
          "__members__": {
            "MemoryEntry": {
              "type": "class",
              "signature": "(*, content: google.genai.types.Content, author: Optional[str] = None, timestamp: Optional[str] = None) -> None",
              "doc": "Represent one memory entry."
            }
          }
        },
        "vertex_ai_memory_bank_service": {
          "__members__": {
            "VertexAiMemoryBankService": {
              "type": "class",
              "signature": "(project: 'Optional[str]' = None, location: 'Optional[str]' = None, agent_engine_id: 'Optional[str]' = None)",
              "doc": "Implementation of the BaseMemoryService using Vertex AI Memory Bank."
            },
            "_convert_api_response": {
              "type": "function",
              "signature": "(api_response) -> 'Dict[str, Any]'",
              "doc": "Converts the API response to a JSON object based on the type."
            },
            "_should_filter_out_event": {
              "type": "function",
              "signature": "(content: 'types.Content') -> 'bool'",
              "doc": "Returns whether the event should be filtered out."
            }
          }
        },
        "vertex_ai_rag_memory_service": {
          "__members__": {
            "VertexAiRagMemoryService": {
              "type": "class",
              "signature": "(rag_corpus: 'Optional[str]' = None, similarity_top_k: 'Optional[int]' = None, vector_distance_threshold: 'float' = 10)",
              "doc": "A memory service that uses Vertex AI RAG for storage and retrieval."
            },
            "_merge_event_lists": {
              "type": "function",
              "signature": "(event_lists: 'list[list[Event]]') -> 'list[list[Event]]'",
              "doc": "Merge event lists that have overlapping timestamps."
            }
          }
        }
      },
      "models": {
        "base_llm": {
          "__members__": {
            "BaseLlm": {
              "type": "class",
              "signature": "(*, model: str) -> None",
              "doc": "The BaseLLM class.\n\nAttributes:\n  model: The name of the LLM, e.g. gemini-1.5-flash or gemini-1.5-flash-001."
            }
          }
        },
        "base_llm_connection": {
          "__members__": {
            "BaseLlmConnection": {
              "type": "class",
              "signature": "()",
              "doc": "The base class for a live model connection."
            }
          }
        },
        "gemini_llm_connection": {
          "__members__": {
            "GeminiLlmConnection": {
              "type": "class",
              "signature": "(gemini_session: 'live.AsyncSession')",
              "doc": "The Gemini model connection."
            }
          }
        },
        "google_llm": {
          "__members__": {
            "Gemini": {
              "type": "class",
              "signature": "(*, model: str = 'gemini-1.5-flash', retry_options: Optional[google.genai.types.HttpRetryOptions] = None) -> None",
              "doc": "Integration for Gemini models.\n\nAttributes:\n  model: The name of the Gemini model."
            },
            "_build_function_declaration_log": {
              "type": "function",
              "signature": "(func_decl: 'types.FunctionDeclaration') -> 'str'",
              "doc": ""
            },
            "_build_request_log": {
              "type": "function",
              "signature": "(req: 'LlmRequest') -> 'str'",
              "doc": ""
            },
            "_build_response_log": {
              "type": "function",
              "signature": "(resp: 'types.GenerateContentResponse') -> 'str'",
              "doc": ""
            },
            "_remove_display_name_if_present": {
              "type": "function",
              "signature": "(data_obj: 'Union[types.Blob, types.FileData, None]')",
              "doc": "Sets display_name to None for the Gemini API (non-Vertex) backend.\n\nThis backend does not support the display_name parameter for file uploads,\nso it must be removed to prevent request failures."
            }
          }
        },
        "lite_llm": {
          "__members__": {
            "FunctionChunk": {
              "type": "class",
              "signature": "(*, id: Optional[str], name: Optional[str], args: Optional[str], index: Optional[int] = 0) -> None",
              "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
            },
            "LiteLLMClient": {
              "type": "class",
              "signature": "()",
              "doc": "Provides acompletion method (for better testability)."
            },
            "LiteLlm": {
              "type": "class",
              "signature": "(model: 'str', *, llm_client: google.adk.models.lite_llm.LiteLLMClient = <factory>) -> None",
              "doc": "Wrapper around litellm.\n\nThis wrapper can be used with any of the models supported by litellm. The\nenvironment variable(s) needed for authenticating with the model endpoint must\nbe set prior to instantiating this class.\n\nExample usage:\n```\nos.environ[\"VERTEXAI_PROJECT\"] = \"your-gcp-project-id\"\nos.environ[\"VERTEXAI_LOCATION\"] = \"your-gcp-location\"\n\nagent = Agent(\n    model=LiteLlm(model=\"vertex_ai/claude-3-7-sonnet@20250219\"),\n    ...\n)\n```\n\nAttributes:\n  model: The name of the LiteLlm model.\n  llm_client: The LLM client to use for the model."
            },
            "TextChunk": {
              "type": "class",
              "signature": "(*, text: str) -> None",
              "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
            },
            "UsageMetadataChunk": {
              "type": "class",
              "signature": "(*, prompt_tokens: int, completion_tokens: int, total_tokens: int) -> None",
              "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
            },
            "_build_function_declaration_log": {
              "type": "function",
              "signature": "(func_decl: 'types.FunctionDeclaration') -> 'str'",
              "doc": "Builds a function declaration log.\n\nArgs:\n  func_decl: The function declaration to convert.\n\nReturns:\n  The function declaration log."
            },
            "_build_request_log": {
              "type": "function",
              "signature": "(req: 'LlmRequest') -> 'str'",
              "doc": "Builds a request log.\n\nArgs:\n  req: The request to convert.\n\nReturns:\n  The request log."
            },
            "_content_to_message_param": {
              "type": "function",
              "signature": "(content: 'types.Content') -> 'Union[Message, list[Message]]'",
              "doc": "Converts a types.Content to a litellm Message or list of Messages.\n\nHandles multipart function responses by returning a list of\nChatCompletionToolMessage objects if multiple function_response parts exist.\n\nArgs:\n  content: The content to convert.\n\nReturns:\n  A litellm Message, a list of litellm Messages."
            },
            "_function_declaration_to_tool_param": {
              "type": "function",
              "signature": "(function_declaration: 'types.FunctionDeclaration') -> 'dict'",
              "doc": "Converts a types.FunctionDeclaration to a openapi spec dictionary.\n\nArgs:\n  function_declaration: The function declaration to convert.\n\nReturns:\n  The openapi spec dictionary representation of the function declaration."
            },
            "_get_completion_inputs": {
              "type": "function",
              "signature": "(llm_request: 'LlmRequest') -> 'Tuple[List[Message], Optional[List[Dict]], Optional[types.SchemaUnion], Optional[Dict]]'",
              "doc": "Converts an LlmRequest to litellm inputs and extracts generation params.\n\nArgs:\n  llm_request: The LlmRequest to convert.\n\nReturns:\n  The litellm inputs (message list, tool dictionary, response format and generation params)."
            },
            "_get_content": {
              "type": "function",
              "signature": "(parts: 'Iterable[types.Part]') -> 'Union[OpenAIMessageContent, str]'",
              "doc": "Converts a list of parts to litellm content.\n\nArgs:\n  parts: The parts to convert.\n\nReturns:\n  The litellm content."
            },
            "_message_to_generate_content_response": {
              "type": "function",
              "signature": "(message: 'Message', is_partial: 'bool' = False) -> 'LlmResponse'",
              "doc": "Converts a litellm message to LlmResponse.\n\nArgs:\n  message: The message to convert.\n  is_partial: Whether the message is partial.\n\nReturns:\n  The LlmResponse."
            },
            "_model_response_to_chunk": {
              "type": "function",
              "signature": "(response: 'ModelResponse') -> 'Generator[Tuple[Optional[Union[TextChunk, FunctionChunk, UsageMetadataChunk]], Optional[str]], None, None]'",
              "doc": "Converts a litellm message to text, function or usage metadata chunk.\n\nArgs:\n  response: The response from the model.\n\nYields:\n  A tuple of text or function or usage metadata chunk and finish reason."
            },
            "_model_response_to_generate_content_response": {
              "type": "function",
              "signature": "(response: 'ModelResponse') -> 'LlmResponse'",
              "doc": "Converts a litellm response to LlmResponse. Also adds usage metadata.\n\nArgs:\n  response: The model response.\n\nReturns:\n  The LlmResponse."
            },
            "_safe_json_serialize": {
              "type": "function",
              "signature": "(obj) -> 'str'",
              "doc": "Convert any Python object to a JSON-serializable type or string.\n\nArgs:\n  obj: The object to serialize.\n\nReturns:\n  The JSON-serialized object string or string."
            },
            "_schema_to_dict": {
              "type": "function",
              "signature": "(schema: 'types.Schema') -> 'dict'",
              "doc": "Recursively converts a types.Schema to a pure-python dict\nwith all enum values written as lower-case strings.\n\nArgs:\n  schema: The schema to convert.\n\nReturns:\n  The dictionary representation of the schema."
            },
            "_to_litellm_role": {
              "type": "function",
              "signature": "(role: 'Optional[str]') -> \"Literal['user', 'assistant']\"",
              "doc": "Converts a types.Content role to a litellm role.\n\nArgs:\n  role: The types.Content role.\n\nReturns:\n  The litellm role."
            }
          }
        },
        "llm_request": {
          "__members__": {
            "LlmRequest": {
              "type": "class",
              "signature": "(*, model: Optional[str] = None, contents: list[google.genai.types.Content] = <factory>, config: google.genai.types.GenerateContentConfig = <factory>, live_connect_config: google.genai.types.LiveConnectConfig = <factory>, tools_dict: dict[str, google.adk.tools.base_tool.BaseTool] = <factory>) -> None",
              "doc": "LLM request class that allows passing in tools, output schema and system\n\ninstructions to the model.\n\nAttributes:\n  model: The model name.\n  contents: The contents to send to the model.\n  config: Additional config for the generate content request.\n  tools_dict: The tools dictionary."
            }
          }
        },
        "llm_response": {
          "__members__": {
            "LlmResponse": {
              "type": "class",
              "signature": "(*, content: Optional[google.genai.types.Content] = None, groundingMetadata: Optional[google.genai.types.GroundingMetadata] = None, partial: Optional[bool] = None, turnComplete: Optional[bool] = None, errorCode: Optional[str] = None, errorMessage: Optional[str] = None, interrupted: Optional[bool] = None, customMetadata: Optional[dict[str, Any]] = None, usageMetadata: Optional[google.genai.types.GenerateContentResponseUsageMetadata] = None, liveSessionResumptionUpdate: Optional[google.genai.types.LiveServerSessionResumptionUpdate] = None) -> None",
              "doc": "LLM response class that provides the first candidate response from the\n\nmodel if available. Otherwise, returns error code and message.\n\nAttributes:\n  content: The content of the response.\n  grounding_metadata: The grounding metadata of the response.\n  partial: Indicates whether the text content is part of a unfinished text\n    stream. Only used for streaming mode and when the content is plain text.\n  turn_complete: Indicates whether the response from the model is complete.\n    Only used for streaming mode.\n  error_code: Error code if the response is an error. Code varies by model.\n  error_message: Error message if the response is an error.\n  interrupted: Flag indicating that LLM was interrupted when generating the\n    content. Usually it's due to user interruption during a bidi streaming.\n  custom_metadata: The custom metadata of the LlmResponse."
            }
          }
        },
        "registry": {
          "__members__": {
            "LLMRegistry": {
              "type": "class",
              "signature": "()",
              "doc": "Registry for LLMs."
            }
          }
        }
      },
      "planners": {
        "base_planner": {
          "__members__": {
            "BasePlanner": {
              "type": "class",
              "signature": "()",
              "doc": "Abstract base class for all planners.\n\nThe planner allows the agent to generate plans for the queries to guide its\naction."
            }
          }
        },
        "built_in_planner": {
          "__members__": {
            "BuiltInPlanner": {
              "type": "class",
              "signature": "(*, thinking_config: google.genai.types.ThinkingConfig)",
              "doc": "The built-in planner that uses model's built-in thinking features.\n\nAttributes:\n    thinking_config: Config for model built-in thinking features. An error\n      will be returned if this field is set for models that don't support\n      thinking."
            }
          }
        },
        "plan_re_act_planner": {
          "__members__": {
            "PlanReActPlanner": {
              "type": "class",
              "signature": "()",
              "doc": "Plan-Re-Act planner that constrains the LLM response to generate a plan before any action/observation.\n\nNote: this planner does not require the model to support built-in thinking\nfeatures or setting the thinking config."
            }
          }
        }
      },
      "runners": {
        "__members__": {
          "InMemoryRunner": {
            "type": "class",
            "signature": "(agent: 'BaseAgent', *, app_name: 'str' = 'InMemoryRunner', plugins: 'Optional[list[BasePlugin]]' = None)",
            "doc": "An in-memory Runner for testing and development.\n\nThis runner uses in-memory implementations for artifact, session, and memory\nservices, providing a lightweight and self-contained environment for agent\nexecution.\n\nAttributes:\n    agent: The root agent to run.\n    app_name: The application name of the runner. Defaults to\n      'InMemoryRunner'.\n    _in_memory_session_service: Deprecated. Please don't use. The in-memory\n      session service for the runner."
          },
          "Runner": {
            "type": "class",
            "signature": "(*, app_name: 'str', agent: 'BaseAgent', plugins: 'Optional[List[BasePlugin]]' = None, artifact_service: 'Optional[BaseArtifactService]' = None, session_service: 'BaseSessionService', memory_service: 'Optional[BaseMemoryService]' = None, credential_service: 'Optional[BaseCredentialService]' = None)",
            "doc": "The Runner class is used to run agents.\n\nIt manages the execution of an agent within a session, handling message\nprocessing, event generation, and interaction with various services like\nartifact storage, session management, and memory.\n\nAttributes:\n    app_name: The application name of the runner.\n    agent: The root agent to run.\n    artifact_service: The artifact service for the runner.\n    plugin_manager: The plugin manager for the runner.\n    session_service: The session service for the runner.\n    memory_service: The memory service for the runner."
          }
        }
      },
      "sessions": {
        "_session_util": {
          "__members__": {
            "decode_content": {
              "type": "function",
              "signature": "(content: 'Optional[dict[str, Any]]') -> 'Optional[types.Content]'",
              "doc": "Decodes a content object from a JSON dictionary."
            },
            "decode_grounding_metadata": {
              "type": "function",
              "signature": "(grounding_metadata: 'Optional[dict[str, Any]]') -> 'Optional[types.GroundingMetadata]'",
              "doc": "Decodes a grounding metadata object from a JSON dictionary."
            }
          }
        },
        "base_session_service": {
          "__members__": {
            "BaseSessionService": {
              "type": "class",
              "signature": "()",
              "doc": "Base class for session services.\n\nThe service provides a set of methods for managing sessions and events."
            },
            "GetSessionConfig": {
              "type": "class",
              "signature": "(*, num_recent_events: Optional[int] = None, after_timestamp: Optional[float] = None) -> None",
              "doc": "The configuration of getting a session."
            },
            "ListSessionsResponse": {
              "type": "class",
              "signature": "(*, sessions: list[google.adk.sessions.session.Session] = <factory>) -> None",
              "doc": "The response of listing sessions.\n\nThe events and states are not set within each Session object."
            }
          }
        },
        "database_session_service": {
          "__members__": {
            "Base": {
              "type": "class",
              "signature": "(**kwargs: 'Any') -> 'None'",
              "doc": "Base class for database tables."
            },
            "DatabaseSessionService": {
              "type": "class",
              "signature": "(db_url: 'str', **kwargs: 'Any')",
              "doc": "A session service that uses a database for storage."
            },
            "DynamicJSON": {
              "type": "class",
              "signature": "(*args: 'Any', **kwargs: 'Any')",
              "doc": "A JSON-like type that uses JSONB on PostgreSQL and TEXT with JSON serialization for other databases."
            },
            "PreciseTimestamp": {
              "type": "class",
              "signature": "(*args: 'Any', **kwargs: 'Any')",
              "doc": "Represents a timestamp precise to the microsecond."
            },
            "StorageAppState": {
              "type": "class",
              "signature": "(**kwargs)",
              "doc": "Represents an app state stored in the database."
            },
            "StorageEvent": {
              "type": "class",
              "signature": "(**kwargs)",
              "doc": "Represents an event stored in the database."
            },
            "StorageSession": {
              "type": "class",
              "signature": "(**kwargs)",
              "doc": "Represents a session stored in the database."
            },
            "StorageUserState": {
              "type": "class",
              "signature": "(**kwargs)",
              "doc": "Represents a user state stored in the database."
            },
            "_extract_state_delta": {
              "type": "function",
              "signature": "(state: 'dict[str, Any]')",
              "doc": ""
            },
            "_merge_state": {
              "type": "function",
              "signature": "(app_state, user_state, session_state)",
              "doc": ""
            }
          }
        },
        "in_memory_session_service": {
          "__members__": {
            "InMemorySessionService": {
              "type": "class",
              "signature": "()",
              "doc": "An in-memory implementation of the session service.\n\nIt is not suitable for multi-threaded production environments. Use it for\ntesting and development only."
            }
          }
        },
        "session": {
          "__members__": {
            "Session": {
              "type": "class",
              "signature": "(*, id: str, appName: str, userId: str, state: dict[str, typing.Any] = <factory>, events: list[google.adk.events.event.Event] = <factory>, lastUpdateTime: float = 0.0) -> None",
              "doc": "Represents a series of interactions between a user and agents.\n\nAttributes:\n  id: The unique identifier of the session.\n  app_name: The name of the app.\n  user_id: The id of the user.\n  state: The state of the session.\n  events: The events of the session, e.g. user input, model response, function\n    call/response, etc.\n  last_update_time: The last update time of the session."
            }
          }
        },
        "state": {
          "__members__": {
            "State": {
              "type": "class",
              "signature": "(value: dict[str, typing.Any], delta: dict[str, typing.Any])",
              "doc": "A state dict that maintain the current value and the pending-commit delta."
            }
          }
        },
        "vertex_ai_session_service": {
          "__members__": {
            "VertexAiSessionService": {
              "type": "class",
              "signature": "(project: 'Optional[str]' = None, location: 'Optional[str]' = None, agent_engine_id: 'Optional[str]' = None)",
              "doc": "Connects to the Vertex AI Agent Engine Session Service using GenAI API client.\n\nhttps://cloud.google.com/vertex-ai/generative-ai/docs/agent-engine/sessions/overview"
            },
            "_convert_api_response": {
              "type": "function",
              "signature": "(api_response)",
              "doc": "Converts the API response to a JSON object based on the type."
            },
            "_convert_event_to_json": {
              "type": "function",
              "signature": "(event: 'Event') -> 'Dict[str, Any]'",
              "doc": ""
            },
            "_from_api_event": {
              "type": "function",
              "signature": "(api_event: 'Dict[str, Any]') -> 'Event'",
              "doc": ""
            },
            "_is_vertex_express_mode": {
              "type": "function",
              "signature": "(project: 'Optional[str]', location: 'Optional[str]') -> 'bool'",
              "doc": "Check if Vertex AI and API key are both enabled replacing project and location, meaning the user is using the Vertex Express Mode."
            }
          }
        }
      },
      "tools": {
        "_automatic_function_calling_util": {
          "__members__": {
            "_annotate_nullable_fields": {
              "type": "function",
              "signature": "(schema: 'Dict')",
              "doc": ""
            },
            "_annotate_required_fields": {
              "type": "function",
              "signature": "(schema: 'Dict')",
              "doc": ""
            },
            "_get_fields_dict": {
              "type": "function",
              "signature": "(func: 'Callable') -> 'Dict'",
              "doc": ""
            },
            "_get_pydantic_schema": {
              "type": "function",
              "signature": "(func: 'Callable') -> 'Dict'",
              "doc": ""
            },
            "_get_return_type": {
              "type": "function",
              "signature": "(func: 'Callable') -> 'Any'",
              "doc": ""
            },
            "_map_pydantic_type_to_property_schema": {
              "type": "function",
              "signature": "(property_schema: 'Dict')",
              "doc": ""
            },
            "_map_pydantic_type_to_schema_type": {
              "type": "function",
              "signature": "(schema: 'Dict')",
              "doc": ""
            },
            "_process_pydantic_schema": {
              "type": "function",
              "signature": "(vertexai: 'bool', schema: 'Dict') -> 'Dict'",
              "doc": ""
            },
            "_remove_any_of": {
              "type": "function",
              "signature": "(schema: 'Dict')",
              "doc": ""
            },
            "_remove_default": {
              "type": "function",
              "signature": "(schema: 'Dict')",
              "doc": ""
            },
            "_remove_nullable": {
              "type": "function",
              "signature": "(schema: 'Dict')",
              "doc": ""
            },
            "_remove_title": {
              "type": "function",
              "signature": "(schema: 'Dict')",
              "doc": ""
            },
            "build_function_declaration": {
              "type": "function",
              "signature": "(func: 'Union[Callable, BaseModel]', ignore_params: 'Optional[list[str]]' = None, variant: 'GoogleLLMVariant' = <GoogleLLMVariant.GEMINI_API: 'GEMINI_API'>) -> 'types.FunctionDeclaration'",
              "doc": ""
            },
            "build_function_declaration_for_langchain": {
              "type": "function",
              "signature": "(vertexai: 'bool', name, description, func, param_pydantic_schema) -> 'types.FunctionDeclaration'",
              "doc": ""
            },
            "build_function_declaration_for_params_for_crewai": {
              "type": "function",
              "signature": "(vertexai: 'bool', name, description, func, param_pydantic_schema) -> 'types.FunctionDeclaration'",
              "doc": ""
            },
            "build_function_declaration_util": {
              "type": "function",
              "signature": "(vertexai: 'bool', name, description, func, before_param_pydantic_schema) -> 'types.FunctionDeclaration'",
              "doc": ""
            },
            "from_function_with_options": {
              "type": "function",
              "signature": "(func: 'Callable', variant: 'GoogleLLMVariant' = <GoogleLLMVariant.GEMINI_API: 'GEMINI_API'>) -> \"'types.FunctionDeclaration'\"",
              "doc": ""
            }
          }
        },
        "_forwarding_artifact_service": {
          "__members__": {
            "ForwardingArtifactService": {
              "type": "class",
              "signature": "(tool_context: 'ToolContext')",
              "doc": "Artifact service that forwards to the parent tool context."
            }
          }
        },
        "_function_parameter_parse_util": {
          "__members__": {
            "_get_required_fields": {
              "type": "function",
              "signature": "(schema: 'types.Schema') -> 'list[str]'",
              "doc": ""
            },
            "_is_builtin_primitive_or_compound": {
              "type": "function",
              "signature": "(annotation: 'inspect.Parameter.annotation') -> 'bool'",
              "doc": ""
            },
            "_is_default_value_compatible": {
              "type": "function",
              "signature": "(default_value: 'Any', annotation: 'inspect.Parameter.annotation') -> 'bool'",
              "doc": ""
            },
            "_parse_schema_from_parameter": {
              "type": "function",
              "signature": "(variant: 'GoogleLLMVariant', param: 'inspect.Parameter', func_name: 'str') -> 'types.Schema'",
              "doc": "parse schema from parameter.\n\nfrom the simplest case to the most complex case."
            },
            "_raise_for_any_of_if_mldev": {
              "type": "function",
              "signature": "(schema: 'types.Schema')",
              "doc": ""
            },
            "_raise_if_schema_unsupported": {
              "type": "function",
              "signature": "(variant: 'GoogleLLMVariant', schema: 'types.Schema')",
              "doc": ""
            },
            "_update_for_default_if_mldev": {
              "type": "function",
              "signature": "(schema: 'types.Schema')",
              "doc": ""
            }
          }
        },
        "_gemini_schema_util": {
          "__members__": {
            "_ExtendedJSONSchema": {
              "type": "class",
              "signature": "(*, type: Union[google.genai.types.JSONSchemaType, list[google.genai.types.JSONSchemaType], NoneType] = None, format: Optional[str] = None, title: Optional[str] = None, description: Optional[str] = None, default: Optional[Any] = None, items: Optional[google.genai.types.JSONSchema] = None, min_items: Optional[int] = None, max_items: Optional[int] = None, enum: Optional[list[Any]] = None, properties: Optional[dict[str, google.genai.types.JSONSchema]] = None, required: Optional[list[str]] = None, min_properties: Optional[int] = None, max_properties: Optional[int] = None, minimum: Optional[float] = None, maximum: Optional[float] = None, min_length: Optional[int] = None, max_length: Optional[int] = None, pattern: Optional[str] = None, any_of: Optional[list[google.genai.types.JSONSchema]] = None, property_ordering: Optional[list[str]] = None) -> None",
              "doc": "A subset of JSON Schema according to 2020-12 JSON Schema draft.\n\nRepresents a subset of a JSON Schema object that is used by the Gemini model.\nThe difference between this class and the Schema class is that this class is\ncompatible with OpenAPI 3.1 schema objects. And the Schema class is used to\nmake API call to Gemini model."
            },
            "_sanitize_schema_formats_for_gemini": {
              "type": "function",
              "signature": "(schema: 'dict[str, Any]') -> 'dict[str, Any]'",
              "doc": "Filters the schema to only include fields that are supported by JSONSchema."
            },
            "_sanitize_schema_type": {
              "type": "function",
              "signature": "(schema: 'dict[str, Any]') -> 'dict[str, Any]'",
              "doc": ""
            },
            "_to_gemini_schema": {
              "type": "function",
              "signature": "(openapi_schema: 'dict[str, Any]') -> 'Schema'",
              "doc": "Converts an OpenAPI schema dictionary to a Gemini Schema object."
            },
            "_to_snake_case": {
              "type": "function",
              "signature": "(text: 'str') -> 'str'",
              "doc": "Converts a string into snake_case.\n\nHandles lowerCamelCase, UpperCamelCase, or space-separated case, acronyms\n(e.g., \"REST API\") and consecutive uppercase letters correctly.  Also handles\nmixed cases with and without spaces.\n\nExamples:\n```\nto_snake_case('camelCase') -> 'camel_case'\nto_snake_case('UpperCamelCase') -> 'upper_camel_case'\nto_snake_case('space separated') -> 'space_separated'\n```\n\nArgs:\n    text: The input string.\n\nReturns:\n    The snake_case version of the string."
            }
          }
        },
        "_memory_entry_utils": {
          "__members__": {
            "extract_text": {
              "type": "function",
              "signature": "(memory: 'MemoryEntry', splitter: 'str' = ' ') -> 'str'",
              "doc": "Extracts the text from the memory entry."
            }
          }
        },
        "agent_tool": {
          "__members__": {
            "AgentTool": {
              "type": "class",
              "signature": "(agent: 'BaseAgent', skip_summarization: 'bool' = False)",
              "doc": "A tool that wraps an agent.\n\nThis tool allows an agent to be called as a tool within a larger application.\nThe agent's input schema is used to define the tool's input parameters, and\nthe agent's output is returned as the tool's result.\n\nAttributes:\n  agent: The agent to wrap.\n  skip_summarization: Whether to skip summarization of the agent output."
            },
            "AgentToolConfig": {
              "type": "class",
              "signature": "(*, agent: google.adk.agents.common_configs.AgentRefConfig, skip_summarization: bool = False) -> None",
              "doc": "The config for the AgentTool."
            }
          }
        },
        "apihub_tool": {
          "apihub_toolset": {
            "__members__": {
              "APIHubToolset": {
                "type": "class",
                "signature": "(*, apihub_resource_name: 'str', access_token: 'Optional[str]' = None, service_account_json: 'Optional[str]' = None, name: 'str' = '', description: 'str' = '', lazy_load_spec=False, auth_scheme: 'Optional[AuthScheme]' = None, auth_credential: 'Optional[AuthCredential]' = None, apihub_client: 'Optional[APIHubClient]' = None, tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None)",
                "doc": "APIHubTool generates tools from a given API Hub resource.\n\nExamples::\n\n  apihub_toolset = APIHubToolset(\n      apihub_resource_name=\"projects/test-project/locations/us-central1/apis/test-api\",\n      service_account_json=\"...\",\n      tool_filter=lambda tool, ctx=None: tool.name in ('my_tool',\n      'my_other_tool')\n  )\n\n  # Get all available tools\n  agent = LlmAgent(tools=apihub_toolset)\n\n**apihub_resource_name** is the resource name from API Hub. It must include\nAPI name, and can optionally include API version and spec name.\n\n- If apihub_resource_name includes a spec resource name, the content of that\n  spec will be used for generating the tools.\n- If apihub_resource_name includes only an api or a version name, the\n  first spec of the first version of that API will be used."
              }
            }
          },
          "clients": {
            "apihub_client": {
              "__members__": {
                "APIHubClient": {
                  "type": "class",
                  "signature": "(*, access_token: 'Optional[str]' = None, service_account_json: 'Optional[str]' = None)",
                  "doc": "Client for interacting with the API Hub service."
                },
                "BaseAPIHubClient": {
                  "type": "class",
                  "signature": "()",
                  "doc": "Base class for API Hub clients."
                }
              }
            },
            "secret_client": {
              "__members__": {
                "SecretManagerClient": {
                  "type": "class",
                  "signature": "(service_account_json: 'Optional[str]' = None, auth_token: 'Optional[str]' = None)",
                  "doc": "A client for interacting with Google Cloud Secret Manager.\n\nThis class provides a simplified interface for retrieving secrets from\nSecret Manager, handling authentication using either a service account\nJSON keyfile (passed as a string) or a pre-existing authorization token.\n\nAttributes:\n    _credentials:  Google Cloud credentials object (ServiceAccountCredentials\n      or Credentials).\n    _client: Secret Manager client instance."
                }
              }
            }
          }
        },
        "application_integration_tool": {
          "application_integration_toolset": {
            "__members__": {
              "ApplicationIntegrationToolset": {
                "type": "class",
                "signature": "(project: 'str', location: 'str', integration: 'Optional[str]' = None, triggers: 'Optional[List[str]]' = None, connection: 'Optional[str]' = None, entity_operations: 'Optional[str]' = None, actions: 'Optional[list[str]]' = None, tool_name_prefix: 'Optional[str]' = '', tool_instructions: 'Optional[str]' = '', service_account_json: 'Optional[str]' = None, auth_scheme: 'Optional[AuthScheme]' = None, auth_credential: 'Optional[AuthCredential]' = None, tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None)",
                "doc": "ApplicationIntegrationToolset generates tools from a given Application\nIntegration or Integration Connector resource.\n\nExample Usage::\n\n  # Get all available tools for an integration with api trigger\n  application_integration_toolset = ApplicationIntegrationToolset(\n      project=\"test-project\",\n      location=\"us-central1\"\n      integration=\"test-integration\",\n      triggers=[\"api_trigger/test_trigger\"],\n      service_account_credentials={...},\n  )\n\n  # Get all available tools for a connection using entity operations and\n  # actions\n  # Note: Find the list of supported entity operations and actions for a\n  # connection using integration connector apis:\n  # https://cloud.google.com/integration-connectors/docs/reference/rest/v1/projects.locations.connections.connectionSchemaMetadata\n  application_integration_toolset = ApplicationIntegrationToolset(\n      project=\"test-project\",\n      location=\"us-central1\"\n      connection=\"test-connection\",\n      entity_operations=[\"EntityId1\": [\"LIST\",\"CREATE\"], \"EntityId2\": []],\n      #empty list for actions means all operations on the entity are supported\n      actions=[\"action1\"],\n      service_account_credentials={...},\n  )\n\n  # Feed the toolset to agent\n  agent = LlmAgent(tools=[\n      ...,\n      application_integration_toolset,\n  ])"
              }
            }
          },
          "integration_connector_tool": {
            "__members__": {
              "IntegrationConnectorTool": {
                "type": "class",
                "signature": "(name: 'str', description: 'str', connection_name: 'str', connection_host: 'str', connection_service_name: 'str', entity: 'str', operation: 'str', action: 'str', rest_api_tool: 'RestApiTool', auth_scheme: 'Optional[Union[AuthScheme, str]]' = None, auth_credential: 'Optional[Union[AuthCredential, str]]' = None)",
                "doc": "A tool that wraps a RestApiTool to interact with a specific Application Integration endpoint.\n\nThis tool adds Application Integration specific context like connection\ndetails, entity, operation, and action to the underlying REST API call\nhandled by RestApiTool. It prepares the arguments and then delegates the\nactual API call execution to the contained RestApiTool instance.\n\n* Generates request params and body\n* Attaches auth credentials to API call.\n\nExample::\n\n  # Each API operation in the spec will be turned into its own tool\n  # Name of the tool is the operationId of that operation, in snake case\n  operations = OperationGenerator().parse(openapi_spec_dict)\n  tool = [RestApiTool.from_parsed_operation(o) for o in operations]"
              }
            }
          }
        },
        "authenticated_function_tool": {
          "__members__": {
            "AuthenticatedFunctionTool": {
              "type": "class",
              "signature": "(*, func: 'Callable[..., Any]', auth_config: 'AuthConfig' = None, response_for_auth_required: 'Optional[Union[dict[str, Any], str]]' = None)",
              "doc": "A FunctionTool that handles authentication before the actual tool logic\ngets called. Functions can accept a special `credential` argument which is the\ncredential ready for use.(Experimental)"
            }
          }
        },
        "base_authenticated_tool": {
          "__members__": {
            "BaseAuthenticatedTool": {
              "type": "class",
              "signature": "(*, name, description, auth_config: 'AuthConfig' = None, response_for_auth_required: 'Optional[Union[dict[str, Any], str]]' = None)",
              "doc": "A base tool class that handles authentication before the actual tool logic\ngets called. Functions can accept a special `credential` argument which is the\ncredential ready for use.(Experimental)"
            }
          }
        },
        "base_tool": {
          "__members__": {
            "BaseTool": {
              "type": "class",
              "signature": "(*, name, description, is_long_running: 'bool' = False)",
              "doc": "The base class for all tools."
            },
            "BaseToolConfig": {
              "type": "class",
              "signature": "() -> None",
              "doc": "The base configurations for all the tools."
            },
            "ToolArgsConfig": {
              "type": "class",
              "signature": "(**extra_data: Any) -> None",
              "doc": "The configuration for tool arguments.\n\nThis config allows arbitrary key-value pairs as tool arguments."
            },
            "ToolConfig": {
              "type": "class",
              "signature": "(*, name: str, args: Optional[google.adk.tools.base_tool.ToolArgsConfig] = None) -> None",
              "doc": "The configuration for a tool.\n\nThe config supports these types of tools:\n1. ADK built-in tools\n2. User-defined tool instances\n3. User-defined tool classes\n4. User-defined functions that generate tool instances\n5. User-defined function tools\n\nFor examples:\n\n  1. For ADK built-in tool instances or classes in `google.adk.tools` package,\n  they can be referenced directly with the `name` and optionally with\n  `config`.\n\n  ```\n  tools:\n    - name: google_search\n    - name: AgentTool\n      config:\n        agent: ./another_agent.yaml\n        skip_summarization: true\n  ```\n\n  2. For user-defined tool instances, the `name` is the fully qualified path\n  to the tool instance.\n\n  ```\n  tools:\n    - name: my_package.my_module.my_tool\n  ```\n\n  3. For user-defined tool classes (custom tools), the `name` is the fully\n  qualified path to the tool class and `config` is the arguments for the tool.\n\n  ```\n  tools:\n    - name: my_package.my_module.my_tool_class\n      config:\n        my_tool_arg1: value1\n        my_tool_arg2: value2\n  ```\n\n  4. For user-defined functions that generate tool instances, the `name` is the\n  fully qualified path to the function and `config` is passed to the function\n  as arguments.\n\n  ```\n  tools:\n    - name: my_package.my_module.my_tool_function\n      config:\n        my_function_arg1: value1\n        my_function_arg2: value2\n  ```\n\n  The function must have the following signature:\n  ```\n  def my_function(config: ToolArgsConfig) -> BaseTool:\n    ...\n  ```\n\n  5. For user-defined function tools, the `name` is the fully qualified path\n  to the function.\n\n  ```\n  tools:\n    - name: my_package.my_module.my_function_tool\n  ```"
            },
            "_find_tool_with_function_declarations": {
              "type": "function",
              "signature": "(llm_request: 'LlmRequest') -> 'Optional[types.Tool]'",
              "doc": ""
            }
          }
        },
        "base_toolset": {
          "__members__": {
            "BaseToolset": {
              "type": "class",
              "signature": "(*, tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None)",
              "doc": "Base class for toolset.\n\nA toolset is a collection of tools that can be used by an agent."
            },
            "ToolPredicate": {
              "type": "class",
              "signature": "(*args, **kwargs)",
              "doc": "Base class for a predicate that defines the interface to decide whether a\n\ntool should be exposed to LLM. Toolset implementer could consider whether to\naccept such instance in the toolset's constructor and apply the predicate in\nget_tools method."
            }
          }
        },
        "bigquery": {
          "bigquery_credentials": {
            "__members__": {
              "BigQueryCredentialsConfig": {
                "type": "class",
                "signature": "(*, credentials: Optional[google.auth.credentials.Credentials] = None, client_id: Optional[str] = None, client_secret: Optional[str] = None, scopes: Optional[List[str]] = None) -> None",
                "doc": "Configuration for Google API tools (Experimental).\n\nPlease do not use this in production, as it may be deprecated later."
              },
              "BigQueryCredentialsManager": {
                "type": "class",
                "signature": "(credentials_config: 'BigQueryCredentialsConfig')",
                "doc": "Manages Google API credentials with automatic refresh and OAuth flow handling.\n\nThis class centralizes credential management so multiple tools can share\nthe same authenticated session without duplicating OAuth logic."
              }
            }
          },
          "bigquery_tool": {
            "__members__": {
              "BigQueryTool": {
                "type": "class",
                "signature": "(func: 'Callable[..., Any]', *, credentials_config: 'Optional[BigQueryCredentialsConfig]' = None, bigquery_tool_config: 'Optional[BigQueryToolConfig]' = None)",
                "doc": "GoogleApiTool class for tools that call Google APIs.\n\nThis class is for developers to handcraft customized Google API tools rather\nthan auto generate Google API tools based on API specs.\n\nThis class handles all the OAuth complexity, credential management,\nand common Google API patterns so subclasses can focus on their\nspecific functionality."
              }
            }
          },
          "bigquery_toolset": {
            "__members__": {
              "BigQueryToolset": {
                "type": "class",
                "signature": "(*, tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None, credentials_config: 'Optional[BigQueryCredentialsConfig]' = None, bigquery_tool_config: 'Optional[BigQueryToolConfig]' = None)",
                "doc": "BigQuery Toolset contains tools for interacting with BigQuery data and metadata."
              }
            }
          },
          "client": {
            "__members__": {
              "get_bigquery_client": {
                "type": "function",
                "signature": "(*, project: 'Optional[str]', credentials: 'Credentials') -> 'bigquery.Client'",
                "doc": "Get a BigQuery client."
              }
            }
          },
          "config": {
            "__members__": {
              "BigQueryToolConfig": {
                "type": "class",
                "signature": "(*, write_mode: google.adk.tools.bigquery.config.WriteMode = <WriteMode.BLOCKED: 'blocked'>, max_query_result_rows: int = 50) -> None",
                "doc": "Configuration for BigQuery tools."
              },
              "WriteMode": {
                "type": "class",
                "signature": "(*values)",
                "doc": "Write mode indicating what levels of write operations are allowed in BigQuery."
              }
            }
          },
          "data_insights_tool": {
            "__members__": {
              "_append_message": {
                "type": "function",
                "signature": "(messages: List[Dict[str, Any]], new_message: Dict[str, Any])",
                "doc": ""
              },
              "_format_bq_table_ref": {
                "type": "function",
                "signature": "(table_ref: Dict[str, str]) -> str",
                "doc": "Formats a BigQuery table reference dictionary into a string."
              },
              "_format_datasource_as_dict": {
                "type": "function",
                "signature": "(datasource: Dict[str, Any]) -> Dict[str, Any]",
                "doc": "Formats a full datasource object into a dictionary with its name and schema."
              },
              "_format_schema_as_dict": {
                "type": "function",
                "signature": "(data: Dict[str, Any]) -> Dict[str, List[Any]]",
                "doc": "Extracts schema fields into a dictionary."
              },
              "_get_property": {
                "type": "function",
                "signature": "(data: Dict[str, Any], field_name: str, default: Any = '') -> Any",
                "doc": "Safely gets a property from a dictionary."
              },
              "_get_stream": {
                "type": "function",
                "signature": "(url: str, ca_payload: Dict[str, Any], headers: Dict[str, str], max_query_result_rows: int) -> List[Dict[str, Any]]",
                "doc": "Sends a JSON request to a streaming API and returns a list of messages."
              },
              "_handle_data_response": {
                "type": "function",
                "signature": "(resp: Dict[str, Any], max_query_result_rows: int) -> Dict[str, Any]",
                "doc": "Formats a data response into a dictionary."
              },
              "_handle_error": {
                "type": "function",
                "signature": "(resp: Dict[str, Any]) -> Dict[str, Dict[str, Any]]",
                "doc": "Formats an error response into a dictionary."
              },
              "_handle_schema_response": {
                "type": "function",
                "signature": "(resp: Dict[str, Any]) -> Dict[str, Any]",
                "doc": "Formats a schema response into a dictionary."
              },
              "_handle_text_response": {
                "type": "function",
                "signature": "(resp: Dict[str, Any]) -> Dict[str, str]",
                "doc": "Formats a text response into a dictionary."
              },
              "_is_json": {
                "type": "function",
                "signature": "(s: str) -> bool",
                "doc": "Checks if a string is a valid JSON object."
              },
              "ask_data_insights": {
                "type": "function",
                "signature": "(project_id: str, user_query_with_context: str, table_references: List[Dict[str, str]], credentials: google.auth.credentials.Credentials, config: google.adk.tools.bigquery.config.BigQueryToolConfig) -> Dict[str, Any]",
                "doc": "Answers questions about structured data in BigQuery tables using natural language.\n\nThis function takes auser's question (which can include conversational\nhistory for context) andreferences to specific BigQuery tables, and sends\nthem to a stateless conversational API.\n\nThe API uses a GenAI agent to understand the question, generate and execute\nSQL queries and Python code, and formulate an answer. This function returns a\ndetailed, sequential log of this entire process, which includes any generated\nSQL or Python code, the data retrieved, and the final text answer.\n\nUse this tool to perform data analysis, get insights, or answer complex\nquestions about the contents of specific BigQuery tables.\n\nArgs:\n    project_id (str): The project that the inquiry is performed in.\n    user_query_with_context (str): The user's question, potentially including\n      conversation history and system instructions for context.\n    table_references (List[Dict[str, str]]): A list of dictionaries, each\n      specifying a BigQuery table to be used as context for the question.\n    credentials (Credentials): The credentials to use for the request.\n    config (BigQueryToolConfig): The configuration for the tool.\n\nReturns:\n    A dictionary with two keys:\n    - 'status': A string indicating the final status (e.g., \"SUCCESS\").\n    - 'response': A list of dictionaries, where each dictionary\n      represents a step in the API's execution process (e.g., SQL\n      generation, data retrieval, final answer).\n\nExample:\n    A query joining multiple tables, showing the full return structure.\n    >>> ask_data_insights(\n    ...     project_id=\"some-project-id\",\n    ...     user_query_with_context=\"Which customer from New York spent the\n    most last month? \"\n    ...                           \"Context: The 'customers' table joins with\n    the 'orders' table \"\n    ...                           \"on the 'customer_id' column.\",\n    ...     table_references=[\n    ...         {\n    ...             \"projectId\": \"my-gcp-project\",\n    ...             \"datasetId\": \"sales_data\",\n    ...             \"tableId\": \"customers\"\n    ...         },\n    ...         {\n    ...             \"projectId\": \"my-gcp-project\",\n    ...             \"datasetId\": \"sales_data\",\n    ...             \"tableId\": \"orders\"\n    ...         }\n    ...     ]\n    ... )\n    {\n      \"status\": \"SUCCESS\",\n      \"response\": [\n        {\n          \"SQL Generated\": \"SELECT t1.customer_name, SUM(t2.order_total) ... \"\n        },\n        {\n          \"Data Retrieved\": {\n            \"headers\": [\"customer_name\", \"total_spent\"],\n            \"rows\": [[\"Jane Doe\", 1234.56]],\n            \"summary\": \"Showing all 1 rows.\"\n          }\n        },\n        {\n          \"Answer\": \"The customer who spent the most was Jane Doe.\"\n        }\n      ]\n    }"
              }
            }
          },
          "metadata_tool": {
            "__members__": {
              "get_dataset_info": {
                "type": "function",
                "signature": "(project_id: 'str', dataset_id: 'str', credentials: 'Credentials') -> 'dict'",
                "doc": "Get metadata information about a BigQuery dataset.\n\nArgs:\n    project_id (str): The Google Cloud project id containing the dataset.\n    dataset_id (str): The BigQuery dataset id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    dict: Dictionary representing the properties of the dataset.\n\nExamples:\n    >>> get_dataset_info(\"bigquery-public-data\", \"cdc_places\")\n    {\n      \"kind\": \"bigquery#dataset\",\n      \"etag\": \"fz9BaiXKgbGi53EpI2rJug==\",\n      \"id\": \"bigquery-public-data:cdc_places\",\n      \"selfLink\": \"https://content-bigquery.googleapis.com/bigquery/v2/projects/bigquery-public-data/datasets/cdc_places\",\n      \"datasetReference\": {\n        \"datasetId\": \"cdc_places\",\n        \"projectId\": \"bigquery-public-data\"\n      },\n      \"description\": \"Local Data for Better Health, County Data\",\n      \"access\": [\n        {\n          \"role\": \"WRITER\",\n          \"specialGroup\": \"projectWriters\"\n        },\n        {\n          \"role\": \"OWNER\",\n          \"specialGroup\": \"projectOwners\"\n        },\n        {\n          \"role\": \"OWNER\",\n          \"userByEmail\": \"some-redacted-email@bigquery-public-data.iam.gserviceaccount.com\"\n        },\n        {\n          \"role\": \"READER\",\n          \"specialGroup\": \"projectReaders\"\n        }\n      ],\n      \"creationTime\": \"1640891845643\",\n      \"lastModifiedTime\": \"1640891845643\",\n      \"location\": \"US\",\n      \"type\": \"DEFAULT\",\n      \"maxTimeTravelHours\": \"168\"\n    }"
              },
              "get_table_info": {
                "type": "function",
                "signature": "(project_id: 'str', dataset_id: 'str', table_id: 'str', credentials: 'Credentials') -> 'dict'",
                "doc": "Get metadata information about a BigQuery table.\n\nArgs:\n    project_id (str): The Google Cloud project id containing the dataset.\n    dataset_id (str): The BigQuery dataset id containing the table.\n    table_id (str): The BigQuery table id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    dict: Dictionary representing the properties of the table.\n\nExamples:\n    >>> get_table_info(\"bigquery-public-data\", \"cdc_places\", \"local_data_for_better_health_county_data\")\n    {\n      \"kind\": \"bigquery#table\",\n      \"etag\": \"wx23aDqmgc39oUSiNuYTAA==\",\n      \"id\": \"bigquery-public-data:cdc_places.local_data_for_better_health_county_data\",\n      \"selfLink\": \"https://content-bigquery.googleapis.com/bigquery/v2/projects/bigquery-public-data/datasets/cdc_places/tables/local_data_for_better_health_county_data\",\n      \"tableReference\": {\n        \"projectId\": \"bigquery-public-data\",\n        \"datasetId\": \"cdc_places\",\n        \"tableId\": \"local_data_for_better_health_county_data\"\n      },\n      \"description\": \"Local Data for Better Health, County Data\",\n      \"schema\": {\n        \"fields\": [\n          {\n            \"name\": \"year\",\n            \"type\": \"INTEGER\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"stateabbr\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"statedesc\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"locationname\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"datasource\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"category\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"measure\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"data_value_unit\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"data_value_type\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"data_value\",\n            \"type\": \"FLOAT\",\n            \"mode\": \"NULLABLE\"\n          }\n        ]\n      },\n      \"numBytes\": \"234849\",\n      \"numLongTermBytes\": \"0\",\n      \"numRows\": \"1000\",\n      \"creationTime\": \"1640891846119\",\n      \"lastModifiedTime\": \"1749427268137\",\n      \"type\": \"TABLE\",\n      \"location\": \"US\",\n      \"numTimeTravelPhysicalBytes\": \"285737\",\n      \"numTotalLogicalBytes\": \"234849\",\n      \"numActiveLogicalBytes\": \"234849\",\n      \"numLongTermLogicalBytes\": \"0\",\n      \"numTotalPhysicalBytes\": \"326557\",\n      \"numActivePhysicalBytes\": \"326557\",\n      \"numLongTermPhysicalBytes\": \"0\",\n      \"numCurrentPhysicalBytes\": \"40820\"\n    }"
              },
              "list_dataset_ids": {
                "type": "function",
                "signature": "(project_id: 'str', credentials: 'Credentials') -> 'list[str]'",
                "doc": "List BigQuery dataset ids in a Google Cloud project.\n\nArgs:\n    project_id (str): The Google Cloud project id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    list[str]: List of the BigQuery dataset ids present in the project.\n\nExamples:\n    >>> list_dataset_ids(\"bigquery-public-data\")\n    ['america_health_rankings',\n     'american_community_survey',\n     'aml_ai_input_dataset',\n     'austin_311',\n     'austin_bikeshare',\n     'austin_crime',\n     'austin_incidents',\n     'austin_waste',\n     'baseball',\n     'bbc_news']"
              },
              "list_table_ids": {
                "type": "function",
                "signature": "(project_id: 'str', dataset_id: 'str', credentials: 'Credentials') -> 'list[str]'",
                "doc": "List table ids in a BigQuery dataset.\n\nArgs:\n    project_id (str): The Google Cloud project id containing the dataset.\n    dataset_id (str): The BigQuery dataset id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    list[str]: List of the tables ids present in the dataset.\n\nExamples:\n    >>> list_table_ids(\"bigquery-public-data\", \"cdc_places\")\n    ['chronic_disease_indicators',\n     'local_data_for_better_health_county_data']"
              }
            }
          },
          "query_tool": {
            "__members__": {
              "execute_sql": {
                "type": "function",
                "signature": "(project_id: 'str', query: 'str', credentials: 'Credentials', config: 'BigQueryToolConfig', tool_context: 'ToolContext') -> 'dict'",
                "doc": "Run a BigQuery or BigQuery ML SQL query in the project and return the result.\n\nArgs:\n    project_id (str): The GCP project id in which the query should be\n      executed.\n    query (str): The BigQuery SQL query to be executed.\n    credentials (Credentials): The credentials to use for the request.\n    config (BigQueryToolConfig): The configuration for the tool.\n    tool_context (ToolContext): The context for the tool.\n\nReturns:\n    dict: Dictionary representing the result of the query.\n          If the result contains the key \"result_is_likely_truncated\" with\n          value True, it means that there may be additional rows matching the\n          query not returned in the result.\n\nExamples:\n    Fetch data or insights from a table:\n\n        >>> execute_sql(\"my_project\",\n        ... \"SELECT island, COUNT(*) AS population \"\n        ... \"FROM bigquery-public-data.ml_datasets.penguins GROUP BY island\")\n        {\n          \"status\": \"SUCCESS\",\n          \"rows\": [\n              {\n                  \"island\": \"Dream\",\n                  \"population\": 124\n              },\n              {\n                  \"island\": \"Biscoe\",\n                  \"population\": 168\n              },\n              {\n                  \"island\": \"Torgersen\",\n                  \"population\": 52\n              }\n          ]\n        }"
              },
              "get_execute_sql": {
                "type": "function",
                "signature": "(config: 'BigQueryToolConfig') -> 'Callable[..., dict]'",
                "doc": "Get the execute_sql tool customized as per the given tool config.\n\nArgs:\n    config: BigQuery tool configuration indicating the behavior of the\n      execute_sql tool.\n\nReturns:\n    callable[..., dict]: A version of the execute_sql tool respecting the tool\n    config."
              }
            }
          }
        },
        "computer_use": {
          "base_computer": {
            "__members__": {
              "BaseComputer": {
                "type": "class",
                "signature": "()",
                "doc": "async defines an interface for computer environments.\n\nThis abstract base class async defines the standard interface for controlling\ncomputer environments, including web browsers and other interactive systems."
              },
              "ComputerEnvironment": {
                "type": "class",
                "signature": "(*values)",
                "doc": "Case insensitive enum for computer environments."
              },
              "ComputerState": {
                "type": "class",
                "signature": "(*, screenshot: bytes = None, url: Optional[str] = None) -> None",
                "doc": "Represents the current state of the computer environment.\n\nAttributes:\n  screenshot: The screenshot in PNG format as bytes.\n  url: The current URL of the webpage being displayed."
              }
            }
          },
          "computer_use_tool": {
            "__members__": {
              "ComputerUseTool": {
                "type": "class",
                "signature": "(*, func: 'Callable[..., Any]', screen_size: 'tuple[int, int]', virtual_screen_size: 'tuple[int, int]' = (1000, 1000))",
                "doc": "A tool that wraps computer control functions for use with LLMs.\n\nThis tool automatically normalizes coordinates from a virtual coordinate space\n(by default 1000x1000) to the actual screen size. This allows LLMs to work\nwith a consistent coordinate system regardless of the actual screen dimensions,\nmaking their output more predictable and easier to handle."
              }
            }
          },
          "computer_use_toolset": {
            "__members__": {
              "ComputerUseToolset": {
                "type": "class",
                "signature": "(*, computer: 'BaseComputer')",
                "doc": "Base class for toolset.\n\nA toolset is a collection of tools that can be used by an agent."
              }
            }
          }
        },
        "enterprise_search_tool": {
          "__members__": {
            "EnterpriseWebSearchTool": {
              "type": "class",
              "signature": "()",
              "doc": "A Gemini 2+ built-in tool using web grounding for Enterprise compliance.\n\nSee the documentation for more details:\nhttps://cloud.google.com/vertex-ai/generative-ai/docs/grounding/web-grounding-enterprise."
            }
          }
        },
        "example_tool": {
          "__members__": {
            "ExampleTool": {
              "type": "class",
              "signature": "(examples: 'Union[list[Example], BaseExampleProvider]')",
              "doc": "A tool that adds (few-shot) examples to the LLM request.\n\nAttributes:\n  examples: The examples to add to the LLM request."
            }
          }
        },
        "exit_loop_tool": {
          "__members__": {
            "exit_loop": {
              "type": "function",
              "signature": "(tool_context: google.adk.tools.tool_context.ToolContext)",
              "doc": "Exits the loop.\n\nCall this function only when you are instructed to do so."
            }
          }
        },
        "function_tool": {
          "__members__": {
            "FunctionTool": {
              "type": "class",
              "signature": "(func: 'Callable[..., Any]')",
              "doc": "A tool that wraps a user-defined Python function.\n\nAttributes:\n  func: The function to wrap."
            }
          }
        },
        "get_user_choice_tool": {
          "__members__": {
            "get_user_choice": {
              "type": "function",
              "signature": "(options: list[str], tool_context: google.adk.tools.tool_context.ToolContext) -> Optional[str]",
              "doc": "Provides the options to the user and asks them to choose one."
            }
          }
        },
        "google_api_tool": {
          "google_api_tool": {
            "__members__": {
              "GoogleApiTool": {
                "type": "class",
                "signature": "(rest_api_tool: 'RestApiTool', client_id: 'Optional[str]' = None, client_secret: 'Optional[str]' = None, service_account: 'Optional[ServiceAccount]' = None)",
                "doc": "The base class for all tools."
              }
            }
          },
          "google_api_toolset": {
            "__members__": {
              "GoogleApiToolset": {
                "type": "class",
                "signature": "(api_name: 'str', api_version: 'str', client_id: 'Optional[str]' = None, client_secret: 'Optional[str]' = None, tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None, service_account: 'Optional[ServiceAccount]' = None)",
                "doc": "Google API Toolset contains tools for interacting with Google APIs.\n\nUsually one toolsets will contains tools only related to one Google API, e.g.\nGoogle Bigquery API toolset will contains tools only related to Google\nBigquery API, like list dataset tool, list table tool etc."
              }
            }
          },
          "google_api_toolsets": {
            "__members__": {
              "BigQueryToolset": {
                "type": "class",
                "signature": "(client_id: 'Optional[str]' = None, client_secret: 'Optional[str]' = None, tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None, service_account: 'Optional[ServiceAccount]' = None)",
                "doc": "Auto-generated Bigquery toolset based on Google BigQuery API v2 spec exposed by Google API discovery API"
              },
              "CalendarToolset": {
                "type": "class",
                "signature": "(client_id: 'Optional[str]' = None, client_secret: 'Optional[str]' = None, tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None, service_account: 'Optional[ServiceAccount]' = None)",
                "doc": "Auto-generated Calendar toolset based on Google Calendar API v3 spec exposed by Google API discovery API"
              },
              "DocsToolset": {
                "type": "class",
                "signature": "(client_id: 'Optional[str]' = None, client_secret: 'Optional[str]' = None, tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None, service_account: 'Optional[ServiceAccount]' = None)",
                "doc": "Auto-generated Docs toolset based on Google Docs API v1 spec exposed by Google API discovery API"
              },
              "GmailToolset": {
                "type": "class",
                "signature": "(client_id: 'Optional[str]' = None, client_secret: 'Optional[str]' = None, tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None, service_account: 'Optional[ServiceAccount]' = None)",
                "doc": "Auto-generated Gmail toolset based on Google Gmail API v1 spec exposed by Google API discovery API"
              },
              "SheetsToolset": {
                "type": "class",
                "signature": "(client_id: 'Optional[str]' = None, client_secret: 'Optional[str]' = None, tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None, service_account: 'Optional[ServiceAccount]' = None)",
                "doc": "Auto-generated Sheets toolset based on Google Sheets API v4 spec exposed by Google API discovery API"
              },
              "SlidesToolset": {
                "type": "class",
                "signature": "(client_id: 'Optional[str]' = None, client_secret: 'Optional[str]' = None, tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None, service_account: 'Optional[ServiceAccount]' = None)",
                "doc": "Auto-generated Slides toolset based on Google Slides API v1 spec exposed by Google API discovery API"
              },
              "YoutubeToolset": {
                "type": "class",
                "signature": "(client_id: 'Optional[str]' = None, client_secret: 'Optional[str]' = None, tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None, service_account: 'Optional[ServiceAccount]' = None)",
                "doc": "Auto-generated Youtube toolset based on Youtube API v3 spec exposed by Google API discovery API"
              }
            }
          },
          "googleapi_to_openapi_converter": {
            "__members__": {
              "GoogleApiToOpenApiConverter": {
                "type": "class",
                "signature": "(api_name: 'str', api_version: 'str')",
                "doc": "Converts Google API Discovery documents to OpenAPI v3 format."
              },
              "main": {
                "type": "function",
                "signature": "()",
                "doc": "Command line interface for the converter."
              }
            }
          }
        },
        "google_search_tool": {
          "__members__": {
            "GoogleSearchTool": {
              "type": "class",
              "signature": "()",
              "doc": "A built-in tool that is automatically invoked by Gemini 2 models to retrieve search results from Google Search.\n\nThis tool operates internally within the model and does not require or perform\nlocal code execution."
            }
          }
        },
        "load_artifacts_tool": {
          "__members__": {
            "LoadArtifactsTool": {
              "type": "class",
              "signature": "()",
              "doc": "A tool that loads the artifacts and adds them to the session."
            }
          }
        },
        "load_memory_tool": {
          "__members__": {
            "LoadMemoryResponse": {
              "type": "class",
              "signature": "(*, memories: list[google.adk.memory.memory_entry.MemoryEntry] = <factory>) -> None",
              "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
            },
            "LoadMemoryTool": {
              "type": "class",
              "signature": "()",
              "doc": "A tool that loads the memory for the current user.\n\nNOTE: Currently this tool only uses text part from the memory."
            },
            "load_memory": {
              "type": "function",
              "signature": "(query: 'str', tool_context: 'ToolContext') -> 'LoadMemoryResponse'",
              "doc": "Loads the memory for the current user.\n\nArgs:\n  query: The query to load the memory for.\n\nReturns:\n  A list of memory results."
            }
          }
        },
        "load_web_page": {
          "__members__": {
            "load_web_page": {
              "type": "function",
              "signature": "(url: str) -> str",
              "doc": "Fetches the content in the url and returns the text in it.\n\nArgs:\n    url (str): The url to browse.\n\nReturns:\n    str: The text content of the url."
            }
          }
        },
        "long_running_tool": {
          "__members__": {
            "LongRunningFunctionTool": {
              "type": "class",
              "signature": "(func: 'Callable')",
              "doc": "A function tool that returns the result asynchronously.\n\nThis tool is used for long-running operations that may take a significant\namount of time to complete. The framework will call the function. Once the\nfunction returns, the response will be returned asynchronously to the\nframework which is identified by the function_call_id.\n\nExample:\n```python\ntool = LongRunningFunctionTool(a_long_running_function)\n```\n\nAttributes:\n  is_long_running: Whether the tool is a long running operation."
            }
          }
        },
        "mcp_tool": {
          "conversion_utils": {
            "__members__": {
              "adk_to_mcp_tool_type": {
                "type": "function",
                "signature": "(tool: 'BaseTool') -> 'mcp_types.Tool'",
                "doc": "Convert a Tool in ADK into MCP tool type.\n\nThis function transforms an ADK tool definition into its equivalent\nrepresentation in the MCP (Model Context Protocol) system.\n\nArgs:\n    tool: The ADK tool to convert. It should be an instance of a class derived\n      from `BaseTool`.\n\nReturns:\n    An object of MCP Tool type, representing the converted tool.\n\nExamples:\n    # Assuming 'my_tool' is an instance of a BaseTool derived class\n    mcp_tool = adk_to_mcp_tool_type(my_tool)\n    print(mcp_tool)"
              },
              "gemini_to_json_schema": {
                "type": "function",
                "signature": "(gemini_schema: 'Schema') -> 'Dict[str, Any]'",
                "doc": "Converts a Gemini Schema object into a JSON Schema dictionary.\n\nArgs:\n    gemini_schema: An instance of the Gemini Schema class.\n\nReturns:\n    A dictionary representing the equivalent JSON Schema.\n\nRaises:\n    TypeError: If the input is not an instance of the expected Schema class.\n    ValueError: If an invalid Gemini Type enum value is encountered."
              }
            }
          },
          "mcp_session_manager": {
            "__members__": {
              "MCPSessionManager": {
                "type": "class",
                "signature": "(connection_params: 'Union[StdioServerParameters, StdioConnectionParams, SseConnectionParams, StreamableHTTPConnectionParams]', errlog: 'TextIO' = <_io.TextIOWrapper name='<stderr>' mode='w' encoding='utf-8'>)",
                "doc": "Manages MCP client sessions.\n\nThis class provides methods for creating and initializing MCP client sessions,\nhandling different connection parameters (Stdio and SSE) and supporting\nsession pooling based on authentication headers."
              },
              "SseConnectionParams": {
                "type": "class",
                "signature": "(*, url: str, headers: dict[str, typing.Any] | None = None, timeout: float = 5.0, sse_read_timeout: float = 300.0) -> None",
                "doc": "Parameters for the MCP SSE connection.\n\nSee MCP SSE Client documentation for more details.\nhttps://github.com/modelcontextprotocol/python-sdk/blob/main/src/mcp/client/sse.py\n\nAttributes:\n    url: URL for the MCP SSE server.\n    headers: Headers for the MCP SSE connection.\n    timeout: Timeout in seconds for establishing the connection to the MCP SSE\n      server.\n    sse_read_timeout: Timeout in seconds for reading data from the MCP SSE\n      server."
              },
              "SseServerParams": {
                "type": "class",
                "signature": "(*, url: str, headers: dict[str, typing.Any] | None = None, timeout: float = 5.0, sse_read_timeout: float = 300.0) -> None",
                "doc": "Parameters for the MCP SSE connection.\n\nSee MCP SSE Client documentation for more details.\nhttps://github.com/modelcontextprotocol/python-sdk/blob/main/src/mcp/client/sse.py\n\nAttributes:\n    url: URL for the MCP SSE server.\n    headers: Headers for the MCP SSE connection.\n    timeout: Timeout in seconds for establishing the connection to the MCP SSE\n      server.\n    sse_read_timeout: Timeout in seconds for reading data from the MCP SSE\n      server."
              },
              "StdioConnectionParams": {
                "type": "class",
                "signature": "(*, server_params: mcp.client.stdio.StdioServerParameters, timeout: float = 5.0) -> None",
                "doc": "Parameters for the MCP Stdio connection.\n\nAttributes:\n    server_params: Parameters for the MCP Stdio server.\n    timeout: Timeout in seconds for establishing the connection to the MCP\n      stdio server."
              },
              "StreamableHTTPConnectionParams": {
                "type": "class",
                "signature": "(*, url: str, headers: dict[str, typing.Any] | None = None, timeout: float = 5.0, sse_read_timeout: float = 300.0, terminate_on_close: bool = True) -> None",
                "doc": "Parameters for the MCP SSE connection.\n\nSee MCP SSE Client documentation for more details.\nhttps://github.com/modelcontextprotocol/python-sdk/blob/main/src/mcp/client/streamable_http.py\n\nAttributes:\n    url: URL for the MCP Streamable HTTP server.\n    headers: Headers for the MCP Streamable HTTP connection.\n    timeout: Timeout in seconds for establishing the connection to the MCP\n      Streamable HTTP server.\n    sse_read_timeout: Timeout in seconds for reading data from the MCP\n      Streamable HTTP server.\n    terminate_on_close: Whether to terminate the MCP Streamable HTTP server\n      when the connection is closed."
              },
              "StreamableHTTPServerParams": {
                "type": "class",
                "signature": "(*, url: str, headers: dict[str, typing.Any] | None = None, timeout: float = 5.0, sse_read_timeout: float = 300.0, terminate_on_close: bool = True) -> None",
                "doc": "Parameters for the MCP SSE connection.\n\nSee MCP SSE Client documentation for more details.\nhttps://github.com/modelcontextprotocol/python-sdk/blob/main/src/mcp/client/streamable_http.py\n\nAttributes:\n    url: URL for the MCP Streamable HTTP server.\n    headers: Headers for the MCP Streamable HTTP connection.\n    timeout: Timeout in seconds for establishing the connection to the MCP\n      Streamable HTTP server.\n    sse_read_timeout: Timeout in seconds for reading data from the MCP\n      Streamable HTTP server.\n    terminate_on_close: Whether to terminate the MCP Streamable HTTP server\n      when the connection is closed."
              },
              "retry_on_closed_resource": {
                "type": "function",
                "signature": "(func)",
                "doc": "Decorator to automatically retry action when MCP session is closed.\n\nWhen MCP session was closed, the decorator will automatically retry the\naction once. The create_session method will handle creating a new session\nif the old one was disconnected.\n\nArgs:\n    func: The function to decorate.\n\nReturns:\n    The decorated function."
              }
            }
          },
          "mcp_tool": {
            "__members__": {
              "MCPTool": {
                "type": "class",
                "signature": "(*, mcp_tool: 'McpBaseTool', mcp_session_manager: 'MCPSessionManager', auth_scheme: 'Optional[AuthScheme]' = None, auth_credential: 'Optional[AuthCredential]' = None)",
                "doc": "Turns an MCP Tool into an ADK Tool.\n\nInternally, the tool initializes from a MCP Tool, and uses the MCP Session to\ncall the tool.\n\nNote: For API key authentication, only header-based API keys are supported.\nQuery and cookie-based API keys will result in authentication errors."
              }
            }
          },
          "mcp_toolset": {
            "__members__": {
              "MCPToolset": {
                "type": "class",
                "signature": "(*, connection_params: 'Union[StdioServerParameters, StdioConnectionParams, SseConnectionParams, StreamableHTTPConnectionParams]', tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None, errlog: 'TextIO' = <_io.TextIOWrapper name='<stderr>' mode='w' encoding='utf-8'>, auth_scheme: 'Optional[AuthScheme]' = None, auth_credential: 'Optional[AuthCredential]' = None)",
                "doc": "Connects to a MCP Server, and retrieves MCP Tools into ADK Tools.\n\nThis toolset manages the connection to an MCP server and provides tools\nthat can be used by an agent. It properly implements the BaseToolset\ninterface for easy integration with the agent framework.\n\nUsage::\n\n  toolset = MCPToolset(\n      connection_params=StdioServerParameters(\n          command='npx',\n          args=[\"-y\", \"@modelcontextprotocol/server-filesystem\"],\n      ),\n      tool_filter=['read_file', 'list_directory']  # Optional: filter specific tools\n  )\n\n  # Use in an agent\n  agent = LlmAgent(\n      model='gemini-2.0-flash',\n      name='enterprise_assistant',\n      instruction='Help user accessing their file systems',\n      tools=[toolset],\n  )\n\n  # Cleanup is handled automatically by the agent framework\n  # But you can also manually close if needed:\n  # await toolset.close()"
              }
            }
          }
        },
        "openapi_tool": {
          "auth": {
            "auth_helpers": {
              "__members__": {
                "OpenIdConfig": {
                  "type": "class",
                  "signature": "(*, client_id: str, auth_uri: str, token_uri: str, client_secret: str, redirect_uri: Optional[str]) -> None",
                  "doc": "Represents OpenID Connect configuration.\n\nAttributes:\n    client_id: The client ID.\n    auth_uri: The authorization URI.\n    token_uri: The token URI.\n    client_secret: The client secret.\n\nExample:\n    config = OpenIdConfig(\n        client_id=\"your_client_id\",\n        auth_uri=\"https://accounts.google.com/o/oauth2/auth\",\n        token_uri=\"https://oauth2.googleapis.com/token\",\n        client_secret=\"your_client_secret\",\n        redirect\n    )"
                },
                "credential_to_param": {
                  "type": "function",
                  "signature": "(auth_scheme: Union[fastapi.openapi.models.APIKey, fastapi.openapi.models.HTTPBase, fastapi.openapi.models.OAuth2, fastapi.openapi.models.OpenIdConnect, fastapi.openapi.models.HTTPBearer, google.adk.auth.auth_schemes.OpenIdConnectWithConfig], auth_credential: google.adk.auth.auth_credential.AuthCredential) -> Tuple[Optional[google.adk.tools.openapi_tool.common.common.ApiParameter], Optional[Dict[str, Any]]]",
                  "doc": "Converts AuthCredential and AuthScheme to a Parameter and a dictionary for additional kwargs.\n\nThis function now supports all credential types returned by the exchangers:\n- API Key\n- HTTP Bearer (for Bearer tokens, OAuth2, Service Account, OpenID Connect)\n- OAuth2 and OpenID Connect (returns None, None, as the token is now a Bearer\ntoken)\n- Service Account (returns None, None, as the token is now a Bearer token)\n\nArgs:\n    auth_scheme: The AuthScheme object.\n    auth_credential: The AuthCredential object.\n\nReturns:\n    Tuple: (ApiParameter, Dict[str, Any])"
                },
                "dict_to_auth_scheme": {
                  "type": "function",
                  "signature": "(data: Dict[str, Any]) -> Union[fastapi.openapi.models.APIKey, fastapi.openapi.models.HTTPBase, fastapi.openapi.models.OAuth2, fastapi.openapi.models.OpenIdConnect, fastapi.openapi.models.HTTPBearer, google.adk.auth.auth_schemes.OpenIdConnectWithConfig]",
                  "doc": "Converts a dictionary to a FastAPI AuthScheme object.\n\nArgs:\n    data: The dictionary representing the security scheme.\n\nReturns:\n    A AuthScheme object (APIKey, HTTPBase, OAuth2, OpenIdConnect, or\n    HTTPBearer).\n\nRaises:\n    ValueError: If the 'type' field is missing or invalid, or if the\n        dictionary cannot be converted to the corresponding Pydantic model.\n\nExample:\n```python\napi_key_data = {\n    \"type\": \"apiKey\",\n    \"in\": \"header\",\n    \"name\": \"X-API-Key\",\n}\napi_key_scheme = dict_to_auth_scheme(api_key_data)\n\nbearer_data = {\n    \"type\": \"http\",\n    \"scheme\": \"bearer\",\n    \"bearerFormat\": \"JWT\",\n}\nbearer_scheme = dict_to_auth_scheme(bearer_data)\n\n\noauth2_data = {\n    \"type\": \"oauth2\",\n    \"flows\": {\n        \"authorizationCode\": {\n            \"authorizationUrl\": \"https://example.com/auth\",\n            \"tokenUrl\": \"https://example.com/token\",\n        }\n    }\n}\noauth2_scheme = dict_to_auth_scheme(oauth2_data)\n\nopenid_data = {\n    \"type\": \"openIdConnect\",\n    \"openIdConnectUrl\": \"https://example.com/.well-known/openid-configuration\"\n}\nopenid_scheme = dict_to_auth_scheme(openid_data)\n\n\n```"
                },
                "openid_dict_to_scheme_credential": {
                  "type": "function",
                  "signature": "(config_dict: Dict[str, Any], scopes: List[str], credential_dict: Dict[str, Any]) -> Tuple[google.adk.auth.auth_schemes.OpenIdConnectWithConfig, google.adk.auth.auth_credential.AuthCredential]",
                  "doc": "Constructs OpenID scheme and credential from configuration and credential dictionaries.\n\nArgs:\n    config_dict: Dictionary containing OpenID Connect configuration,  must\n      include at least 'authorization_endpoint' and 'token_endpoint'.\n    scopes: List of scopes to be used.\n    credential_dict: Dictionary containing credential information, must\n      include 'client_id', 'client_secret', and 'scopes'.  May optionally\n      include 'redirect_uri'.\n\nReturns:\n    Tuple: (OpenIdConnectWithConfig, AuthCredential)\n\nRaises:\n    ValueError: If required fields are missing in the input dictionaries."
                },
                "openid_url_to_scheme_credential": {
                  "type": "function",
                  "signature": "(openid_url: str, scopes: List[str], credential_dict: Dict[str, Any]) -> Tuple[google.adk.auth.auth_schemes.OpenIdConnectWithConfig, google.adk.auth.auth_credential.AuthCredential]",
                  "doc": "Constructs OpenID scheme and credential from OpenID URL, scopes, and credential dictionary.\n\nFetches OpenID configuration from the provided URL.\n\nArgs:\n    openid_url: The OpenID Connect discovery URL.\n    scopes: List of scopes to be used.\n    credential_dict: Dictionary containing credential information, must\n      include at least \"client_id\" and \"client_secret\", may optionally include\n      \"redirect_uri\" and \"scope\"\n\nReturns:\n    Tuple: (AuthScheme, AuthCredential)\n\nRaises:\n    ValueError: If the OpenID URL is invalid, fetching fails, or required\n      fields are missing.\n    requests.exceptions.RequestException:  If there's an error during the\n        HTTP request."
                },
                "service_account_dict_to_scheme_credential": {
                  "type": "function",
                  "signature": "(config: Dict[str, Any], scopes: List[str]) -> Tuple[Union[fastapi.openapi.models.APIKey, fastapi.openapi.models.HTTPBase, fastapi.openapi.models.OAuth2, fastapi.openapi.models.OpenIdConnect, fastapi.openapi.models.HTTPBearer, google.adk.auth.auth_schemes.OpenIdConnectWithConfig], google.adk.auth.auth_credential.AuthCredential]",
                  "doc": "Creates AuthScheme and AuthCredential for Google Service Account.\n\nReturns a bearer token scheme, and a service account credential.\n\nArgs:\n    config: A ServiceAccount object containing the Google Service Account\n      configuration.\n    scopes: A list of scopes to be used.\n\nReturns:\n    Tuple: (AuthScheme, AuthCredential)"
                },
                "service_account_scheme_credential": {
                  "type": "function",
                  "signature": "(config: google.adk.auth.auth_credential.ServiceAccount) -> Tuple[Union[fastapi.openapi.models.APIKey, fastapi.openapi.models.HTTPBase, fastapi.openapi.models.OAuth2, fastapi.openapi.models.OpenIdConnect, fastapi.openapi.models.HTTPBearer, google.adk.auth.auth_schemes.OpenIdConnectWithConfig], google.adk.auth.auth_credential.AuthCredential]",
                  "doc": "Creates AuthScheme and AuthCredential for Google Service Account.\n\nReturns a bearer token scheme, and a service account credential.\n\nArgs:\n    config: A ServiceAccount object containing the Google Service Account\n      configuration.\n\nReturns:\n    Tuple: (AuthScheme, AuthCredential)"
                },
                "token_to_scheme_credential": {
                  "type": "function",
                  "signature": "(token_type: Literal['apikey', 'oauth2Token'], location: Optional[Literal['header', 'query', 'cookie']] = None, name: Optional[str] = None, credential_value: Optional[str] = None) -> Tuple[Union[fastapi.openapi.models.APIKey, fastapi.openapi.models.HTTPBase, fastapi.openapi.models.OAuth2, fastapi.openapi.models.OpenIdConnect, fastapi.openapi.models.HTTPBearer, google.adk.auth.auth_schemes.OpenIdConnectWithConfig], google.adk.auth.auth_credential.AuthCredential]",
                  "doc": "Creates a AuthScheme and AuthCredential for API key or bearer token.\n\nExamples:\n```\n# API Key in header\nauth_scheme, auth_credential = token_to_scheme_credential(\"apikey\", \"header\",\n\"X-API-Key\", \"your_api_key_value\")\n\n# API Key in query parameter\nauth_scheme, auth_credential = token_to_scheme_credential(\"apikey\", \"query\",\n\"api_key\", \"your_api_key_value\")\n\n# OAuth2 Bearer Token in Authorization header\nauth_scheme, auth_credential = token_to_scheme_credential(\"oauth2Token\",\n\"header\", \"Authorization\", \"your_bearer_token_value\")\n```\n\nArgs:\n    type: 'apikey' or 'oauth2Token'.\n    location: 'header', 'query', or 'cookie' (only 'header' for oauth2Token).\n    name: The name of the header, query parameter, or cookie.\n    credential_value:  The value of the API Key/ Token.\n\nReturns:\n    Tuple: (AuthScheme, AuthCredential)\n\nRaises:\n    ValueError: For invalid type or location."
                }
              }
            },
            "credential_exchangers": {
              "auto_auth_credential_exchanger": {
                "__members__": {
                  "AutoAuthCredentialExchanger": {
                    "type": "class",
                    "signature": "(custom_exchangers: Optional[Dict[str, Type[google.adk.tools.openapi_tool.auth.credential_exchangers.base_credential_exchanger.BaseAuthCredentialExchanger]]] = None)",
                    "doc": "Automatically selects the appropriate credential exchanger based on the auth scheme.\n\nOptionally, an override can be provided to use a specific exchanger for a\ngiven auth scheme.\n\nExample (common case):\n```\nexchanger = AutoAuthCredentialExchanger()\nauth_credential = exchanger.exchange_credential(\n    auth_scheme=service_account_scheme,\n    auth_credential=service_account_credential,\n)\n# Returns an oauth token in the form of a bearer token.\n```\n\nExample (use CustomAuthExchanger for OAuth2):\n```\nexchanger = AutoAuthCredentialExchanger(\n    custom_exchangers={\n        AuthScheme.OAUTH2: CustomAuthExchanger,\n    }\n)\n```\n\nAttributes:\n  exchangers: A dictionary mapping auth scheme to credential exchanger class."
                  }
                }
              },
              "base_credential_exchanger": {
                "__members__": {
                  "AuthCredentialMissingError": {
                    "type": "class",
                    "signature": "(message: str)",
                    "doc": "Exception raised when required authentication credentials are missing."
                  },
                  "BaseAuthCredentialExchanger": {
                    "type": "class",
                    "signature": "()",
                    "doc": "Base class for authentication credential exchangers."
                  }
                }
              },
              "oauth2_exchanger": {
                "__members__": {
                  "OAuth2CredentialExchanger": {
                    "type": "class",
                    "signature": "()",
                    "doc": "Fetches credentials for OAuth2 and OpenID Connect."
                  }
                }
              },
              "service_account_exchanger": {
                "__members__": {
                  "ServiceAccountCredentialExchanger": {
                    "type": "class",
                    "signature": "()",
                    "doc": "Fetches credentials for Google Service Account.\n\nUses the default service credential if `use_default_credential = True`.\nOtherwise, uses the service account credential provided in the auth\ncredential."
                  }
                }
              }
            }
          },
          "common": {
            "common": {
              "__members__": {
                "ApiParameter": {
                  "type": "class",
                  "signature": "(*, original_name: str, param_location: str, param_schema: Union[str, fastapi.openapi.models.Schema], description: Optional[str] = '', py_name: Optional[str] = '', type_value: type[typing.Any] = None, type_hint: str = None, required: bool = False) -> None",
                  "doc": "Data class representing a function parameter."
                },
                "PydocHelper": {
                  "type": "class",
                  "signature": "()",
                  "doc": "Helper class for generating PyDoc strings."
                },
                "TypeHintHelper": {
                  "type": "class",
                  "signature": "()",
                  "doc": "Helper class for generating type hints."
                },
                "rename_python_keywords": {
                  "type": "function",
                  "signature": "(s: 'str', prefix: 'str' = 'param_') -> 'str'",
                  "doc": "Renames Python keywords by adding a prefix.\n\nExample:\n```\nrename_python_keywords('if') -> 'param_if'\nrename_python_keywords('for') -> 'param_for'\n```\n\nArgs:\n    s: The input string.\n    prefix: The prefix to add to the keyword.\n\nReturns:\n    The renamed string."
                }
              }
            }
          },
          "openapi_spec_parser": {
            "openapi_spec_parser": {
              "__members__": {
                "OpenApiSpecParser": {
                  "type": "class",
                  "signature": "()",
                  "doc": "Generates Python code, JSON schema, and callables for an OpenAPI operation.\n\nThis class takes an OpenApiOperation object and provides methods to generate:\n1. A string representation of a Python function that handles the operation.\n2. A JSON schema representing the input parameters of the operation.\n3. A callable Python object (a function) that can execute the operation."
                },
                "OperationEndpoint": {
                  "type": "class",
                  "signature": "(*, base_url: str, path: str, method: str) -> None",
                  "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
                },
                "ParsedOperation": {
                  "type": "class",
                  "signature": "(*, name: str, description: str, endpoint: google.adk.tools.openapi_tool.openapi_spec_parser.openapi_spec_parser.OperationEndpoint, operation: fastapi.openapi.models.Operation, parameters: List[google.adk.tools.openapi_tool.common.common.ApiParameter], return_value: google.adk.tools.openapi_tool.common.common.ApiParameter, auth_scheme: Union[fastapi.openapi.models.APIKey, fastapi.openapi.models.HTTPBase, fastapi.openapi.models.OAuth2, fastapi.openapi.models.OpenIdConnect, fastapi.openapi.models.HTTPBearer, google.adk.auth.auth_schemes.OpenIdConnectWithConfig, NoneType] = None, auth_credential: Optional[google.adk.auth.auth_credential.AuthCredential] = None, additional_context: Optional[Any] = None) -> None",
                  "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
                }
              }
            },
            "openapi_toolset": {
              "__members__": {
                "OpenAPIToolset": {
                  "type": "class",
                  "signature": "(*, spec_dict: 'Optional[Dict[str, Any]]' = None, spec_str: 'Optional[str]' = None, spec_str_type: \"Literal['json', 'yaml']\" = 'json', auth_scheme: 'Optional[AuthScheme]' = None, auth_credential: 'Optional[AuthCredential]' = None, tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None)",
                  "doc": "Class for parsing OpenAPI spec into a list of RestApiTool.\n\nUsage::\n\n  # Initialize OpenAPI toolset from a spec string.\n  openapi_toolset = OpenAPIToolset(spec_str=openapi_spec_str,\n    spec_str_type=\"json\")\n  # Or, initialize OpenAPI toolset from a spec dictionary.\n  openapi_toolset = OpenAPIToolset(spec_dict=openapi_spec_dict)\n\n  # Add all tools to an agent.\n  agent = Agent(\n    tools=[*openapi_toolset.get_tools()]\n  )\n  # Or, add a single tool to an agent.\n  agent = Agent(\n    tools=[openapi_toolset.get_tool('tool_name')]\n  )"
                }
              }
            },
            "operation_parser": {
              "__members__": {
                "OperationParser": {
                  "type": "class",
                  "signature": "(operation: 'Union[Operation, Dict[str, Any], str]', should_parse=True)",
                  "doc": "Generates parameters for Python functions from an OpenAPI operation.\n\nThis class processes an OpenApiOperation object and provides helper methods\nto extract information needed to generate Python function declarations,\ndocstrings, signatures, and JSON schemas.  It handles parameter processing,\nname deduplication, and type hint generation."
                }
              }
            },
            "rest_api_tool": {
              "__members__": {
                "RestApiTool": {
                  "type": "class",
                  "signature": "(name: 'str', description: 'str', endpoint: 'Union[OperationEndpoint, str]', operation: 'Union[Operation, str]', auth_scheme: 'Optional[Union[AuthScheme, str]]' = None, auth_credential: 'Optional[Union[AuthCredential, str]]' = None, should_parse_operation=True)",
                  "doc": "A generic tool that interacts with a REST API.\n\n* Generates request params and body\n* Attaches auth credentials to API call.\n\nExample::\n\n  # Each API operation in the spec will be turned into its own tool\n  # Name of the tool is the operationId of that operation, in snake case\n  operations = OperationGenerator().parse(openapi_spec_dict)\n  tool = [RestApiTool.from_parsed_operation(o) for o in operations]"
                },
                "snake_to_lower_camel": {
                  "type": "function",
                  "signature": "(snake_case_string: 'str')",
                  "doc": "Converts a snake_case string to a lower_camel_case string.\n\nArgs:\n    snake_case_string: The input snake_case string.\n\nReturns:\n    The lower_camel_case string."
                }
              }
            },
            "tool_auth_handler": {
              "__members__": {
                "AuthPreparationResult": {
                  "type": "class",
                  "signature": "(*, state: Literal['pending', 'done'], auth_scheme: Union[fastapi.openapi.models.APIKey, fastapi.openapi.models.HTTPBase, fastapi.openapi.models.OAuth2, fastapi.openapi.models.OpenIdConnect, fastapi.openapi.models.HTTPBearer, google.adk.auth.auth_schemes.OpenIdConnectWithConfig, NoneType] = None, auth_credential: Optional[google.adk.auth.auth_credential.AuthCredential] = None) -> None",
                  "doc": "Result of the credential preparation process."
                },
                "ToolAuthHandler": {
                  "type": "class",
                  "signature": "(tool_context: 'ToolContext', auth_scheme: 'Optional[AuthScheme]', auth_credential: 'Optional[AuthCredential]', credential_exchanger: 'Optional[BaseAuthCredentialExchanger]' = None, credential_store: \"Optional['ToolContextCredentialStore']\" = None)",
                  "doc": "Handles the preparation and exchange of authentication credentials for tools."
                },
                "ToolContextCredentialStore": {
                  "type": "class",
                  "signature": "(tool_context: 'ToolContext')",
                  "doc": "Handles storage and retrieval of credentials within a ToolContext."
                }
              }
            }
          }
        },
        "preload_memory_tool": {
          "__members__": {
            "PreloadMemoryTool": {
              "type": "class",
              "signature": "()",
              "doc": "A tool that preloads the memory for the current user.\n\nNOTE: Currently this tool only uses text part from the memory."
            }
          }
        },
        "tool_context": {
          "__members__": {
            "ToolContext": {
              "type": "class",
              "signature": "(invocation_context: 'InvocationContext', *, function_call_id: 'Optional[str]' = None, event_actions: 'Optional[EventActions]' = None)",
              "doc": "The context of the tool.\n\nThis class provides the context for a tool invocation, including access to\nthe invocation context, function call ID, event actions, and authentication\nresponse. It also provides methods for requesting credentials, retrieving\nauthentication responses, listing artifacts, and searching memory.\n\nAttributes:\n  invocation_context: The invocation context of the tool.\n  function_call_id: The function call id of the current tool call. This id was\n    returned in the function call event from LLM to identify a function call.\n    If LLM didn't return this id, ADK will assign one to it. This id is used\n    to map function call response to the original function call.\n  event_actions: The event actions of the current tool call."
            }
          }
        },
        "transfer_to_agent_tool": {
          "__members__": {
            "transfer_to_agent": {
              "type": "function",
              "signature": "(agent_name: 'str', tool_context: 'ToolContext') -> 'None'",
              "doc": "Transfer the question to another agent.\n\nThis tool hands off control to another agent when it's more suitable to\nanswer the user's question according to the agent's description.\n\nArgs:\n  agent_name: the agent name to transfer to."
            }
          }
        },
        "url_context_tool": {
          "__members__": {
            "UrlContextTool": {
              "type": "class",
              "signature": "()",
              "doc": "A built-in tool that is automatically invoked by Gemini 2 models to retrieve content from the URLs and use that content to inform and shape its response.\n\nThis tool operates internally within the model and does not require or perform\nlocal code execution."
            }
          }
        },
        "vertex_ai_search_tool": {
          "__members__": {
            "VertexAiSearchTool": {
              "type": "class",
              "signature": "(*, data_store_id: 'Optional[str]' = None, data_store_specs: 'Optional[list[types.VertexAISearchDataStoreSpec]]' = None, search_engine_id: 'Optional[str]' = None, filter: 'Optional[str]' = None, max_results: 'Optional[int]' = None)",
              "doc": "A built-in tool using Vertex AI Search.\n\nAttributes:\n  data_store_id: The Vertex AI search data store resource ID.\n  search_engine_id: The Vertex AI search engine resource ID."
            }
          }
        }
      },
      "utils": {
        "feature_decorator": {
          "__members__": {
            "_create_decorator": {
              "type": "function",
              "signature": "(message: 'str', label: 'str', block_usage: 'bool', bypass_env_var: 'Optional[str]') -> 'Callable[[T], T]'",
              "doc": ""
            },
            "_make_feature_decorator": {
              "type": "function",
              "signature": "(*, label: 'str', default_message: 'str', block_usage: 'bool' = False, bypass_env_var: 'Optional[str]' = None) -> 'Callable'",
              "doc": ""
            },
            "experimental": {
              "type": "function",
              "signature": "(message_or_obj=None)",
              "doc": ""
            },
            "working_in_progress": {
              "type": "function",
              "signature": "(message_or_obj=None)",
              "doc": ""
            }
          }
        },
        "instructions_utils": {
          "__members__": {
            "_is_valid_state_name": {
              "type": "function",
              "signature": "(var_name)",
              "doc": "Checks if the variable name is a valid state name.\n\nValid state is either:\n  - Valid identifier\n  - <Valid prefix>:<Valid identifier>\nAll the others will just return as it is.\n\nArgs:\n  var_name: The variable name to check.\n\nReturns:\n  True if the variable name is a valid state name, False otherwise."
            },
            "inject_session_state": {
              "type": "function",
              "signature": "(template: 'str', readonly_context: 'ReadonlyContext') -> 'str'",
              "doc": "Populates values in the instruction template, e.g. state, artifact, etc.\n\nThis method is intended to be used in InstructionProvider based instruction\nand global_instruction which are called with readonly_context.\n\ne.g.\n```\n...\nfrom google.adk.utils.instructions_utils import inject_session_state\n\nasync def build_instruction(\n    readonly_context: ReadonlyContext,\n) -> str:\n  return await inject_session_state(\n      'You can inject a state variable like {var_name} or an artifact '\n      '{artifact.file_name} into the instruction template.',\n      readonly_context,\n  )\n\nagent = Agent(\n    model=\"gemini-2.0-flash\",\n    name=\"agent\",\n    instruction=build_instruction,\n)\n```\n\nArgs:\n  template: The instruction template.\n  readonly_context: The read-only context\n\nReturns:\n  The instruction template with values populated."
            }
          }
        },
        "model_name_utils": {
          "__members__": {
            "extract_model_name": {
              "type": "function",
              "signature": "(model_string: 'str') -> 'str'",
              "doc": "Extract the actual model name from either simple or path-based format.\n\nArgs:\n  model_string: Either a simple model name like \"gemini-2.5-pro\" or\n                a path-based model name like \"projects/.../models/gemini-2.0-flash-001\"\n\nReturns:\n  The extracted model name (e.g., \"gemini-2.5-pro\")"
            },
            "is_gemini_1_model": {
              "type": "function",
              "signature": "(model_string: 'Optional[str]') -> 'bool'",
              "doc": "Check if the model is a Gemini 1.x model using regex patterns.\n\nArgs:\n  model_string: Either a simple model name or path-based model name\n\nReturns:\n  True if it's a Gemini 1.x model, False otherwise"
            },
            "is_gemini_2_model": {
              "type": "function",
              "signature": "(model_string: 'Optional[str]') -> 'bool'",
              "doc": "Check if the model is a Gemini 2.x model using regex patterns.\n\nArgs:\n  model_string: Either a simple model name or path-based model name\n\nReturns:\n  True if it's a Gemini 2.x model, False otherwise"
            },
            "is_gemini_model": {
              "type": "function",
              "signature": "(model_string: 'Optional[str]') -> 'bool'",
              "doc": "Check if the model is a Gemini model using regex patterns.\n\nArgs:\n  model_string: Either a simple model name or path-based model name\n\nReturns:\n  True if it's a Gemini model, False otherwise"
            }
          }
        },
        "variant_utils": {
          "__members__": {
            "GoogleLLMVariant": {
              "type": "class",
              "signature": "(*values)",
              "doc": "The Google LLM variant to use.\nsee https://google.github.io/adk-docs/get-started/quickstart/#set-up-the-model"
            },
            "get_google_llm_variant": {
              "type": "function",
              "signature": "() -> 'str'",
              "doc": ""
            }
          }
        }
      }
    }
  }
}