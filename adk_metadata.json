{
  "google": {
    "adk": {
      "a2a": {
        "converters": {
          "utils": {
            "__members__": {
              "_from_a2a_context_id": {
                "type": "function",
                "signature": "(context_id: 'str') -> 'tuple[str, str, str]'",
                "doc": "Converts an A2A context id to app name, user id and session id.\nif context_id is None, return None, None, None\nif context_id is not None, but not in the format of\nADK$app_name$user_id$session_id, return None, None, None\n\nArgs:\n  context_id: The A2A context id.\n\nReturns:\n  The app name, user id and session id."
              },
              "_get_adk_metadata_key": {
                "type": "function",
                "signature": "(key: 'str') -> 'str'",
                "doc": "Gets the A2A event metadata key for the given key.\n\nArgs:\n  key: The metadata key to prefix.\n\nReturns:\n  The prefixed metadata key.\n\nRaises:\n  ValueError: If key is empty or None."
              },
              "_to_a2a_context_id": {
                "type": "function",
                "signature": "(app_name: 'str', user_id: 'str', session_id: 'str') -> 'str'",
                "doc": "Converts app name, user id and session id to an A2A context id.\n\nArgs:\n  app_name: The app name.\n  user_id: The user id.\n  session_id: The session id.\n\nReturns:\n  The A2A context id.\n\nRaises:\n  ValueError: If any of the input parameters are empty or None."
              }
            }
          }
        }
      },
      "agents": {
        "active_streaming_tool": {
          "__members__": {
            "ActiveStreamingTool": {
              "type": "class",
              "signature": "(*, task: Optional[_asyncio.Task] = None, stream: Optional[google.adk.agents.live_request_queue.LiveRequestQueue] = None) -> None",
              "doc": "Manages streaming tool related resources during invocation."
            }
          }
        },
        "agent_config": {
          "__members__": {
            "AgentConfig": {
              "type": "class",
              "signature": "(root: 'RootModelRootType' = PydanticUndefined) -> None",
              "doc": "The config for the YAML schema to create an agent."
            },
            "agent_config_discriminator": {
              "type": "function",
              "signature": "(v: 'Any')",
              "doc": ""
            }
          }
        },
        "base_agent": {
          "__members__": {
            "BaseAgent": {
              "type": "class",
              "signature": "(*, name: str, description: str = '', parent_agent: Optional[google.adk.agents.base_agent.BaseAgent] = None, sub_agents: list[google.adk.agents.base_agent.BaseAgent] = <factory>, before_agent_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]]], NoneType] = None, after_agent_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]]], NoneType] = None) -> None",
              "doc": "Base class for all agents in Agent Development Kit."
            }
          }
        },
        "base_agent_config": {
          "__members__": {
            "BaseAgentConfig": {
              "type": "class",
              "signature": "(*, agent_class: Union[Literal['BaseAgent'], str] = 'BaseAgent', name: str, description: str = '', sub_agents: Optional[List[google.adk.agents.common_configs.AgentRefConfig]] = None, before_agent_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None, after_agent_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None, **extra_data: Any) -> None",
              "doc": "The config for the YAML schema of a BaseAgent.\n\nDo not use this class directly. It's the base class for all agent configs."
            }
          }
        },
        "callback_context": {
          "__members__": {
            "CallbackContext": {
              "type": "class",
              "signature": "(invocation_context: 'InvocationContext', *, event_actions: 'Optional[EventActions]' = None) -> 'None'",
              "doc": "The context of various callbacks within an agent run."
            }
          }
        },
        "common_configs": {
          "__members__": {
            "AgentRefConfig": {
              "type": "class",
              "signature": "(*, config_path: Optional[str] = None, code: Optional[str] = None) -> None",
              "doc": "The config for the reference to another agent."
            },
            "ArgumentConfig": {
              "type": "class",
              "signature": "(*, name: Optional[str] = None, value: Any) -> None",
              "doc": "An argument passed to a function or a class's constructor."
            },
            "CodeConfig": {
              "type": "class",
              "signature": "(*, name: str, args: Optional[List[google.adk.agents.common_configs.ArgumentConfig]] = None) -> None",
              "doc": "Code reference config for a variable, a function, or a class.\n\nThis config is used for configuring callbacks and tools."
            }
          }
        },
        "config_agent_utils": {
          "__members__": {
            "_load_config_from_path": {
              "type": "function",
              "signature": "(config_path: 'str') -> 'AgentConfig'",
              "doc": "Load an agent's configuration from a YAML file.\n\nArgs:\n  config_path: Path to the YAML config file. Both relative and absolute\n    paths are accepted.\n\nReturns:\n  The loaded and validated AgentConfig object.\n\nRaises:\n  FileNotFoundError: If config file doesn't exist.\n  ValidationError: If config file's content is invalid YAML."
            },
            "_resolve_agent_class": {
              "type": "function",
              "signature": "(agent_class: 'str') -> 'type[BaseAgent]'",
              "doc": "Resolve the agent class from its fully qualified name."
            },
            "_resolve_agent_code_reference": {
              "type": "function",
              "signature": "(code: 'str') -> 'Any'",
              "doc": "Resolve a code reference to an actual agent instance.\n\nArgs:\n  code: The fully-qualified path to an agent instance.\n\nReturns:\n  The resolved agent instance.\n\nRaises:\n  ValueError: If the agent reference cannot be resolved."
            },
            "_resolve_fully_qualified_name": {
              "type": "function",
              "signature": "(name: 'str') -> 'Any'",
              "doc": ""
            },
            "from_config": {
              "type": "function",
              "signature": "(config_path: 'str') -> 'BaseAgent'",
              "doc": "Build agent from a configfile path.\n\nArgs:\n  config: the path to a YAML config file.\n\nReturns:\n  The created agent instance.\n\nRaises:\n  FileNotFoundError: If config file doesn't exist.\n  ValidationError: If config file's content is invalid YAML.\n  ValueError: If agent type is unsupported."
            },
            "resolve_agent_reference": {
              "type": "function",
              "signature": "(ref_config: 'AgentRefConfig', referencing_agent_config_abs_path: 'str') -> 'BaseAgent'",
              "doc": "Build an agent from a reference.\n\nArgs:\n  ref_config: The agent reference configuration (AgentRefConfig).\n  referencing_agent_config_abs_path: The absolute path to the agent config\n  that contains the reference.\n\nReturns:\n  The created agent instance."
            },
            "resolve_callbacks": {
              "type": "function",
              "signature": "(callbacks_config: 'List[CodeConfig]') -> 'Any'",
              "doc": "Resolve callbacks from configuration.\n\nArgs:\n  callbacks_config: List of callback configurations (CodeConfig objects).\n\nReturns:\n  List of resolved callback objects."
            },
            "resolve_code_reference": {
              "type": "function",
              "signature": "(code_config: 'CodeConfig') -> 'Any'",
              "doc": "Resolve a code reference to actual Python object.\n\nArgs:\n  code_config: The code configuration (CodeConfig).\n\nReturns:\n  The resolved Python object.\n\nRaises:\n  ValueError: If the code reference cannot be resolved."
            }
          }
        },
        "invocation_context": {
          "__members__": {
            "InvocationContext": {
              "type": "class",
              "signature": "(*, artifact_service: Optional[google.adk.artifacts.base_artifact_service.BaseArtifactService] = None, session_service: google.adk.sessions.base_session_service.BaseSessionService, memory_service: Optional[google.adk.memory.base_memory_service.BaseMemoryService] = None, credential_service: Optional[google.adk.auth.credential_service.base_credential_service.BaseCredentialService] = None, invocation_id: str, branch: Optional[str] = None, agent: google.adk.agents.base_agent.BaseAgent, user_content: Optional[google.genai.types.Content] = None, session: google.adk.sessions.session.Session, end_invocation: bool = False, live_request_queue: Optional[google.adk.agents.live_request_queue.LiveRequestQueue] = None, active_streaming_tools: Optional[dict[str, google.adk.agents.active_streaming_tool.ActiveStreamingTool]] = None, transcription_cache: Optional[list[google.adk.agents.transcription_entry.TranscriptionEntry]] = None, live_session_resumption_handle: Optional[str] = None, run_config: Optional[google.adk.agents.run_config.RunConfig] = None, plugin_manager: google.adk.plugins.plugin_manager.PluginManager = <factory>) -> None",
              "doc": "An invocation context represents the data of a single invocation of an agent.\n\nAn invocation:\n  1. Starts with a user message and ends with a final response.\n  2. Can contain one or multiple agent calls.\n  3. Is handled by runner.run_async().\n\nAn invocation runs an agent until it does not request to transfer to another\nagent.\n\nAn agent call:\n  1. Is handled by agent.run().\n  2. Ends when agent.run() ends.\n\nAn LLM agent call is an agent with a BaseLLMFlow.\nAn LLM agent call can contain one or multiple steps.\n\nAn LLM agent runs steps in a loop until:\n  1. A final response is generated.\n  2. The agent transfers to another agent.\n  3. The end_invocation is set to true by any callbacks or tools.\n\nA step:\n  1. Calls the LLM only once and yields its response.\n  2. Calls the tools and yields their responses if requested.\n\nThe summarization of the function response is considered another step, since\nit is another llm call.\nA step ends when it's done calling llm and tools, or if the end_invocation\nis set to true at any time.\n\n```\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 invocation \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 llm_agent_call_1 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500 agent_call_2 \u2500\u2510\n   \u250c\u2500\u2500\u2500\u2500 step_1 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500 step_2 \u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   [call_llm] [call_tool] [call_llm] [transfer]\n```"
            },
            "LlmCallsLimitExceededError": {
              "type": "class",
              "signature": null,
              "doc": "Error thrown when the number of LLM calls exceed the limit."
            },
            "_InvocationCostManager": {
              "type": "class",
              "signature": "() -> None",
              "doc": "A container to keep track of the cost of invocation.\n\nWhile we don't expect the metrics captured here to be a direct\nrepresentative of monetary cost incurred in executing the current\ninvocation, they in some ways have an indirect effect."
            },
            "new_invocation_context_id": {
              "type": "function",
              "signature": "() -> 'str'",
              "doc": ""
            }
          }
        },
        "live_request_queue": {
          "__members__": {
            "LiveRequest": {
              "type": "class",
              "signature": "(*, content: Optional[google.genai.types.Content] = None, blob: Optional[google.genai.types.Blob] = None, activity_start: Optional[google.genai.types.ActivityStart] = None, activity_end: Optional[google.genai.types.ActivityEnd] = None, close: bool = False) -> None",
              "doc": "Request send to live agents."
            },
            "LiveRequestQueue": {
              "type": "class",
              "signature": "()",
              "doc": "Queue used to send LiveRequest in a live(bidirectional streaming) way."
            }
          }
        },
        "llm_agent": {
          "__members__": {
            "Agent": {
              "type": "class",
              "signature": "(*, name: str, description: str = '', parent_agent: Optional[google.adk.agents.base_agent.BaseAgent] = None, sub_agents: list[google.adk.agents.base_agent.BaseAgent] = <factory>, before_agent_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]]], NoneType] = None, after_agent_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]]], NoneType] = None, model: Union[str, google.adk.models.base_llm.BaseLlm] = '', instruction: Union[str, Callable[[google.adk.agents.readonly_context.ReadonlyContext], Union[str, Awaitable[str]]]] = '', global_instruction: Union[str, Callable[[google.adk.agents.readonly_context.ReadonlyContext], Union[str, Awaitable[str]]]] = '', tools: list[typing.Union[typing.Callable, google.adk.tools.base_tool.BaseTool, google.adk.tools.base_toolset.BaseToolset]] = <factory>, generate_content_config: Optional[google.genai.types.GenerateContentConfig] = None, disallow_transfer_to_parent: bool = False, disallow_transfer_to_peers: bool = False, include_contents: Literal['default', 'none'] = 'default', input_schema: Optional[type[pydantic.main.BaseModel]] = None, output_schema: Optional[type[pydantic.main.BaseModel]] = None, output_key: Optional[str] = None, planner: Optional[google.adk.planners.base_planner.BasePlanner] = None, code_executor: Optional[google.adk.code_executors.base_code_executor.BaseCodeExecutor] = None, before_model_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext, google.adk.models.llm_request.LlmRequest], Union[Awaitable[Optional[google.adk.models.llm_response.LlmResponse]], google.adk.models.llm_response.LlmResponse, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext, google.adk.models.llm_request.LlmRequest], Union[Awaitable[Optional[google.adk.models.llm_response.LlmResponse]], google.adk.models.llm_response.LlmResponse, NoneType]]], NoneType] = None, after_model_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext, google.adk.models.llm_response.LlmResponse], Union[Awaitable[Optional[google.adk.models.llm_response.LlmResponse]], google.adk.models.llm_response.LlmResponse, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext, google.adk.models.llm_response.LlmResponse], Union[Awaitable[Optional[google.adk.models.llm_response.LlmResponse]], google.adk.models.llm_response.LlmResponse, NoneType]]], NoneType] = None, before_tool_callback: Union[Callable[[google.adk.tools.base_tool.BaseTool, dict[str, Any], google.adk.tools.tool_context.ToolContext], Union[Awaitable[Optional[dict]], dict, NoneType]], list[Callable[[google.adk.tools.base_tool.BaseTool, dict[str, Any], google.adk.tools.tool_context.ToolContext], Union[Awaitable[Optional[dict]], dict, NoneType]]], NoneType] = None, after_tool_callback: Union[Callable[[google.adk.tools.base_tool.BaseTool, dict[str, Any], google.adk.tools.tool_context.ToolContext, dict], Union[Awaitable[Optional[dict]], dict, NoneType]], list[Callable[[google.adk.tools.base_tool.BaseTool, dict[str, Any], google.adk.tools.tool_context.ToolContext, dict], Union[Awaitable[Optional[dict]], dict, NoneType]]], NoneType] = None) -> None",
              "doc": "LLM-based Agent."
            },
            "LlmAgent": {
              "type": "class",
              "signature": "(*, name: str, description: str = '', parent_agent: Optional[google.adk.agents.base_agent.BaseAgent] = None, sub_agents: list[google.adk.agents.base_agent.BaseAgent] = <factory>, before_agent_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]]], NoneType] = None, after_agent_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]]], NoneType] = None, model: Union[str, google.adk.models.base_llm.BaseLlm] = '', instruction: Union[str, Callable[[google.adk.agents.readonly_context.ReadonlyContext], Union[str, Awaitable[str]]]] = '', global_instruction: Union[str, Callable[[google.adk.agents.readonly_context.ReadonlyContext], Union[str, Awaitable[str]]]] = '', tools: list[typing.Union[typing.Callable, google.adk.tools.base_tool.BaseTool, google.adk.tools.base_toolset.BaseToolset]] = <factory>, generate_content_config: Optional[google.genai.types.GenerateContentConfig] = None, disallow_transfer_to_parent: bool = False, disallow_transfer_to_peers: bool = False, include_contents: Literal['default', 'none'] = 'default', input_schema: Optional[type[pydantic.main.BaseModel]] = None, output_schema: Optional[type[pydantic.main.BaseModel]] = None, output_key: Optional[str] = None, planner: Optional[google.adk.planners.base_planner.BasePlanner] = None, code_executor: Optional[google.adk.code_executors.base_code_executor.BaseCodeExecutor] = None, before_model_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext, google.adk.models.llm_request.LlmRequest], Union[Awaitable[Optional[google.adk.models.llm_response.LlmResponse]], google.adk.models.llm_response.LlmResponse, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext, google.adk.models.llm_request.LlmRequest], Union[Awaitable[Optional[google.adk.models.llm_response.LlmResponse]], google.adk.models.llm_response.LlmResponse, NoneType]]], NoneType] = None, after_model_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext, google.adk.models.llm_response.LlmResponse], Union[Awaitable[Optional[google.adk.models.llm_response.LlmResponse]], google.adk.models.llm_response.LlmResponse, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext, google.adk.models.llm_response.LlmResponse], Union[Awaitable[Optional[google.adk.models.llm_response.LlmResponse]], google.adk.models.llm_response.LlmResponse, NoneType]]], NoneType] = None, before_tool_callback: Union[Callable[[google.adk.tools.base_tool.BaseTool, dict[str, Any], google.adk.tools.tool_context.ToolContext], Union[Awaitable[Optional[dict]], dict, NoneType]], list[Callable[[google.adk.tools.base_tool.BaseTool, dict[str, Any], google.adk.tools.tool_context.ToolContext], Union[Awaitable[Optional[dict]], dict, NoneType]]], NoneType] = None, after_tool_callback: Union[Callable[[google.adk.tools.base_tool.BaseTool, dict[str, Any], google.adk.tools.tool_context.ToolContext, dict], Union[Awaitable[Optional[dict]], dict, NoneType]], list[Callable[[google.adk.tools.base_tool.BaseTool, dict[str, Any], google.adk.tools.tool_context.ToolContext, dict], Union[Awaitable[Optional[dict]], dict, NoneType]]], NoneType] = None) -> None",
              "doc": "LLM-based Agent."
            },
            "_convert_tool_union_to_tools": {
              "type": "function",
              "signature": "(tool_union: 'ToolUnion', ctx: 'ReadonlyContext') -> 'list[BaseTool]'",
              "doc": ""
            }
          }
        },
        "llm_agent_config": {
          "__members__": {
            "LlmAgentConfig": {
              "type": "class",
              "signature": "(*, agent_class: Literal['LlmAgent', ''] = 'LlmAgent', name: str, description: str = '', sub_agents: Optional[List[google.adk.agents.common_configs.AgentRefConfig]] = None, before_agent_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None, after_agent_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None, model: Optional[str] = None, instruction: str, disallow_transfer_to_parent: Optional[bool] = None, disallow_transfer_to_peers: Optional[bool] = None, input_schema: Optional[google.adk.agents.common_configs.CodeConfig] = None, output_schema: Optional[google.adk.agents.common_configs.CodeConfig] = None, output_key: Optional[str] = None, include_contents: Literal['default', 'none'] = 'default', tools: Optional[list[google.adk.tools.base_tool.ToolConfig]] = None, before_model_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None, after_model_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None, before_tool_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None, after_tool_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None, generate_content_config: Optional[google.genai.types.GenerateContentConfig] = None) -> None",
              "doc": "The config for the YAML schema of a LlmAgent."
            }
          }
        },
        "loop_agent": {
          "__members__": {
            "LoopAgent": {
              "type": "class",
              "signature": "(*, name: str, description: str = '', parent_agent: Optional[google.adk.agents.base_agent.BaseAgent] = None, sub_agents: list[google.adk.agents.base_agent.BaseAgent] = <factory>, before_agent_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]]], NoneType] = None, after_agent_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]]], NoneType] = None, max_iterations: Optional[int] = None) -> None",
              "doc": "A shell agent that run its sub-agents in a loop.\n\nWhen sub-agent generates an event with escalate or max_iterations are\nreached, the loop agent will stop."
            }
          }
        },
        "loop_agent_config": {
          "__members__": {
            "LoopAgentConfig": {
              "type": "class",
              "signature": "(*, agent_class: Literal['LoopAgent'] = 'LoopAgent', name: str, description: str = '', sub_agents: Optional[List[google.adk.agents.common_configs.AgentRefConfig]] = None, before_agent_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None, after_agent_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None, max_iterations: Optional[int] = None) -> None",
              "doc": "The config for the YAML schema of a LoopAgent."
            }
          }
        },
        "parallel_agent": {
          "__members__": {
            "ParallelAgent": {
              "type": "class",
              "signature": "(*, name: str, description: str = '', parent_agent: Optional[google.adk.agents.base_agent.BaseAgent] = None, sub_agents: list[google.adk.agents.base_agent.BaseAgent] = <factory>, before_agent_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]]], NoneType] = None, after_agent_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]]], NoneType] = None) -> None",
              "doc": "A shell agent that run its sub-agents in parallel in isolated manner.\n\nThis approach is beneficial for scenarios requiring multiple perspectives or\nattempts on a single task, such as:\n\n- Running different algorithms simultaneously.\n- Generating multiple responses for review by a subsequent evaluation agent."
            },
            "_create_branch_ctx_for_sub_agent": {
              "type": "function",
              "signature": "(agent: 'BaseAgent', sub_agent: 'BaseAgent', invocation_context: 'InvocationContext') -> 'InvocationContext'",
              "doc": "Create isolated branch for every sub-agent."
            },
            "_merge_agent_run": {
              "type": "function",
              "signature": "(agent_runs: 'list[AsyncGenerator[Event, None]]') -> 'AsyncGenerator[Event, None]'",
              "doc": "Merges the agent run event generator.\n\nThis implementation guarantees for each agent, it won't move on until the\ngenerated event is processed by upstream runner.\n\nArgs:\n    agent_runs: A list of async generators that yield events from each agent.\n\nYields:\n    Event: The next event from the merged generator."
            }
          }
        },
        "parallel_agent_config": {
          "__members__": {
            "ParallelAgentConfig": {
              "type": "class",
              "signature": "(*, agent_class: Literal['ParallelAgent'] = 'ParallelAgent', name: str, description: str = '', sub_agents: Optional[List[google.adk.agents.common_configs.AgentRefConfig]] = None, before_agent_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None, after_agent_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None) -> None",
              "doc": "The config for the YAML schema of a ParallelAgent."
            }
          }
        },
        "readonly_context": {
          "__members__": {
            "ReadonlyContext": {
              "type": "class",
              "signature": "(invocation_context: 'InvocationContext') -> 'None'",
              "doc": ""
            }
          }
        },
        "run_config": {
          "__members__": {
            "RunConfig": {
              "type": "class",
              "signature": "(*, speech_config: Optional[google.genai.types.SpeechConfig] = None, response_modalities: Optional[list[str]] = None, save_input_blobs_as_artifacts: bool = False, support_cfc: bool = False, streaming_mode: google.adk.agents.run_config.StreamingMode = <StreamingMode.NONE: None>, output_audio_transcription: Optional[google.genai.types.AudioTranscriptionConfig] = None, input_audio_transcription: Optional[google.genai.types.AudioTranscriptionConfig] = None, realtime_input_config: Optional[google.genai.types.RealtimeInputConfig] = None, enable_affective_dialog: Optional[bool] = None, proactivity: Optional[google.genai.types.ProactivityConfig] = None, session_resumption: Optional[google.genai.types.SessionResumptionConfig] = None, max_llm_calls: int = 500) -> None",
              "doc": "Configs for runtime behavior of agents."
            },
            "StreamingMode": {
              "type": "class",
              "signature": "(*values)",
              "doc": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
            }
          }
        },
        "sequential_agent": {
          "__members__": {
            "SequentialAgent": {
              "type": "class",
              "signature": "(*, config_type: Type[google.adk.agents.base_agent_config.BaseAgentConfig] = <class 'google.adk.agents.sequential_agent_config.SequentialAgentConfig'>, name: str, description: str = '', parent_agent: Optional[google.adk.agents.base_agent.BaseAgent] = None, sub_agents: list[google.adk.agents.base_agent.BaseAgent] = <factory>, before_agent_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]]], NoneType] = None, after_agent_callback: Union[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]], list[Callable[[google.adk.agents.callback_context.CallbackContext], Union[Awaitable[Optional[google.genai.types.Content]], google.genai.types.Content, NoneType]]], NoneType] = None) -> None",
              "doc": "A shell agent that runs its sub-agents in sequence."
            }
          }
        },
        "sequential_agent_config": {
          "__members__": {
            "SequentialAgentConfig": {
              "type": "class",
              "signature": "(*, agent_class: Literal['SequentialAgent'] = 'SequentialAgent', name: str, description: str = '', sub_agents: Optional[List[google.adk.agents.common_configs.AgentRefConfig]] = None, before_agent_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None, after_agent_callbacks: Optional[List[google.adk.agents.common_configs.CodeConfig]] = None) -> None",
              "doc": "The config for the YAML schema of a SequentialAgent."
            }
          }
        },
        "transcription_entry": {
          "__members__": {
            "TranscriptionEntry": {
              "type": "class",
              "signature": "(*, role: Optional[str] = None, data: Union[google.genai.types.Blob, google.genai.types.Content]) -> None",
              "doc": "Store the data that can be used for transcription."
            }
          }
        }
      },
      "artifacts": {
        "base_artifact_service": {
          "__members__": {
            "BaseArtifactService": {
              "type": "class",
              "signature": "()",
              "doc": "Abstract base class for artifact services."
            }
          }
        },
        "gcs_artifact_service": {
          "__members__": {
            "GcsArtifactService": {
              "type": "class",
              "signature": "(bucket_name: 'str', **kwargs)",
              "doc": "An artifact service implementation using Google Cloud Storage (GCS)."
            }
          }
        },
        "in_memory_artifact_service": {
          "__members__": {
            "InMemoryArtifactService": {
              "type": "class",
              "signature": "(*, artifacts: dict[str, list[google.genai.types.Part]] = <factory>) -> None",
              "doc": "An in-memory implementation of the artifact service.\n\nIt is not suitable for multi-threaded production environments. Use it for\ntesting and development only."
            }
          }
        }
      },
      "auth": {
        "auth_credential": {
          "__members__": {
            "AuthCredential": {
              "type": "class",
              "signature": "(*, authType: google.adk.auth.auth_credential.AuthCredentialTypes, resourceRef: Optional[str] = None, apiKey: Optional[str] = None, http: Optional[google.adk.auth.auth_credential.HttpAuth] = None, serviceAccount: Optional[google.adk.auth.auth_credential.ServiceAccount] = None, oauth2: Optional[google.adk.auth.auth_credential.OAuth2Auth] = None, **extra_data: Any) -> None",
              "doc": "Data class representing an authentication credential.\n\nTo exchange for the actual credential, please use\nCredentialExchanger.exchange_credential().\n\nExamples: API Key Auth\nAuthCredential(\n    auth_type=AuthCredentialTypes.API_KEY,\n    api_key=\"1234\",\n)\n\nExample: HTTP Auth\nAuthCredential(\n    auth_type=AuthCredentialTypes.HTTP,\n    http=HttpAuth(\n        scheme=\"basic\",\n        credentials=HttpCredentials(username=\"user\", password=\"password\"),\n    ),\n)\n\nExample: OAuth2 Bearer Token in HTTP Header\nAuthCredential(\n    auth_type=AuthCredentialTypes.HTTP,\n    http=HttpAuth(\n        scheme=\"bearer\",\n        credentials=HttpCredentials(token=\"eyAkaknabna....\"),\n    ),\n)\n\nExample: OAuth2 Auth with Authorization Code Flow\nAuthCredential(\n    auth_type=AuthCredentialTypes.OAUTH2,\n    oauth2=OAuth2Auth(\n        client_id=\"1234\",\n        client_secret=\"secret\",\n    ),\n)\n\nExample: OpenID Connect Auth\nAuthCredential(\n    auth_type=AuthCredentialTypes.OPEN_ID_CONNECT,\n    oauth2=OAuth2Auth(\n        client_id=\"1234\",\n        client_secret=\"secret\",\n        redirect_uri=\"https://example.com\",\n        scopes=[\"scope1\", \"scope2\"],\n    ),\n)\n\nExample: Auth with resource reference\nAuthCredential(\n    auth_type=AuthCredentialTypes.API_KEY,\n    resource_ref=\"projects/1234/locations/us-central1/resources/resource1\",\n)"
            },
            "AuthCredentialTypes": {
              "type": "class",
              "signature": "(*values)",
              "doc": "Represents the type of authentication credential."
            },
            "BaseModelWithConfig": {
              "type": "class",
              "signature": "(**extra_data: Any) -> None",
              "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
            },
            "HttpAuth": {
              "type": "class",
              "signature": "(*, scheme: str, credentials: google.adk.auth.auth_credential.HttpCredentials, **extra_data: Any) -> None",
              "doc": "The credentials and metadata for HTTP authentication."
            },
            "HttpCredentials": {
              "type": "class",
              "signature": "(*, username: Optional[str] = None, password: Optional[str] = None, token: Optional[str] = None, **extra_data: Any) -> None",
              "doc": "Represents the secret token value for HTTP authentication, like user name, password, oauth token, etc."
            },
            "OAuth2Auth": {
              "type": "class",
              "signature": "(*, clientId: Optional[str] = None, clientSecret: Optional[str] = None, authUri: Optional[str] = None, state: Optional[str] = None, redirectUri: Optional[str] = None, authResponseUri: Optional[str] = None, authCode: Optional[str] = None, accessToken: Optional[str] = None, refreshToken: Optional[str] = None, expiresAt: Optional[int] = None, expiresIn: Optional[int] = None, **extra_data: Any) -> None",
              "doc": "Represents credential value and its metadata for a OAuth2 credential."
            },
            "ServiceAccount": {
              "type": "class",
              "signature": "(*, serviceAccountCredential: Optional[google.adk.auth.auth_credential.ServiceAccountCredential] = None, scopes: List[str], useDefaultCredential: Optional[bool] = False, **extra_data: Any) -> None",
              "doc": "Represents Google Service Account configuration."
            },
            "ServiceAccountCredential": {
              "type": "class",
              "signature": "(*, type: str = '', projectId: str, privateKeyId: str, privateKey: str, clientEmail: str, clientId: str, authUri: str, tokenUri: str, authProviderX509CertUrl: str, clientX509CertUrl: str, universeDomain: str, **extra_data: Any) -> None",
              "doc": "Represents Google Service Account configuration.\n\nAttributes:\n  type: The type should be \"service_account\".\n  project_id: The project ID.\n  private_key_id: The ID of the private key.\n  private_key: The private key.\n  client_email: The client email.\n  client_id: The client ID.\n  auth_uri: The authorization URI.\n  token_uri: The token URI.\n  auth_provider_x509_cert_url: URL for auth provider's X.509 cert.\n  client_x509_cert_url: URL for the client's X.509 cert.\n  universe_domain: The universe domain.\n\nExample:\n\n    config = ServiceAccountCredential(\n        type_=\"service_account\",\n        project_id=\"your_project_id\",\n        private_key_id=\"your_private_key_id\",\n        private_key=\"-----BEGIN PRIVATE KEY-----...\",\n        client_email=\"...@....iam.gserviceaccount.com\",\n        client_id=\"your_client_id\",\n        auth_uri=\"https://accounts.google.com/o/oauth2/auth\",\n        token_uri=\"https://oauth2.googleapis.com/token\",\n        auth_provider_x509_cert_url=\"https://www.googleapis.com/oauth2/v1/certs\",\n        client_x509_cert_url=\"https://www.googleapis.com/robot/v1/metadata/x509/...\",\n        universe_domain=\"googleapis.com\"\n    )\n\n\n    config = ServiceAccountConfig.model_construct(**{\n        ...service account config dict\n    })"
            }
          }
        },
        "auth_handler": {
          "__members__": {
            "AuthHandler": {
              "type": "class",
              "signature": "(auth_config: 'AuthConfig')",
              "doc": "A handler that handles the auth flow in Agent Development Kit to help\norchestrate the credential request and response flow (e.g. OAuth flow)\nThis class should only be used by Agent Development Kit."
            }
          }
        },
        "auth_preprocessor": {
          "__members__": {
            "_AuthLlmRequestProcessor": {
              "type": "class",
              "signature": "()",
              "doc": "Handles auth information to build the LLM request."
            }
          }
        },
        "auth_schemes": {
          "__members__": {
            "OAuthGrantType": {
              "type": "class",
              "signature": "(*values)",
              "doc": "Represents the OAuth2 flow (or grant type)."
            },
            "OpenIdConnectWithConfig": {
              "type": "class",
              "signature": "(*, type: fastapi.openapi.models.SecuritySchemeType = <SecuritySchemeType.openIdConnect: 'openIdConnect'>, description: Optional[str] = None, authorization_endpoint: str, token_endpoint: str, userinfo_endpoint: Optional[str] = None, revocation_endpoint: Optional[str] = None, token_endpoint_auth_methods_supported: Optional[List[str]] = None, grant_types_supported: Optional[List[str]] = None, scopes: Optional[List[str]] = None, **extra_data: Any) -> None",
              "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
            }
          }
        },
        "auth_tool": {
          "__members__": {
            "AuthConfig": {
              "type": "class",
              "signature": "(*, authScheme: Union[fastapi.openapi.models.APIKey, fastapi.openapi.models.HTTPBase, fastapi.openapi.models.OAuth2, fastapi.openapi.models.OpenIdConnect, fastapi.openapi.models.HTTPBearer, google.adk.auth.auth_schemes.OpenIdConnectWithConfig], rawAuthCredential: Optional[google.adk.auth.auth_credential.AuthCredential] = None, exchangedAuthCredential: Optional[google.adk.auth.auth_credential.AuthCredential] = None, credentialKey: Optional[str] = None, **data) -> None",
              "doc": "The auth config sent by tool asking client to collect auth credentials and\n\nadk and client will help to fill in the response"
            },
            "AuthToolArguments": {
              "type": "class",
              "signature": "(*, functionCallId: str, authConfig: google.adk.auth.auth_tool.AuthConfig, **extra_data: Any) -> None",
              "doc": "the arguments for the special long running function tool that is used to\n\nrequest end user credentials."
            }
          }
        },
        "credential_manager": {
          "__members__": {
            "CredentialManager": {
              "type": "class",
              "signature": "(auth_config: 'AuthConfig')",
              "doc": "Manages authentication credentials through a structured workflow.\n\nThe CredentialManager orchestrates the complete lifecycle of authentication\ncredentials, from initial loading to final preparation for use. It provides\na centralized interface for handling various credential types and authentication\nschemes while maintaining proper credential hygiene (refresh, exchange, caching).\n\nThis class is only for use by Agent Development Kit.\n\nArgs:\n    auth_config: Configuration containing authentication scheme and credentials\n\nExample:\n    ```python\n    auth_config = AuthConfig(\n        auth_scheme=oauth2_scheme,\n        raw_auth_credential=service_account_credential\n    )\n    manager = CredentialManager(auth_config)\n\n    # Register custom exchanger if needed\n    manager.register_credential_exchanger(\n        AuthCredentialTypes.CUSTOM_TYPE,\n        CustomCredentialExchanger()\n    )\n\n    # Register custom refresher if needed\n    manager.register_credential_refresher(\n        AuthCredentialTypes.CUSTOM_TYPE,\n        CustomCredentialRefresher()\n    )\n\n    # Load and prepare credential\n    credential = await manager.load_auth_credential(callback_context)\n    ```"
            }
          }
        },
        "credential_service": {
          "base_credential_service": {
            "__members__": {
              "BaseCredentialService": {
                "type": "class",
                "signature": "()",
                "doc": "Abstract class for Service that loads / saves tool credentials from / to\nthe backend credential store."
              }
            }
          },
          "in_memory_credential_service": {
            "__members__": {
              "InMemoryCredentialService": {
                "type": "class",
                "signature": "()",
                "doc": "Class for in memory implementation of credential service(Experimental)"
              }
            }
          },
          "session_state_credential_service": {
            "__members__": {
              "SessionStateCredentialService": {
                "type": "class",
                "signature": "()",
                "doc": "Class for implementation of credential service using session state as the\nstore.\nNote: store credential in session may not be secure, use at your own risk."
              }
            }
          }
        },
        "exchanger": {
          "base_credential_exchanger": {
            "__members__": {
              "BaseCredentialExchanger": {
                "type": "class",
                "signature": "()",
                "doc": "Base interface for credential exchangers.\n\nCredential exchangers are responsible for exchanging credentials from\none format or scheme to another."
              },
              "CredentialExchangError": {
                "type": "class",
                "signature": null,
                "doc": "Base exception for credential exchange errors."
              }
            }
          },
          "credential_exchanger_registry": {
            "__members__": {
              "CredentialExchangerRegistry": {
                "type": "class",
                "signature": "()",
                "doc": "Registry for credential exchanger instances."
              }
            }
          },
          "oauth2_credential_exchanger": {
            "__members__": {
              "OAuth2CredentialExchanger": {
                "type": "class",
                "signature": "()",
                "doc": "Exchanges OAuth2 credentials from authorization responses."
              }
            }
          }
        },
        "oauth2_credential_util": {
          "__members__": {
            "create_oauth2_session": {
              "type": "function",
              "signature": "(auth_scheme: 'AuthScheme', auth_credential: 'AuthCredential') -> 'Tuple[Optional[OAuth2Session], Optional[str]]'",
              "doc": "Create an OAuth2 session for token operations.\n\nArgs:\n    auth_scheme: The authentication scheme configuration.\n    auth_credential: The authentication credential.\n\nReturns:\n    Tuple of (OAuth2Session, token_endpoint) or (None, None) if cannot create session."
            },
            "update_credential_with_tokens": {
              "type": "function",
              "signature": "(auth_credential: 'AuthCredential', tokens: 'OAuth2Token') -> 'None'",
              "doc": "Update the credential with new tokens.\n\nArgs:\n    auth_credential: The authentication credential to update.\n    tokens: The OAuth2Token object containing new token information."
            }
          }
        },
        "refresher": {
          "base_credential_refresher": {
            "__members__": {
              "BaseCredentialRefresher": {
                "type": "class",
                "signature": "()",
                "doc": "Base interface for credential refreshers.\n\nCredential refreshers are responsible for checking if a credential is expired\nor needs to be refreshed, and for refreshing it if necessary."
              },
              "CredentialRefresherError": {
                "type": "class",
                "signature": null,
                "doc": "Base exception for credential refresh errors."
              }
            }
          },
          "credential_refresher_registry": {
            "__members__": {
              "CredentialRefresherRegistry": {
                "type": "class",
                "signature": "()",
                "doc": "Registry for credential refresher instances."
              }
            }
          },
          "oauth2_credential_refresher": {
            "__members__": {
              "OAuth2CredentialRefresher": {
                "type": "class",
                "signature": "()",
                "doc": "Refreshes OAuth2 credentials including Google OAuth2 JSON credentials."
              }
            }
          }
        }
      },
      "cli": {
        "adk_web_server": {
          "__members__": {
            "AddSessionToEvalSetRequest": {
              "type": "class",
              "signature": "(*, evalId: str, sessionId: str, userId: str) -> None",
              "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
            },
            "AdkWebServer": {
              "type": "class",
              "signature": "(*, agent_loader: 'BaseAgentLoader', session_service: 'BaseSessionService', memory_service: 'BaseMemoryService', artifact_service: 'BaseArtifactService', credential_service: 'BaseCredentialService', eval_sets_manager: 'EvalSetsManager', eval_set_results_manager: 'EvalSetResultsManager', agents_dir: 'str')",
              "doc": "Helper class for setting up and running the ADK web server on FastAPI.\n\nYou construct this class with all the Services required to run ADK agents and\ncan then call the get_fast_api_app method to get a FastAPI app instance that\ncan will use your provided service instances, static assets, and agent loader.\nIf you pass in a web_assets_dir, the static assets will be served under\n/dev-ui in addition to the API endpoints created by default.\n\nYou can add add additional API endpoints by modifying the FastAPI app\ninstance returned by get_fast_api_app as this class exposes the agent runners\nand most other bits of state retained during the lifetime of the server.\n\nAttributes:\n    agent_loader: An instance of BaseAgentLoader for loading agents.\n    session_service: An instance of BaseSessionService for managing sessions.\n    memory_service: An instance of BaseMemoryService for managing memory.\n    artifact_service: An instance of BaseArtifactService for managing\n      artifacts.\n    credential_service: An instance of BaseCredentialService for managing\n      credentials.\n    eval_sets_manager: An instance of EvalSetsManager for managing evaluation\n      sets.\n    eval_set_results_manager: An instance of EvalSetResultsManager for\n      managing evaluation set results.\n    agents_dir: Root directory containing subdirs for agents with those\n      containing resources (e.g. .env files, eval sets, etc.) for the agents.\n    runners_to_clean: Set of runner names marked for cleanup.\n    current_app_name_ref: A shared reference to the latest ran app name.\n    runner_dict: A dict of instantiated runners for each app."
            },
            "AgentRunRequest": {
              "type": "class",
              "signature": "(*, appName: str, userId: str, sessionId: str, newMessage: google.genai.types.Content, streaming: bool = False, stateDelta: Optional[dict[str, Any]] = None) -> None",
              "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
            },
            "ApiServerSpanExporter": {
              "type": "class",
              "signature": "(trace_dict)",
              "doc": "Interface for exporting spans.\n\nInterface to be implemented by services that want to export spans recorded\nin their own format.\n\nTo export data this MUST be registered to the :class`opentelemetry.sdk.trace.Tracer` using a\n`SimpleSpanProcessor` or a `BatchSpanProcessor`."
            },
            "GetEventGraphResult": {
              "type": "class",
              "signature": "(*, dotSrc: str) -> None",
              "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
            },
            "InMemoryExporter": {
              "type": "class",
              "signature": "(trace_dict)",
              "doc": "Interface for exporting spans.\n\nInterface to be implemented by services that want to export spans recorded\nin their own format.\n\nTo export data this MUST be registered to the :class`opentelemetry.sdk.trace.Tracer` using a\n`SimpleSpanProcessor` or a `BatchSpanProcessor`."
            },
            "RunEvalRequest": {
              "type": "class",
              "signature": "(*, evalIds: list[str], evalMetrics: list[google.adk.evaluation.eval_metrics.EvalMetric]) -> None",
              "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
            },
            "RunEvalResult": {
              "type": "class",
              "signature": "(*, evalSetFile: str, evalSetId: str, evalId: str, finalEvalStatus: google.adk.evaluation.evaluator.EvalStatus, evalMetricResults: list[tuple[google.adk.evaluation.eval_metrics.EvalMetric, google.adk.evaluation.eval_metrics.EvalMetricResult]] = [], overallEvalMetricResults: list[google.adk.evaluation.eval_metrics.EvalMetricResult], evalMetricResultPerInvocation: list[google.adk.evaluation.eval_metrics.EvalMetricResultPerInvocation], userId: str, sessionId: str) -> None",
              "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
            }
          }
        },
        "agent_graph": {
          "__members__": {
            "build_graph": {
              "type": "function",
              "signature": "(graph: 'graphviz.Digraph', agent: 'BaseAgent', highlight_pairs, parent_agent=None)",
              "doc": "Build a graph of the agent and its sub-agents.\nArgs:\n  graph: The graph to build on.\n  agent: The agent to build the graph for.\n  highlight_pairs: A list of pairs of nodes to highlight.\n  parent_agent: The parent agent of the current agent. This is specifically used when building Workflow Agents to directly connect a node to nodes inside a Workflow Agent.\n\nReturns:\n  None"
            },
            "get_agent_graph": {
              "type": "function",
              "signature": "(root_agent, highlights_pairs, image=False)",
              "doc": ""
            }
          }
        },
        "cli": {
          "__members__": {
            "InputFile": {
              "type": "class",
              "signature": "(*, state: dict[str, object], queries: list[str]) -> None",
              "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
            },
            "run_cli": {
              "type": "function",
              "signature": "(*, agent_parent_dir: 'str', agent_folder_name: 'str', input_file: 'Optional[str]' = None, saved_session_file: 'Optional[str]' = None, save_session: 'bool', session_id: 'Optional[str]' = None) -> 'None'",
              "doc": "Runs an interactive CLI for a certain agent.\n\nArgs:\n  agent_parent_dir: str, the absolute path of the parent folder of the agent\n    folder.\n  agent_folder_name: str, the name of the agent folder.\n  input_file: Optional[str], the absolute path to the json file that contains\n    the initial session state and user queries, exclusive with\n    saved_session_file.\n  saved_session_file: Optional[str], the absolute path to the json file that\n    contains a previously saved session, exclusive with input_file.\n  save_session: bool, whether to save the session on exit.\n  session_id: Optional[str], the session ID to save the session to on exit."
            },
            "run_input_file": {
              "type": "function",
              "signature": "(app_name: 'str', user_id: 'str', root_agent: 'LlmAgent', artifact_service: 'BaseArtifactService', session_service: 'BaseSessionService', credential_service: 'BaseCredentialService', input_path: 'str') -> 'Session'",
              "doc": ""
            },
            "run_interactively": {
              "type": "function",
              "signature": "(root_agent: 'LlmAgent', artifact_service: 'BaseArtifactService', session: 'Session', session_service: 'BaseSessionService', credential_service: 'BaseCredentialService') -> 'None'",
              "doc": ""
            }
          }
        },
        "cli_create": {
          "__members__": {
            "Type": {
              "type": "class",
              "signature": "(*values)",
              "doc": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
            },
            "_generate_files": {
              "type": "function",
              "signature": "(agent_folder: 'str', *, google_api_key: 'Optional[str]' = None, google_cloud_project: 'Optional[str]' = None, google_cloud_region: 'Optional[str]' = None, model: 'Optional[str]' = None, type: 'Optional[Type]' = None)",
              "doc": "Generates a folder name for the agent."
            },
            "_get_gcp_project_from_gcloud": {
              "type": "function",
              "signature": "() -> 'str'",
              "doc": "Uses gcloud to get default project."
            },
            "_get_gcp_region_from_gcloud": {
              "type": "function",
              "signature": "() -> 'str'",
              "doc": "Uses gcloud to get default region."
            },
            "_prompt_for_google_api_key": {
              "type": "function",
              "signature": "(google_api_key: 'Optional[str]') -> 'str'",
              "doc": "Prompts user for Google API key."
            },
            "_prompt_for_google_cloud": {
              "type": "function",
              "signature": "(google_cloud_project: 'Optional[str]') -> 'str'",
              "doc": "Prompts user for Google Cloud project ID."
            },
            "_prompt_for_google_cloud_region": {
              "type": "function",
              "signature": "(google_cloud_region: 'Optional[str]') -> 'str'",
              "doc": "Prompts user for Google Cloud region."
            },
            "_prompt_for_model": {
              "type": "function",
              "signature": "() -> 'str'",
              "doc": ""
            },
            "_prompt_str": {
              "type": "function",
              "signature": "(prompt_prefix: 'str', *, prior_msg: 'Optional[str]' = None, default_value: 'Optional[str]' = None) -> 'str'",
              "doc": ""
            },
            "_prompt_to_choose_backend": {
              "type": "function",
              "signature": "(google_api_key: 'Optional[str]', google_cloud_project: 'Optional[str]', google_cloud_region: 'Optional[str]') -> 'Tuple[Optional[str], Optional[str], Optional[str]]'",
              "doc": "Prompts user to choose backend.\n\nReturns:\n  A tuple of (google_api_key, google_cloud_project, google_cloud_region)."
            },
            "_prompt_to_choose_type": {
              "type": "function",
              "signature": "() -> 'Type'",
              "doc": "Prompts user to choose type of agent to create."
            },
            "run_cmd": {
              "type": "function",
              "signature": "(agent_name: 'str', *, model: 'Optional[str]', google_api_key: 'Optional[str]', google_cloud_project: 'Optional[str]', google_cloud_region: 'Optional[str]', type: 'Optional[Type]')",
              "doc": "Runs `adk create` command to create agent template.\n\nArgs:\n  agent_name: str, The name of the agent.\n  google_api_key: Optional[str], The Google API key for using Google AI as\n    backend.\n  google_cloud_project: Optional[str], The Google Cloud project for using\n    VertexAI as backend.\n  google_cloud_region: Optional[str], The Google Cloud region for using\n    VertexAI as backend.\n  type: Optional[Type], Whether to define agent with config file or code."
            }
          }
        },
        "cli_deploy": {
          "__members__": {
            "_get_service_option_by_adk_version": {
              "type": "function",
              "signature": "(adk_version: 'str', session_uri: 'Optional[str]', artifact_uri: 'Optional[str]', memory_uri: 'Optional[str]') -> 'str'",
              "doc": "Returns service option string based on adk_version."
            },
            "_resolve_project": {
              "type": "function",
              "signature": "(project_in_option: 'Optional[str]') -> 'str'",
              "doc": ""
            },
            "to_agent_engine": {
              "type": "function",
              "signature": "(*, agent_folder: 'str', temp_folder: 'str', adk_app: 'str', staging_bucket: 'str', trace_to_cloud: 'bool', agent_engine_id: 'Optional[str]' = None, absolutize_imports: 'bool' = True, project: 'Optional[str]' = None, region: 'Optional[str]' = None, display_name: 'Optional[str]' = None, description: 'Optional[str]' = None, requirements_file: 'Optional[str]' = None, env_file: 'Optional[str]' = None)",
              "doc": "Deploys an agent to Vertex AI Agent Engine.\n\n`agent_folder` should contain the following files:\n\n- __init__.py\n- agent.py\n- <adk_app>.py (optional, for customization; will be autogenerated otherwise)\n- requirements.txt (optional, for additional dependencies)\n- .env (optional, for environment variables)\n- ... (other required source files)\n\nThe contents of `adk_app` should look something like:\n\n```\nfrom agent import root_agent\nfrom vertexai.preview.reasoning_engines import AdkApp\n\nadk_app = AdkApp(\n  agent=root_agent,\n  enable_tracing=True,\n)\n```\n\nArgs:\n  agent_folder (str): The folder (absolute path) containing the agent source\n    code.\n  temp_folder (str): The temp folder for the generated Agent Engine source\n    files. It will be replaced with the generated files if it already exists.\n  project (str): Google Cloud project id.\n  region (str): Google Cloud region.\n  staging_bucket (str): The GCS bucket for staging the deployment artifacts.\n  trace_to_cloud (bool): Whether to enable Cloud Trace.\n  agent_engine_id (str): The ID of the Agent Engine instance to update. If not\n    specified, a new Agent Engine instance will be created.\n  absolutize_imports (bool): Whether to absolutize imports. If True, all relative\n    imports will be converted to absolute import statements. Default is True.\n  requirements_file (str): The filepath to the `requirements.txt` file to use.\n    If not specified, the `requirements.txt` file in the `agent_folder` will\n    be used.\n  env_file (str): The filepath to the `.env` file for environment variables.\n    If not specified, the `.env` file in the `agent_folder` will be used. The\n    values of `GOOGLE_CLOUD_PROJECT` and `GOOGLE_CLOUD_LOCATION` will be\n    overridden by `project` and `region` if they are specified."
            },
            "to_cloud_run": {
              "type": "function",
              "signature": "(*, agent_folder: 'str', project: 'Optional[str]', region: 'Optional[str]', service_name: 'str', app_name: 'str', temp_folder: 'str', port: 'int', trace_to_cloud: 'bool', with_ui: 'bool', log_level: 'str', verbosity: 'str', adk_version: 'str', allow_origins: 'Optional[list[str]]' = None, session_service_uri: 'Optional[str]' = None, artifact_service_uri: 'Optional[str]' = None, memory_service_uri: 'Optional[str]' = None, a2a: 'bool' = False)",
              "doc": "Deploys an agent to Google Cloud Run.\n\n`agent_folder` should contain the following files:\n\n- __init__.py\n- agent.py\n- requirements.txt (optional, for additional dependencies)\n- ... (other required source files)\n\nThe folder structure of temp_folder will be\n\n* dist/[google_adk wheel file]\n* agents/[app_name]/\n  * agent source code from `agent_folder`\n\nArgs:\n  agent_folder: The folder (absolute path) containing the agent source code.\n  project: Google Cloud project id.\n  region: Google Cloud region.\n  service_name: The service name in Cloud Run.\n  app_name: The name of the app, by default, it's basename of `agent_folder`.\n  temp_folder: The temp folder for the generated Cloud Run source files.\n  port: The port of the ADK api server.\n  trace_to_cloud: Whether to enable Cloud Trace.\n  with_ui: Whether to deploy with UI.\n  verbosity: The verbosity level of the CLI.\n  adk_version: The ADK version to use in Cloud Run.\n  allow_origins: The list of allowed origins for the ADK api server.\n  session_service_uri: The URI of the session service.\n  artifact_service_uri: The URI of the artifact service.\n  memory_service_uri: The URI of the memory service."
            },
            "to_gke": {
              "type": "function",
              "signature": "(*, agent_folder: 'str', project: 'Optional[str]', region: 'Optional[str]', cluster_name: 'str', service_name: 'str', app_name: 'str', temp_folder: 'str', port: 'int', trace_to_cloud: 'bool', with_ui: 'bool', log_level: 'str', adk_version: 'str', allow_origins: 'Optional[list[str]]' = None, session_service_uri: 'Optional[str]' = None, artifact_service_uri: 'Optional[str]' = None, memory_service_uri: 'Optional[str]' = None, a2a: 'bool' = False)",
              "doc": "Deploys an agent to Google Kubernetes Engine(GKE).\n\nArgs:\n  agent_folder: The folder (absolute path) containing the agent source code.\n  project: Google Cloud project id.\n  region: Google Cloud region.\n  cluster_name: The name of the GKE cluster.\n  service_name: The service name in GKE.\n  app_name: The name of the app, by default, it's basename of `agent_folder`.\n  temp_folder: The local directory to use as a temporary workspace for preparing deployment artifacts. The tool populates this folder with a copy of the agent's source code and auto-generates necessary files like a Dockerfile and deployment.yaml.\n  port: The port of the ADK api server.\n  trace_to_cloud: Whether to enable Cloud Trace.\n  with_ui: Whether to deploy with UI.\n  log_level: The logging level.\n  adk_version: The ADK version to use in GKE.\n  allow_origins: The list of allowed origins for the ADK api server.\n  session_service_uri: The URI of the session service.\n  artifact_service_uri: The URI of the artifact service.\n  memory_service_uri: The URI of the memory service."
            }
          }
        },
        "cli_eval": {
          "__members__": {
            "_collect_eval_results": {
              "type": "function",
              "signature": "(inference_results: 'list[InferenceResult]', eval_service: 'BaseEvalService', eval_metrics: 'list[EvalMetric]') -> 'list[EvalCaseResult]'",
              "doc": "Simple utility methods to collect eval results from an eval service.\n\nThe method is intentionally kept private to prevent general usage."
            },
            "_collect_inferences": {
              "type": "function",
              "signature": "(inference_requests: 'list[InferenceRequest]', eval_service: 'BaseEvalService') -> 'list[InferenceResult]'",
              "doc": "Simple utility methods to collect inferences from an eval service.\n\nThe method is intentionally kept private to prevent general usage."
            },
            "_get_agent_module": {
              "type": "function",
              "signature": "(agent_module_file_path: 'str')",
              "doc": ""
            },
            "_get_evaluator": {
              "type": "function",
              "signature": "(eval_metric: 'EvalMetric') -> 'Evaluator'",
              "doc": ""
            },
            "_import_from_path": {
              "type": "function",
              "signature": "(module_name, file_path)",
              "doc": ""
            },
            "get_evaluation_criteria_or_default": {
              "type": "function",
              "signature": "(eval_config_file_path: 'str') -> 'dict[str, float]'",
              "doc": "Returns evaluation criteria from the config file, if present.\n\nOtherwise a default one is returned."
            },
            "get_root_agent": {
              "type": "function",
              "signature": "(agent_module_file_path: 'str') -> 'Agent'",
              "doc": "Returns root agent given the agent module."
            },
            "parse_and_get_evals_to_run": {
              "type": "function",
              "signature": "(evals_to_run_info: 'list[str]') -> 'dict[str, list[str]]'",
              "doc": "Returns a dictionary of eval set info to evals that should be run.\n\nArgs:\n  evals_to_run_info: While the structure is quite simple, a list of string,\n    each string actually is formatted with the following convention:\n    <eval_set_file_path | eval_set_id>:[comma separated eval case ids]"
            },
            "run_evals": {
              "type": "function",
              "signature": "(eval_cases_by_eval_set_id: 'dict[str, list[EvalCase]]', root_agent: 'Agent', reset_func: 'Optional[Any]', eval_metrics: 'list[EvalMetric]', session_service: 'Optional[BaseSessionService]' = None, artifact_service: 'Optional[BaseArtifactService]' = None) -> 'AsyncGenerator[EvalCaseResult, None]'",
              "doc": "Returns a stream of EvalCaseResult for each eval case that was evaluated.\n\nArgs:\n  eval_cases_by_eval_set_id: Eval cases categorized by eval set id to which\n    they belong.\n  root_agent: Agent to use for inferencing.\n  reset_func: If present, this will be called before invoking the agent before\n    every inferencing step.\n  eval_metrics: A list of metrics that should be used during evaluation.\n  session_service: The session service to use during inferencing.\n  artifact_service: The artifact service to use during inferencing."
            },
            "try_get_reset_func": {
              "type": "function",
              "signature": "(agent_module_file_path: 'str') -> 'Any'",
              "doc": "Returns reset function for the agent, if present, given the agent module."
            }
          }
        },
        "cli_tools_click": {
          "__members__": {
            "HelpfulCommand": {
              "type": "class",
              "signature": "(*args, **kwargs)",
              "doc": "Command that shows full help on error instead of just the error message.\n\nA custom Click Command class that overrides the default error handling\nbehavior to display the full help text when a required argument is missing,\nfollowed by the error message. This provides users with better context\nabout command usage without needing to run a separate --help command.\n\nArgs:\n  *args: Variable length argument list to pass to the parent class.\n  **kwargs: Arbitrary keyword arguments to pass to the parent class.\n\nReturns:\n  None. Inherits behavior from the parent Click Command class.\n\nReturns:"
            },
            "adk_services_options": {
              "type": "function",
              "signature": "()",
              "doc": "Decorator to add ADK services options to click commands."
            },
            "deprecated_adk_services_options": {
              "type": "function",
              "signature": "()",
              "doc": "Depracated ADK services options."
            },
            "fast_api_common_options": {
              "type": "function",
              "signature": "()",
              "doc": "Decorator to add common fast api options to click commands."
            },
            "validate_exclusive": {
              "type": "function",
              "signature": "(ctx, param, value)",
              "doc": ""
            }
          }
        },
        "fast_api": {
          "__members__": {
            "get_fast_api_app": {
              "type": "function",
              "signature": "(*, agents_dir: 'str', session_service_uri: 'Optional[str]' = None, session_db_kwargs: 'Optional[Mapping[str, Any]]' = None, artifact_service_uri: 'Optional[str]' = None, memory_service_uri: 'Optional[str]' = None, eval_storage_uri: 'Optional[str]' = None, allow_origins: 'Optional[list[str]]' = None, web: 'bool', a2a: 'bool' = False, host: 'str' = '127.0.0.1', port: 'int' = 8000, trace_to_cloud: 'bool' = False, reload_agents: 'bool' = False, lifespan: 'Optional[Lifespan[FastAPI]]' = None) -> 'FastAPI'",
              "doc": ""
            }
          }
        },
        "utils": {
          "agent_change_handler": {
            "__members__": {
              "AgentChangeEventHandler": {
                "type": "class",
                "signature": "(agent_loader: 'AgentLoader', runners_to_clean: 'set[str]', current_app_name_ref: 'SharedValue[str]')",
                "doc": "Base file system event handler that you can override methods from."
              }
            }
          },
          "agent_loader": {
            "__members__": {
              "AgentLoader": {
                "type": "class",
                "signature": "(agents_dir: 'str')",
                "doc": "Centralized agent loading with proper isolation, caching, and .env loading.\nSupport loading agents from below folder/file structures:\na)  {agent_name}.agent as a module name:\n    agents_dir/{agent_name}/agent.py (with root_agent defined in the module)\nb)  {agent_name} as a module name\n    agents_dir/{agent_name}.py (with root_agent defined in the module)\nc)  {agent_name} as a package name\n    agents_dir/{agent_name}/__init__.py (with root_agent in the package)\nd)  {agent_name} as a YAML config folder:\n    agents_dir/{agent_name}/root_agent.yaml defines the root agent"
              }
            }
          },
          "base_agent_loader": {
            "__members__": {
              "BaseAgentLoader": {
                "type": "class",
                "signature": "()",
                "doc": "Abstract base class for agent loaders."
              }
            }
          },
          "cleanup": {
            "__members__": {
              "close_runners": {
                "type": "function",
                "signature": "(runners: List[google.adk.runners.Runner]) -> None",
                "doc": ""
              }
            }
          },
          "common": {
            "__members__": {
              "BaseModel": {
                "type": "class",
                "signature": "() -> None",
                "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
              }
            }
          },
          "envs": {
            "__members__": {
              "_walk_to_root_until_found": {
                "type": "function",
                "signature": "(folder, filename) -> str",
                "doc": ""
              },
              "load_dotenv_for_agent": {
                "type": "function",
                "signature": "(agent_name: str, agent_parent_folder: str, filename: str = '.env')",
                "doc": "Loads the .env file for the agent module."
              }
            }
          },
          "evals": {
            "__members__": {
              "GcsEvalManagers": {
                "type": "class",
                "signature": "(*, evalSetsManager: google.adk.evaluation.gcs_eval_sets_manager.GcsEvalSetsManager, evalSetResultsManager: google.adk.evaluation.gcs_eval_set_results_manager.GcsEvalSetResultsManager) -> None",
                "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
              },
              "convert_session_to_eval_format": {
                "type": "function",
                "signature": "(session: 'Session') -> 'list[dict[str, Any]]'",
                "doc": "Converts a session data into eval format.\n\nArgs:\n    session: The session that should be converted.\n\nReturns:\n    list: A single evaluation dataset in the required format."
              },
              "convert_session_to_eval_invocations": {
                "type": "function",
                "signature": "(session: 'Session') -> 'list[Invocation]'",
                "doc": "Converts a session data into a list of Invocation.\n\nArgs:\n    session: The session that should be converted.\n\nReturns:\n    list: A list of invocation."
              },
              "create_gcs_eval_managers_from_uri": {
                "type": "function",
                "signature": "(eval_storage_uri: 'str') -> 'GcsEvalManagers'",
                "doc": "Creates GcsEvalManagers from eval_storage_uri.\n\nArgs:\n    eval_storage_uri: The evals storage URI to use. Supported URIs:\n      gs://<bucket name>. If a path is provided, the bucket will be extracted.\n\nReturns:\n    GcsEvalManagers: The GcsEvalManagers object.\n\nRaises:\n    ValueError: If the eval_storage_uri is not supported."
              }
            }
          },
          "logs": {
            "__members__": {
              "log_to_tmp_folder": {
                "type": "function",
                "signature": "(level=20, *, sub_folder: 'str' = 'agents_log', log_file_prefix: 'str' = 'agent', log_file_timestamp: 'str' = '20250815_134137')",
                "doc": "Logs to system temp folder, instead of logging to stderr.\n\nArgs\n  sub_folder: str = 'agents_log',\n  log_file_prefix: str = 'agent',\n  log_file_timestamp: str = time.strftime('%Y%m%d_%H%M%S'),\n\nReturns\n  the log file path."
              },
              "setup_adk_logger": {
                "type": "function",
                "signature": "(level=20)",
                "doc": ""
              }
            }
          },
          "shared_value": {
            "__members__": {
              "SharedValue": {
                "type": "class",
                "signature": "(*, value: ~T) -> None",
                "doc": "Simple wrapper around a value to allow modifying it from callbacks."
              }
            }
          },
          "state": {
            "__members__": {
              "_create_empty_state": {
                "type": "function",
                "signature": "(agent: 'BaseAgent', all_state: 'dict[str, Any]')",
                "doc": ""
              },
              "create_empty_state": {
                "type": "function",
                "signature": "(agent: 'BaseAgent', initialized_states: 'Optional[dict[str, Any]]' = None) -> 'dict[str, Any]'",
                "doc": "Creates empty str for non-initialized states."
              }
            }
          }
        }
      },
      "code_executors": {
        "base_code_executor": {
          "__members__": {
            "BaseCodeExecutor": {
              "type": "class",
              "signature": "(*, optimize_data_file: bool = False, stateful: bool = False, error_retry_attempts: int = 2, code_block_delimiters: List[tuple[str, str]] = [('```tool_code\\n', '\\n```'), ('```python\\n', '\\n```')], execution_result_delimiters: tuple[str, str] = ('```tool_output\\n', '\\n```')) -> None",
              "doc": "Abstract base class for all code executors.\n\nThe code executor allows the agent to execute code blocks from model responses\nand incorporate the execution results into the final response.\n\nAttributes:\n  optimize_data_file: If true, extract and process data files from the model\n    request and attach them to the code executor. Supported data file\n    MimeTypes are [text/csv]. Default to False.\n  stateful: Whether the code executor is stateful. Default to False.\n  error_retry_attempts: The number of attempts to retry on consecutive code\n    execution errors. Default to 2.\n  code_block_delimiters: The list of the enclosing delimiters to identify the\n    code blocks.\n  execution_result_delimiters: The delimiters to format the code execution\n    result."
            }
          }
        },
        "built_in_code_executor": {
          "__members__": {
            "BuiltInCodeExecutor": {
              "type": "class",
              "signature": "(*, optimize_data_file: bool = False, stateful: bool = False, error_retry_attempts: int = 2, code_block_delimiters: List[tuple[str, str]] = [('```tool_code\\n', '\\n```'), ('```python\\n', '\\n```')], execution_result_delimiters: tuple[str, str] = ('```tool_output\\n', '\\n```')) -> None",
              "doc": "A code executor that uses the Model's built-in code executor.\n\nCurrently only supports Gemini 2.0+ models, but will be expanded to\nother models."
            }
          }
        },
        "code_execution_utils": {
          "__members__": {
            "CodeExecutionInput": {
              "type": "class",
              "signature": "(code: str, input_files: list[google.adk.code_executors.code_execution_utils.File] = <factory>, execution_id: Optional[str] = None) -> None",
              "doc": "A structure that contains the input of code execution."
            },
            "CodeExecutionResult": {
              "type": "class",
              "signature": "(stdout: str = '', stderr: str = '', output_files: list[google.adk.code_executors.code_execution_utils.File] = <factory>) -> None",
              "doc": "A structure that contains the result of code execution."
            },
            "CodeExecutionUtils": {
              "type": "class",
              "signature": "()",
              "doc": "Utility functions for code execution."
            },
            "File": {
              "type": "class",
              "signature": "(name: str, content: str, mime_type: str = 'text/plain') -> None",
              "doc": "A structure that contains a file name and its content."
            }
          }
        },
        "code_executor_context": {
          "__members__": {
            "CodeExecutorContext": {
              "type": "class",
              "signature": "(session_state: google.adk.sessions.state.State)",
              "doc": "The persistent context used to configure the code executor."
            }
          }
        },
        "unsafe_local_code_executor": {
          "__members__": {
            "UnsafeLocalCodeExecutor": {
              "type": "class",
              "signature": "(*, optimize_data_file: bool = False, stateful: bool = False, error_retry_attempts: int = 2, code_block_delimiters: List[tuple[str, str]] = [('```tool_code\\n', '\\n```'), ('```python\\n', '\\n```')], execution_result_delimiters: tuple[str, str] = ('```tool_output\\n', '\\n```')) -> None",
              "doc": "A code executor that unsafely execute code in the current local context."
            },
            "_prepare_globals": {
              "type": "function",
              "signature": "(code: 'str', globals_: 'dict[str, Any]') -> 'None'",
              "doc": "Prepare globals for code execution, injecting __name__ if needed."
            }
          }
        },
        "vertex_ai_code_executor": {
          "__members__": {
            "VertexAiCodeExecutor": {
              "type": "class",
              "signature": "(resource_name: 'str' = None, *, optimize_data_file: bool = False, stateful: bool = False, error_retry_attempts: int = 2, code_block_delimiters: List[tuple[str, str]] = [('```tool_code\\n', '\\n```'), ('```python\\n', '\\n```')], execution_result_delimiters: tuple[str, str] = ('```tool_output\\n', '\\n```')) -> None",
              "doc": "A code executor that uses Vertex Code Interpreter Extension to execute code.\n\nAttributes:\n  resource_name: If set, load the existing resource name of the code\n    interpreter extension instead of creating a new one. Format:\n    projects/123/locations/us-central1/extensions/456"
            },
            "_get_code_interpreter_extension": {
              "type": "function",
              "signature": "(resource_name: 'str' = None)",
              "doc": "Returns: Load or create the code interpreter extension."
            }
          }
        }
      },
      "errors": {
        "not_found_error": {
          "__members__": {
            "NotFoundError": {
              "type": "class",
              "signature": "(message='The requested item was not found.')",
              "doc": "Represents an error that occurs when an entity is not found."
            }
          }
        }
      },
      "evaluation": {
        "_eval_set_results_manager_utils": {
          "__members__": {
            "_sanitize_eval_set_result_name": {
              "type": "function",
              "signature": "(eval_set_result_name: 'str') -> 'str'",
              "doc": "Sanitizes the eval set result name."
            },
            "create_eval_set_result": {
              "type": "function",
              "signature": "(app_name: 'str', eval_set_id: 'str', eval_case_results: 'list[EvalCaseResult]') -> 'EvalSetResult'",
              "doc": "Creates a new EvalSetResult given eval_case_results."
            }
          }
        },
        "_eval_sets_manager_utils": {
          "__members__": {
            "add_eval_case_to_eval_set": {
              "type": "function",
              "signature": "(eval_set: 'EvalSet', eval_case: 'EvalCase') -> 'EvalSet'",
              "doc": "Adds an eval case to an eval set and returns the updated eval set."
            },
            "delete_eval_case_from_eval_set": {
              "type": "function",
              "signature": "(eval_set: 'EvalSet', eval_case_id: 'str') -> 'EvalSet'",
              "doc": "Deletes an eval case from an eval set and returns the updated eval set."
            },
            "get_eval_case_from_eval_set": {
              "type": "function",
              "signature": "(eval_set: 'EvalSet', eval_case_id: 'str') -> 'Optional[EvalCase]'",
              "doc": "Returns an EvalCase if found, otherwise None."
            },
            "get_eval_set_from_app_and_id": {
              "type": "function",
              "signature": "(eval_sets_manager: 'EvalSetsManager', app_name: 'str', eval_set_id: 'str') -> 'EvalSet'",
              "doc": "Returns an EvalSet if found, otherwise raises NotFoundError."
            },
            "update_eval_case_in_eval_set": {
              "type": "function",
              "signature": "(eval_set: 'EvalSet', updated_eval_case: 'EvalCase') -> 'EvalSet'",
              "doc": "Updates an eval case in an eval set and returns the updated eval set."
            }
          }
        },
        "agent_evaluator": {
          "__members__": {
            "AgentEvaluator": {
              "type": "class",
              "signature": "()",
              "doc": "An evaluator for Agents, mainly intended for helping with test cases."
            },
            "_EvalMetricResultWithInvocation": {
              "type": "class",
              "signature": "(*, actual_invocation: google.adk.evaluation.eval_case.Invocation, expected_invocation: google.adk.evaluation.eval_case.Invocation, eval_metric_result: google.adk.evaluation.eval_metrics.EvalMetricResult) -> None",
              "doc": "EvalMetricResult along with both actual and expected invocation.\n\nThis is class is intentionally marked as private and is created for\nconvenience."
            },
            "load_json": {
              "type": "function",
              "signature": "(file_path: 'str') -> 'Union[Dict, List]'",
              "doc": ""
            }
          }
        },
        "base_eval_service": {
          "__members__": {
            "BaseEvalService": {
              "type": "class",
              "signature": "()",
              "doc": "A service to run Evals for an ADK agent."
            },
            "EvaluateConfig": {
              "type": "class",
              "signature": "(*, evalMetrics: list[google.adk.evaluation.eval_metrics.EvalMetric], parallelism: int = 4) -> None",
              "doc": "Contains configurations need to run an evaluations."
            },
            "EvaluateRequest": {
              "type": "class",
              "signature": "(*, inferenceResults: list[google.adk.evaluation.base_eval_service.InferenceResult], evaluateConfig: google.adk.evaluation.base_eval_service.EvaluateConfig) -> None",
              "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
            },
            "InferenceConfig": {
              "type": "class",
              "signature": "(*, labels: Optional[dict[str, str]] = None, parallelism: int = 4) -> None",
              "doc": "Contains configurations need to run inferences."
            },
            "InferenceRequest": {
              "type": "class",
              "signature": "(*, appName: str, evalSetId: str, evalCaseIds: Optional[list[str]] = None, inferenceConfig: google.adk.evaluation.base_eval_service.InferenceConfig) -> None",
              "doc": "Represent a request to perform inferences for the eval cases in an eval set."
            },
            "InferenceResult": {
              "type": "class",
              "signature": "(*, appName: str, evalSetId: str, evalCaseId: str, inferences: Optional[list[google.adk.evaluation.eval_case.Invocation]] = None, sessionId: Optional[str], status: google.adk.evaluation.base_eval_service.InferenceStatus = <InferenceStatus.UNKNOWN: 0>, errorMessage: Optional[str] = None) -> None",
              "doc": "Contains inference results for a single eval case."
            },
            "InferenceStatus": {
              "type": "class",
              "signature": "(*values)",
              "doc": "Status of the inference."
            }
          }
        },
        "eval_case": {
          "__members__": {
            "EvalBaseModel": {
              "type": "class",
              "signature": "() -> None",
              "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
            },
            "EvalCase": {
              "type": "class",
              "signature": "(*, evalId: str, conversation: list[google.adk.evaluation.eval_case.Invocation], sessionInput: Optional[google.adk.evaluation.eval_case.SessionInput] = None, creationTimestamp: float = 0.0) -> None",
              "doc": "An eval case."
            },
            "IntermediateData": {
              "type": "class",
              "signature": "(*, toolUses: list[google.genai.types.FunctionCall] = [], intermediateResponses: list[tuple[str, list[google.genai.types.Part]]] = []) -> None",
              "doc": "Container for intermediate data that an agent would generate as it responds with a final answer."
            },
            "Invocation": {
              "type": "class",
              "signature": "(*, invocationId: str = '', userContent: google.genai.types.Content, finalResponse: Optional[google.genai.types.Content] = None, intermediateData: Optional[google.adk.evaluation.eval_case.IntermediateData] = None, creationTimestamp: float = 0.0) -> None",
              "doc": "Represents a single invocation."
            },
            "SessionInput": {
              "type": "class",
              "signature": "(*, appName: str, userId: str, state: dict[str, typing.Any] = <factory>) -> None",
              "doc": "Values that help initialize a Session."
            }
          }
        },
        "eval_metrics": {
          "__members__": {
            "EvalMetric": {
              "type": "class",
              "signature": "(*, metricName: str, threshold: float, judgeModelOptions: Optional[google.adk.evaluation.eval_metrics.JudgeModelOptions] = None) -> None",
              "doc": "A metric used to evaluate a particular aspect of an eval case."
            },
            "EvalMetricResult": {
              "type": "class",
              "signature": "(*, metricName: str, threshold: float, judgeModelOptions: Optional[google.adk.evaluation.eval_metrics.JudgeModelOptions] = None, score: Optional[float] = None, evalStatus: google.adk.evaluation.evaluator.EvalStatus) -> None",
              "doc": "The actual computed score/value of a particular EvalMetric."
            },
            "EvalMetricResultPerInvocation": {
              "type": "class",
              "signature": "(*, actualInvocation: google.adk.evaluation.eval_case.Invocation, expectedInvocation: google.adk.evaluation.eval_case.Invocation, evalMetricResults: list[google.adk.evaluation.eval_metrics.EvalMetricResult] = []) -> None",
              "doc": "Eval metric results per invocation."
            },
            "Interval": {
              "type": "class",
              "signature": "(*, min_value: float, open_at_min: bool = False, max_value: float, open_at_max: bool = False) -> None",
              "doc": "Represents a range of numeric values, e.g. [0 ,1] or (2,3) or [-1, 6)."
            },
            "JudgeModelOptions": {
              "type": "class",
              "signature": "(*, judge_model: str = 'gemini-2.5-flash', judge_model_config: Optional[google.genai.types.GenerateContentConfig] = None, num_samples: Optional[int] = None) -> None",
              "doc": "Options for an eval metric's judge model."
            },
            "MetricInfo": {
              "type": "class",
              "signature": "(*, metricName: str, description: str = None, metricValueInfo: google.adk.evaluation.eval_metrics.MetricValueInfo) -> None",
              "doc": "Information about the metric that are used for Evals."
            },
            "MetricValueInfo": {
              "type": "class",
              "signature": "(*, interval: Optional[google.adk.evaluation.eval_metrics.Interval] = None) -> None",
              "doc": "Information about the type of metric value."
            },
            "PrebuiltMetrics": {
              "type": "class",
              "signature": "(*values)",
              "doc": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
            }
          }
        },
        "eval_result": {
          "__members__": {
            "EvalCaseResult": {
              "type": "class",
              "signature": "(*, evalSetFile: Optional[str] = None, evalSetId: str = '', evalId: str = '', finalEvalStatus: google.adk.evaluation.evaluator.EvalStatus, evalMetricResults: Optional[list[tuple[google.adk.evaluation.eval_metrics.EvalMetric, google.adk.evaluation.eval_metrics.EvalMetricResult]]] = None, overallEvalMetricResults: list[google.adk.evaluation.eval_metrics.EvalMetricResult], evalMetricResultPerInvocation: list[google.adk.evaluation.eval_metrics.EvalMetricResultPerInvocation], sessionId: str, sessionDetails: Optional[google.adk.sessions.session.Session] = None, userId: Optional[str] = None) -> None",
              "doc": "Case level evaluation results."
            },
            "EvalSetResult": {
              "type": "class",
              "signature": "(*, evalSetResultId: str, evalSetResultName: Optional[str] = None, evalSetId: str, evalCaseResults: list[google.adk.evaluation.eval_result.EvalCaseResult] = <factory>, creationTimestamp: float = 0.0) -> None",
              "doc": "Eval set level evaluation results."
            }
          }
        },
        "eval_set": {
          "__members__": {
            "EvalSet": {
              "type": "class",
              "signature": "(*, eval_set_id: str, name: Optional[str] = None, description: Optional[str] = None, eval_cases: list[google.adk.evaluation.eval_case.EvalCase], creation_timestamp: float = 0.0) -> None",
              "doc": "A set of eval cases."
            }
          }
        },
        "eval_set_results_manager": {
          "__members__": {
            "EvalSetResultsManager": {
              "type": "class",
              "signature": "()",
              "doc": "An interface to manage Eval Set Results."
            }
          }
        },
        "eval_sets_manager": {
          "__members__": {
            "EvalSetsManager": {
              "type": "class",
              "signature": "()",
              "doc": "An interface to manage an Eval Sets."
            }
          }
        },
        "evaluation_constants": {
          "__members__": {
            "EvalConstants": {
              "type": "class",
              "signature": "()",
              "doc": "Holds constants for evaluation file constants."
            }
          }
        },
        "evaluation_generator": {
          "__members__": {
            "EvalCaseResponses": {
              "type": "class",
              "signature": "(*, eval_case: google.adk.evaluation.eval_case.EvalCase, responses: list[list[google.adk.evaluation.eval_case.Invocation]]) -> None",
              "doc": "Contains multiple responses associated with an EvalCase.\n\nMultiple responses are a result of repeated requests to genereate inferences."
            },
            "EvaluationGenerator": {
              "type": "class",
              "signature": "()",
              "doc": "Generates evaluation responses for agents."
            }
          }
        },
        "evaluator": {
          "__members__": {
            "EvalStatus": {
              "type": "class",
              "signature": "(*values)",
              "doc": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
            },
            "EvaluationResult": {
              "type": "class",
              "signature": "(*, overall_score: Optional[float] = None, overall_eval_status: google.adk.evaluation.evaluator.EvalStatus = <EvalStatus.NOT_EVALUATED: 3>, per_invocation_results: list[google.adk.evaluation.evaluator.PerInvocationResult] = []) -> None",
              "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
            },
            "Evaluator": {
              "type": "class",
              "signature": "()",
              "doc": "A merics evaluator interface."
            },
            "PerInvocationResult": {
              "type": "class",
              "signature": "(*, actual_invocation: google.adk.evaluation.eval_case.Invocation, expected_invocation: google.adk.evaluation.eval_case.Invocation, score: Optional[float] = None, eval_status: google.adk.evaluation.evaluator.EvalStatus = <EvalStatus.NOT_EVALUATED: 3>) -> None",
              "doc": "Metric evaluation score per invocation."
            }
          }
        },
        "final_response_match_v2": {
          "__members__": {
            "FinalResponseMatchV2Evaluator": {
              "type": "class",
              "signature": "(eval_metric: 'EvalMetric')",
              "doc": "V2 final response match evaluator which uses an LLM to judge responses.\n\nThe evaluator prompts the LLM to output whether the agent final response is\nvalid or invalid, hence outputs a score of 0 or 1. Repeated invocation samples\nare aggregated by taking majority vote, and then the overall score is the\nfraction, ranging from 0 to 1, of valid samples. Higher values of overall\nscore indicate better final response performance of the agent."
            },
            "_parse_critique": {
              "type": "function",
              "signature": "(response: 'str') -> 'Label'",
              "doc": "Parses the judge model critique and extracts the final label.\n\nArgs:\n  response: model response\n\nReturns:\n  The extracted label, either VALID, INVALID, or NOT_FOUND."
            }
          }
        },
        "gcs_eval_set_results_manager": {
          "__members__": {
            "GcsEvalSetResultsManager": {
              "type": "class",
              "signature": "(bucket_name: 'str', **kwargs)",
              "doc": "An EvalSetResultsManager that stores eval results in a GCS bucket."
            }
          }
        },
        "gcs_eval_sets_manager": {
          "__members__": {
            "GcsEvalSetsManager": {
              "type": "class",
              "signature": "(bucket_name: 'str', **kwargs)",
              "doc": "An EvalSetsManager that stores eval sets in a GCS bucket."
            }
          }
        },
        "in_memory_eval_sets_manager": {
          "__members__": {
            "InMemoryEvalSetsManager": {
              "type": "class",
              "signature": "()",
              "doc": "An in-memory implementation of EvalSetsManager using dictionaries.\n\nYou can use this class:\n1) As a part of your testcase.\n2) For cases where other implementations of EvalSetsManager are too expensive\nto use."
            }
          }
        },
        "llm_as_judge": {
          "__members__": {
            "LlmAsJudge": {
              "type": "class",
              "signature": "(eval_metric: 'EvalMetric')",
              "doc": "Evaluator based on a LLM.\n\nIt is meant to be extended by specific auto-raters for different evaluation\ntasks:\n  - Provide the prompt template, and implement format_auto_rater_prompt to\n    format the auto-rater prompt for a given invocation.\n  - Implement convert_auto_rater_response_to_score to parse the auto-rater\n    response and return the corresponding score.\n  - Implement aggregate_invocation_results to aggregate the per-invocation\n    results to get the overall score.\n  - (Optional) Override aggregate_per_invocation_result_samples to aggregate\n    multiple auto-rater samples of the same invocation."
            }
          }
        },
        "llm_as_judge_utils": {
          "__members__": {
            "Label": {
              "type": "class",
              "signature": "(*values)",
              "doc": "Labels for auto rater response."
            },
            "get_eval_status": {
              "type": "function",
              "signature": "(score: 'Optional[float]', threshold: 'float') -> 'EvalStatus'",
              "doc": ""
            },
            "get_text_from_content": {
              "type": "function",
              "signature": "(content: 'Optional[genai_types.Content]') -> 'Optional[str]'",
              "doc": ""
            }
          }
        },
        "local_eval_set_results_manager": {
          "__members__": {
            "LocalEvalSetResultsManager": {
              "type": "class",
              "signature": "(agents_dir: 'str')",
              "doc": "An EvalSetResult manager that stores eval set results locally on disk."
            }
          }
        },
        "local_eval_sets_manager": {
          "__members__": {
            "LocalEvalSetsManager": {
              "type": "class",
              "signature": "(agents_dir: 'str')",
              "doc": "An EvalSets manager that stores eval sets locally on disk."
            },
            "_convert_invocation_to_pydantic_schema": {
              "type": "function",
              "signature": "(invocation_in_json_format: 'dict[str, Any]') -> 'Invocation'",
              "doc": "Converts an invocation from old json format to new Pydantic Schema."
            },
            "convert_eval_set_to_pydanctic_schema": {
              "type": "function",
              "signature": "(eval_set_id: 'str', eval_set_in_json_format: 'list[dict[str, Any]]') -> 'EvalSet'",
              "doc": "Returns an pydantic EvalSet generated from the json representation.\n\n  Args:\n    eval_set_id: Eval set id.\n    eval_set_in_json_format: Eval set specified in JSON format.\n\n  Here is a sample eval set in JSON format:\n[\n  {\n    \"name\": \"roll_17_sided_dice_twice\",\n    \"data\": [\n      {\n        \"query\": \"What can you do?\",\n        \"expected_tool_use\": [],\n        \"expected_intermediate_agent_responses\": [],\n        \"reference\": \"I can roll dice of different sizes and check if a number\n          is prime. I can also use multiple tools in parallel.\\n\"\n      },\n      {\n        \"query\": \"Roll a 17 sided dice twice for me\",\n        \"expected_tool_use\": [\n          {\n            \"tool_name\": \"roll_die\",\n            \"tool_input\": {\n              \"sides\": 17\n            }\n          },\n          {\n            \"tool_name\": \"roll_die\",\n            \"tool_input\": {\n              \"sides\": 17\n            }\n          }\n        ],\n        \"expected_intermediate_agent_responses\": [],\n        \"reference\": \"I have rolled a 17 sided die twice. The first roll was\n          13 and the second roll was 4.\\n\"\n      }\n    ],\n    \"initial_session\": {\n      \"state\": {},\n      \"app_name\": \"hello_world\",\n      \"user_id\": \"user\"\n    }\n  }\n]"
            },
            "load_eval_set_from_file": {
              "type": "function",
              "signature": "(eval_set_file_path: 'str', eval_set_id: 'str') -> 'EvalSet'",
              "doc": "Returns an EvalSet that is read from the given file."
            }
          }
        },
        "safety_evaluator": {
          "__members__": {
            "SafetyEvaluatorV1": {
              "type": "class",
              "signature": "(eval_metric: 'EvalMetric')",
              "doc": "Evaluates safety (harmlessness) of an Agent's Response.\n\nThe class delegates the responsibility to Vertex Gen AI Eval SDK. The V1\nsuffix in the class name is added to convey that there could be other versions\nof the safety metric as well, and those metrics could use a different strategy\nto evaluate safety.\n\nUsing this class requires a GCP project. Please set GOOGLE_CLOUD_PROJECT and\nGOOGLE_CLOUD_LOCATION in your .env file.\n\nValue range of the metric is [0, 1], with values closer to 1 to be more\ndesirable (safe)."
            }
          }
        },
        "vertex_ai_eval_facade": {
          "__members__": {
            "_VertexAiEvalFacade": {
              "type": "class",
              "signature": "(threshold: 'float', metric_name: 'vertexai_types.PrebuiltMetric')",
              "doc": "Simple facade for Vertex Gen AI Eval SDK.\n\nVertex Gen AI Eval SDK exposes quite a few metrics that are valuable for\nagentic evals. This class helps us to access those metrics.\n\nUsing this class requires a GCP project. Please set GOOGLE_CLOUD_PROJECT and\nGOOGLE_CLOUD_LOCATION in your .env file."
            }
          }
        }
      },
      "events": {
        "event": {
          "__members__": {
            "Event": {
              "type": "class",
              "signature": "(*, content: Optional[google.genai.types.Content] = None, groundingMetadata: Optional[google.genai.types.GroundingMetadata] = None, partial: Optional[bool] = None, turnComplete: Optional[bool] = None, errorCode: Optional[str] = None, errorMessage: Optional[str] = None, interrupted: Optional[bool] = None, customMetadata: Optional[dict[str, Any]] = None, usageMetadata: Optional[google.genai.types.GenerateContentResponseUsageMetadata] = None, liveSessionResumptionUpdate: Optional[google.genai.types.LiveServerSessionResumptionUpdate] = None, invocationId: str = '', author: str, actions: google.adk.events.event_actions.EventActions = <factory>, longRunningToolIds: Optional[set[str]] = None, branch: Optional[str] = None, id: str = '', timestamp: float = <factory>) -> None",
              "doc": "Represents an event in a conversation between agents and users.\n\nIt is used to store the content of the conversation, as well as the actions\ntaken by the agents like function calls, etc.\n\nAttributes:\n  invocation_id: Required. The invocation ID of the event. Should be non-empty\n    before appending to a session.\n  author: Required. \"user\" or the name of the agent, indicating who appended\n    the event to the session.\n  actions: The actions taken by the agent.\n  long_running_tool_ids: The ids of the long running function calls.\n  branch: The branch of the event.\n  id: The unique identifier of the event.\n  timestamp: The timestamp of the event.\n  get_function_calls: Returns the function calls in the event."
            }
          }
        },
        "event_actions": {
          "__members__": {
            "EventActions": {
              "type": "class",
              "signature": "(*, skipSummarization: Optional[bool] = None, stateDelta: dict[str, object] = <factory>, artifactDelta: dict[str, int] = <factory>, transferToAgent: Optional[str] = None, escalate: Optional[bool] = None, requestedAuthConfigs: dict[str, google.adk.auth.auth_tool.AuthConfig] = <factory>) -> None",
              "doc": "Represents the actions attached to an event."
            }
          }
        }
      },
      "examples": {
        "base_example_provider": {
          "__members__": {
            "BaseExampleProvider": {
              "type": "class",
              "signature": "()",
              "doc": "Base class for example providers.\n\nThis class defines the interface for providing examples for a given query."
            }
          }
        },
        "example": {
          "__members__": {
            "Example": {
              "type": "class",
              "signature": "(*, input: google.genai.types.Content, output: list[google.genai.types.Content]) -> None",
              "doc": "A few-shot example.\n\nAttributes:\n  input: The input content for the example.\n  output: The expected output content for the example."
            }
          }
        },
        "example_util": {
          "__members__": {
            "_get_latest_message_from_user": {
              "type": "function",
              "signature": "(session: 'Session') -> str",
              "doc": "Gets the latest message from the user.\n\nReturns:\n  The latest message from the user. If not found, returns an empty string."
            },
            "build_example_si": {
              "type": "function",
              "signature": "(examples: Union[list[google.adk.examples.example.Example], google.adk.examples.base_example_provider.BaseExampleProvider], query: str, model: Optional[str]) -> str",
              "doc": ""
            },
            "convert_examples_to_text": {
              "type": "function",
              "signature": "(examples: list[google.adk.examples.example.Example], model: Optional[str]) -> str",
              "doc": "Converts a list of examples to a string that can be used in a system instruction."
            }
          }
        },
        "vertex_ai_example_store": {
          "__members__": {
            "VertexAiExampleStore": {
              "type": "class",
              "signature": "(examples_store_name: str)",
              "doc": "Provides examples from Vertex example store."
            }
          }
        }
      },
      "flows": {
        "llm_flows": {
          "_base_llm_processor": {
            "__members__": {
              "BaseLlmRequestProcessor": {
                "type": "class",
                "signature": "()",
                "doc": "Base class for LLM request processor."
              },
              "BaseLlmResponseProcessor": {
                "type": "class",
                "signature": "()",
                "doc": "Base class for LLM response processor."
              }
            }
          },
          "_code_execution": {
            "__members__": {
              "DataFileUtil": {
                "type": "class",
                "signature": "(extension: 'str', loader_code_template: 'str') -> None",
                "doc": "A structure that contains a data file name and its content."
              },
              "_CodeExecutionRequestProcessor": {
                "type": "class",
                "signature": "()",
                "doc": "Processes code execution requests."
              },
              "_CodeExecutionResponseProcessor": {
                "type": "class",
                "signature": "()",
                "doc": "Processes code execution responses."
              },
              "_extrac_and_replace_inline_files": {
                "type": "function",
                "signature": "(code_executor_context: 'CodeExecutorContext', llm_request: 'LlmRequest') -> 'list[File]'",
                "doc": "Extracts and replaces inline files with file names in the LLM request."
              },
              "_get_data_file_preprocessing_code": {
                "type": "function",
                "signature": "(file: 'File') -> 'Optional[str]'",
                "doc": "Returns the code to explore the data file."
              },
              "_get_or_set_execution_id": {
                "type": "function",
                "signature": "(invocation_context: 'InvocationContext', code_executor_context: 'CodeExecutorContext') -> 'Optional[str]'",
                "doc": "Returns the ID for stateful code execution or None if not stateful."
              },
              "_post_process_code_execution_result": {
                "type": "function",
                "signature": "(invocation_context: 'InvocationContext', code_executor_context: 'CodeExecutorContext', code_execution_result: 'CodeExecutionResult') -> 'Event'",
                "doc": "Post-process the code execution result and emit an Event."
              },
              "_run_post_processor": {
                "type": "function",
                "signature": "(invocation_context: 'InvocationContext', llm_response) -> 'AsyncGenerator[Event, None]'",
                "doc": "Post-process the model response by extracting and executing the first code block."
              },
              "_run_pre_processor": {
                "type": "function",
                "signature": "(invocation_context: 'InvocationContext', llm_request: 'LlmRequest') -> 'AsyncGenerator[Event, None]'",
                "doc": "Pre-process the user message by adding the user message to the Colab notebook."
              }
            }
          },
          "_nl_planning": {
            "__members__": {
              "_NlPlanningRequestProcessor": {
                "type": "class",
                "signature": "()",
                "doc": "Processor for NL planning."
              },
              "_NlPlanningResponse": {
                "type": "class",
                "signature": "()",
                "doc": "Base class for LLM response processor."
              },
              "_get_planner": {
                "type": "function",
                "signature": "(invocation_context: 'InvocationContext') -> 'Optional[BasePlanner]'",
                "doc": ""
              },
              "_remove_thought_from_request": {
                "type": "function",
                "signature": "(llm_request: 'LlmRequest')",
                "doc": ""
              }
            }
          },
          "agent_transfer": {
            "__members__": {
              "_AgentTransferLlmRequestProcessor": {
                "type": "class",
                "signature": "()",
                "doc": "Agent transfer request processor."
              },
              "_build_target_agents_info": {
                "type": "function",
                "signature": "(target_agent: 'BaseAgent') -> 'str'",
                "doc": ""
              },
              "_build_target_agents_instructions": {
                "type": "function",
                "signature": "(agent: 'LlmAgent', target_agents: 'list[BaseAgent]') -> 'str'",
                "doc": ""
              },
              "_get_transfer_targets": {
                "type": "function",
                "signature": "(agent: 'LlmAgent') -> 'list[BaseAgent]'",
                "doc": ""
              }
            }
          },
          "audio_transcriber": {
            "__members__": {
              "AudioTranscriber": {
                "type": "class",
                "signature": "(init_client=False)",
                "doc": "Transcribes audio using Google Cloud Speech-to-Text."
              }
            }
          },
          "auto_flow": {
            "__members__": {
              "AutoFlow": {
                "type": "class",
                "signature": "()",
                "doc": "AutoFlow is SingleFlow with agent transfer capability.\n\nAgent transfer is allowed in the following direction:\n\n1. from parent to sub-agent;\n2. from sub-agent to parent;\n3. from sub-agent to its peer agents;\n\nFor peer-agent transfers, it's only enabled when all below conditions are met:\n\n- The parent agent is also an LlmAgent.\n- `disallow_transfer_to_peer` option of this agent is False (default).\n\nDepending on the target agent type, the transfer may be automatically\nreversed. (see Runner._find_agent_to_run method for which agent will remain\nactive to handle next user message.)"
              }
            }
          },
          "base_llm_flow": {
            "__members__": {
              "BaseLlmFlow": {
                "type": "class",
                "signature": "()",
                "doc": "A basic flow that calls the LLM in a loop until a final response is generated.\n\nThis flow ends when it transfer to another agent."
              }
            }
          },
          "basic": {
            "__members__": {
              "_BasicLlmRequestProcessor": {
                "type": "class",
                "signature": "()",
                "doc": "Base class for LLM request processor."
              }
            }
          },
          "contents": {
            "__members__": {
              "_ContentLlmRequestProcessor": {
                "type": "class",
                "signature": "()",
                "doc": "Builds the contents for the LLM request."
              },
              "_convert_foreign_event": {
                "type": "function",
                "signature": "(event: 'Event') -> 'Event'",
                "doc": "Converts an event authored by another agent as a user-content event.\n\nThis is to provide another agent's output as context to the current agent, so\nthat current agent can continue to respond, such as summarizing previous\nagent's reply, etc.\n\nArgs:\n  event: The event to convert.\n\nReturns:\n  The converted event."
              },
              "_get_contents": {
                "type": "function",
                "signature": "(current_branch: 'Optional[str]', events: 'list[Event]', agent_name: 'str' = '') -> 'list[types.Content]'",
                "doc": "Get the contents for the LLM request.\n\nApplies filtering, rearrangement, and content processing to events.\n\nArgs:\n  current_branch: The current branch of the agent.\n  events: Events to process.\n  agent_name: The name of the agent.\n\nReturns:\n  A list of processed contents."
              },
              "_get_current_turn_contents": {
                "type": "function",
                "signature": "(current_branch: 'Optional[str]', events: 'list[Event]', agent_name: 'str' = '') -> 'list[types.Content]'",
                "doc": "Get contents for the current turn only (no conversation history).\n\nWhen include_contents='none', we want to include:\n- The current user input\n- Tool calls and responses from the current turn\nBut exclude conversation history from previous turns.\n\nIn multi-agent scenarios, the \"current turn\" for an agent starts from an\nactual user or from another agent.\n\nArgs:\n  current_branch: The current branch of the agent.\n  events: A list of all session events.\n  agent_name: The name of the agent.\n\nReturns:\n  A list of contents for the current turn only, preserving context needed\n  for proper tool execution while excluding conversation history."
              },
              "_is_auth_event": {
                "type": "function",
                "signature": "(event: 'Event') -> 'bool'",
                "doc": ""
              },
              "_is_event_belongs_to_branch": {
                "type": "function",
                "signature": "(invocation_branch: 'Optional[str]', event: 'Event') -> 'bool'",
                "doc": "Event belongs to a branch, when event.branch is prefix of the invocation branch."
              },
              "_is_other_agent_reply": {
                "type": "function",
                "signature": "(current_agent_name: 'str', event: 'Event') -> 'bool'",
                "doc": "Whether the event is a reply from another agent."
              },
              "_merge_function_response_events": {
                "type": "function",
                "signature": "(function_response_events: 'list[Event]') -> 'Event'",
                "doc": "Merges a list of function_response events into one event.\n\nThe key goal is to ensure:\n1. function_call and function_response are always of the same number.\n2. The function_call and function_response are consecutively in the content.\n\nArgs:\n  function_response_events: A list of function_response events.\n    NOTE: function_response_events must fulfill these requirements: 1. The\n      list is in increasing order of timestamp; 2. the first event is the\n      initial function_response event; 3. all later events should contain at\n      least one function_response part that related to the function_call\n      event.\n    Caveat: This implementation doesn't support when a parallel function_call\n      event contains async function_call of the same name.\n\nReturns:\n  A merged event, that is\n    1. All later function_response will replace function_response part in\n        the initial function_response event.\n    2. All non-function_response parts will be appended to the part list of\n        the initial function_response event."
              },
              "_rearrange_events_for_async_function_responses_in_history": {
                "type": "function",
                "signature": "(events: 'list[Event]') -> 'list[Event]'",
                "doc": "Rearrange the async function_response events in the history."
              },
              "_rearrange_events_for_latest_function_response": {
                "type": "function",
                "signature": "(events: 'list[Event]') -> 'list[Event]'",
                "doc": "Rearrange the events for the latest function_response.\n\nIf the latest function_response is for an async function_call, all events\nbetween the initial function_call and the latest function_response will be\nremoved.\n\nArgs:\n  events: A list of events.\n\nReturns:\n  A list of events with the latest function_response rearranged."
              }
            }
          },
          "functions": {
            "__members__": {
              "__build_response_event": {
                "type": "function",
                "signature": "(tool: 'BaseTool', function_result: 'dict[str, object]', tool_context: 'ToolContext', invocation_context: 'InvocationContext') -> 'Event'",
                "doc": ""
              },
              "__call_tool_async": {
                "type": "function",
                "signature": "(tool: 'BaseTool', args: 'dict[str, Any]', tool_context: 'ToolContext') -> 'Any'",
                "doc": "Calls the tool."
              },
              "__call_tool_live": {
                "type": "function",
                "signature": "(tool: 'BaseTool', args: 'dict[str, object]', tool_context: 'ToolContext', invocation_context: 'InvocationContext') -> 'AsyncGenerator[Event, None]'",
                "doc": "Calls the tool asynchronously (awaiting the coroutine)."
              },
              "_execute_single_function_call_async": {
                "type": "function",
                "signature": "(invocation_context: 'InvocationContext', function_call: 'types.FunctionCall', tools_dict: 'dict[str, BaseTool]', agent: 'LlmAgent') -> 'Optional[Event]'",
                "doc": "Execute a single function call with thread safety for state modifications."
              },
              "_execute_single_function_call_live": {
                "type": "function",
                "signature": "(invocation_context: 'InvocationContext', function_call: 'types.FunctionCall', tools_dict: 'dict[str, BaseTool]', agent: 'LlmAgent', streaming_lock: 'asyncio.Lock') -> 'Optional[Event]'",
                "doc": "Execute a single function call for live mode with thread safety."
              },
              "_get_tool_and_context": {
                "type": "function",
                "signature": "(invocation_context: 'InvocationContext', function_call: 'types.FunctionCall', tools_dict: 'dict[str, BaseTool]')",
                "doc": ""
              },
              "_process_function_live_helper": {
                "type": "function",
                "signature": "(tool, tool_context, function_call, function_args, invocation_context, streaming_lock: 'asyncio.Lock')",
                "doc": ""
              },
              "deep_merge_dicts": {
                "type": "function",
                "signature": "(d1: 'dict', d2: 'dict') -> 'dict'",
                "doc": "Recursively merges d2 into d1."
              },
              "find_matching_function_call": {
                "type": "function",
                "signature": "(events: 'list[Event]') -> 'Optional[Event]'",
                "doc": "Finds the function call event that matches the function response id of the last event."
              },
              "generate_auth_event": {
                "type": "function",
                "signature": "(invocation_context: 'InvocationContext', function_response_event: 'Event') -> 'Optional[Event]'",
                "doc": ""
              },
              "generate_client_function_call_id": {
                "type": "function",
                "signature": "() -> 'str'",
                "doc": ""
              },
              "get_long_running_function_calls": {
                "type": "function",
                "signature": "(function_calls: 'list[types.FunctionCall]', tools_dict: 'dict[str, BaseTool]') -> 'set[str]'",
                "doc": ""
              },
              "handle_function_calls_async": {
                "type": "function",
                "signature": "(invocation_context: 'InvocationContext', function_call_event: 'Event', tools_dict: 'dict[str, BaseTool]', filters: 'Optional[set[str]]' = None) -> 'Optional[Event]'",
                "doc": "Calls the functions and returns the function response event."
              },
              "handle_function_calls_live": {
                "type": "function",
                "signature": "(invocation_context: 'InvocationContext', function_call_event: 'Event', tools_dict: 'dict[str, BaseTool]') -> 'Event'",
                "doc": "Calls the functions and returns the function response event."
              },
              "merge_parallel_function_response_events": {
                "type": "function",
                "signature": "(function_response_events: \"list['Event']\") -> \"'Event'\"",
                "doc": ""
              },
              "populate_client_function_call_id": {
                "type": "function",
                "signature": "(model_response_event: 'Event') -> 'None'",
                "doc": ""
              },
              "remove_client_function_call_id": {
                "type": "function",
                "signature": "(content: 'types.Content') -> 'None'",
                "doc": ""
              }
            }
          },
          "identity": {
            "__members__": {
              "_IdentityLlmRequestProcessor": {
                "type": "class",
                "signature": "()",
                "doc": "Gives the agent identity from the framework."
              }
            }
          },
          "instructions": {
            "__members__": {
              "_InstructionsLlmRequestProcessor": {
                "type": "class",
                "signature": "()",
                "doc": "Handles instructions and global instructions for LLM flow."
              }
            }
          },
          "single_flow": {
            "__members__": {
              "SingleFlow": {
                "type": "class",
                "signature": "()",
                "doc": "SingleFlow is the LLM flows that handles tools calls.\n\nA single flow only consider an agent itself and tools.\nNo sub-agents are allowed for single flow."
              }
            }
          }
        }
      },
      "memory": {
        "_utils": {
          "__members__": {
            "format_timestamp": {
              "type": "function",
              "signature": "(timestamp: 'float') -> 'str'",
              "doc": "Formats the timestamp of the memory entry."
            }
          }
        },
        "base_memory_service": {
          "__members__": {
            "BaseMemoryService": {
              "type": "class",
              "signature": "()",
              "doc": "Base class for memory services.\n\nThe service provides functionalities to ingest sessions into memory so that\nthe memory can be used for user queries."
            },
            "SearchMemoryResponse": {
              "type": "class",
              "signature": "(*, memories: list[google.adk.memory.memory_entry.MemoryEntry] = <factory>) -> None",
              "doc": "Represents the response from a memory search.\n\nAttributes:\n    memories: A list of memory entries that relate to the search query."
            }
          }
        },
        "in_memory_memory_service": {
          "__members__": {
            "InMemoryMemoryService": {
              "type": "class",
              "signature": "()",
              "doc": "An in-memory memory service for prototyping purpose only.\n\nUses keyword matching instead of semantic search.\n\nThis class is thread-safe, however, it should be used for testing and\ndevelopment only."
            },
            "_extract_words_lower": {
              "type": "function",
              "signature": "(text: 'str') -> 'set[str]'",
              "doc": "Extracts words from a string and converts them to lowercase."
            },
            "_user_key": {
              "type": "function",
              "signature": "(app_name: 'str', user_id: 'str')",
              "doc": ""
            }
          }
        },
        "memory_entry": {
          "__members__": {
            "MemoryEntry": {
              "type": "class",
              "signature": "(*, content: google.genai.types.Content, author: Optional[str] = None, timestamp: Optional[str] = None) -> None",
              "doc": "Represent one memory entry."
            }
          }
        },
        "vertex_ai_memory_bank_service": {
          "__members__": {
            "VertexAiMemoryBankService": {
              "type": "class",
              "signature": "(project: 'Optional[str]' = None, location: 'Optional[str]' = None, agent_engine_id: 'Optional[str]' = None)",
              "doc": "Implementation of the BaseMemoryService using Vertex AI Memory Bank."
            },
            "_convert_api_response": {
              "type": "function",
              "signature": "(api_response) -> 'Dict[str, Any]'",
              "doc": "Converts the API response to a JSON object based on the type."
            },
            "_should_filter_out_event": {
              "type": "function",
              "signature": "(content: 'types.Content') -> 'bool'",
              "doc": "Returns whether the event should be filtered out."
            }
          }
        },
        "vertex_ai_rag_memory_service": {
          "__members__": {
            "VertexAiRagMemoryService": {
              "type": "class",
              "signature": "(rag_corpus: 'Optional[str]' = None, similarity_top_k: 'Optional[int]' = None, vector_distance_threshold: 'float' = 10)",
              "doc": "A memory service that uses Vertex AI RAG for storage and retrieval."
            },
            "_merge_event_lists": {
              "type": "function",
              "signature": "(event_lists: 'list[list[Event]]') -> 'list[list[Event]]'",
              "doc": "Merge event lists that have overlapping timestamps."
            }
          }
        }
      },
      "models": {
        "base_llm": {
          "__members__": {
            "BaseLlm": {
              "type": "class",
              "signature": "(*, model: str) -> None",
              "doc": "The BaseLLM class.\n\nAttributes:\n  model: The name of the LLM, e.g. gemini-1.5-flash or gemini-1.5-flash-001."
            }
          }
        },
        "base_llm_connection": {
          "__members__": {
            "BaseLlmConnection": {
              "type": "class",
              "signature": "()",
              "doc": "The base class for a live model connection."
            }
          }
        },
        "gemini_llm_connection": {
          "__members__": {
            "GeminiLlmConnection": {
              "type": "class",
              "signature": "(gemini_session: 'live.AsyncSession')",
              "doc": "The Gemini model connection."
            }
          }
        },
        "google_llm": {
          "__members__": {
            "Gemini": {
              "type": "class",
              "signature": "(*, model: str = 'gemini-1.5-flash', retry_options: Optional[google.genai.types.HttpRetryOptions] = None) -> None",
              "doc": "Integration for Gemini models.\n\nAttributes:\n  model: The name of the Gemini model."
            },
            "_build_function_declaration_log": {
              "type": "function",
              "signature": "(func_decl: 'types.FunctionDeclaration') -> 'str'",
              "doc": ""
            },
            "_build_request_log": {
              "type": "function",
              "signature": "(req: 'LlmRequest') -> 'str'",
              "doc": ""
            },
            "_build_response_log": {
              "type": "function",
              "signature": "(resp: 'types.GenerateContentResponse') -> 'str'",
              "doc": ""
            },
            "_remove_display_name_if_present": {
              "type": "function",
              "signature": "(data_obj: 'Union[types.Blob, types.FileData, None]')",
              "doc": "Sets display_name to None for the Gemini API (non-Vertex) backend.\n\nThis backend does not support the display_name parameter for file uploads,\nso it must be removed to prevent request failures."
            }
          }
        },
        "lite_llm": {
          "__members__": {
            "FunctionChunk": {
              "type": "class",
              "signature": "(*, id: Optional[str], name: Optional[str], args: Optional[str], index: Optional[int] = 0) -> None",
              "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
            },
            "LiteLLMClient": {
              "type": "class",
              "signature": "()",
              "doc": "Provides acompletion method (for better testability)."
            },
            "LiteLlm": {
              "type": "class",
              "signature": "(model: 'str', *, llm_client: google.adk.models.lite_llm.LiteLLMClient = <factory>) -> None",
              "doc": "Wrapper around litellm.\n\nThis wrapper can be used with any of the models supported by litellm. The\nenvironment variable(s) needed for authenticating with the model endpoint must\nbe set prior to instantiating this class.\n\nExample usage:\n```\nos.environ[\"VERTEXAI_PROJECT\"] = \"your-gcp-project-id\"\nos.environ[\"VERTEXAI_LOCATION\"] = \"your-gcp-location\"\n\nagent = Agent(\n    model=LiteLlm(model=\"vertex_ai/claude-3-7-sonnet@20250219\"),\n    ...\n)\n```\n\nAttributes:\n  model: The name of the LiteLlm model.\n  llm_client: The LLM client to use for the model."
            },
            "TextChunk": {
              "type": "class",
              "signature": "(*, text: str) -> None",
              "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
            },
            "UsageMetadataChunk": {
              "type": "class",
              "signature": "(*, prompt_tokens: int, completion_tokens: int, total_tokens: int) -> None",
              "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
            },
            "_build_function_declaration_log": {
              "type": "function",
              "signature": "(func_decl: 'types.FunctionDeclaration') -> 'str'",
              "doc": "Builds a function declaration log.\n\nArgs:\n  func_decl: The function declaration to convert.\n\nReturns:\n  The function declaration log."
            },
            "_build_request_log": {
              "type": "function",
              "signature": "(req: 'LlmRequest') -> 'str'",
              "doc": "Builds a request log.\n\nArgs:\n  req: The request to convert.\n\nReturns:\n  The request log."
            },
            "_content_to_message_param": {
              "type": "function",
              "signature": "(content: 'types.Content') -> 'Union[Message, list[Message]]'",
              "doc": "Converts a types.Content to a litellm Message or list of Messages.\n\nHandles multipart function responses by returning a list of\nChatCompletionToolMessage objects if multiple function_response parts exist.\n\nArgs:\n  content: The content to convert.\n\nReturns:\n  A litellm Message, a list of litellm Messages."
            },
            "_function_declaration_to_tool_param": {
              "type": "function",
              "signature": "(function_declaration: 'types.FunctionDeclaration') -> 'dict'",
              "doc": "Converts a types.FunctionDeclaration to a openapi spec dictionary.\n\nArgs:\n  function_declaration: The function declaration to convert.\n\nReturns:\n  The openapi spec dictionary representation of the function declaration."
            },
            "_get_completion_inputs": {
              "type": "function",
              "signature": "(llm_request: 'LlmRequest') -> 'Tuple[List[Message], Optional[List[Dict]], Optional[types.SchemaUnion], Optional[Dict]]'",
              "doc": "Converts an LlmRequest to litellm inputs and extracts generation params.\n\nArgs:\n  llm_request: The LlmRequest to convert.\n\nReturns:\n  The litellm inputs (message list, tool dictionary, response format and generation params)."
            },
            "_get_content": {
              "type": "function",
              "signature": "(parts: 'Iterable[types.Part]') -> 'Union[OpenAIMessageContent, str]'",
              "doc": "Converts a list of parts to litellm content.\n\nArgs:\n  parts: The parts to convert.\n\nReturns:\n  The litellm content."
            },
            "_message_to_generate_content_response": {
              "type": "function",
              "signature": "(message: 'Message', is_partial: 'bool' = False) -> 'LlmResponse'",
              "doc": "Converts a litellm message to LlmResponse.\n\nArgs:\n  message: The message to convert.\n  is_partial: Whether the message is partial.\n\nReturns:\n  The LlmResponse."
            },
            "_model_response_to_chunk": {
              "type": "function",
              "signature": "(response: 'ModelResponse') -> 'Generator[Tuple[Optional[Union[TextChunk, FunctionChunk, UsageMetadataChunk]], Optional[str]], None, None]'",
              "doc": "Converts a litellm message to text, function or usage metadata chunk.\n\nArgs:\n  response: The response from the model.\n\nYields:\n  A tuple of text or function or usage metadata chunk and finish reason."
            },
            "_model_response_to_generate_content_response": {
              "type": "function",
              "signature": "(response: 'ModelResponse') -> 'LlmResponse'",
              "doc": "Converts a litellm response to LlmResponse. Also adds usage metadata.\n\nArgs:\n  response: The model response.\n\nReturns:\n  The LlmResponse."
            },
            "_safe_json_serialize": {
              "type": "function",
              "signature": "(obj) -> 'str'",
              "doc": "Convert any Python object to a JSON-serializable type or string.\n\nArgs:\n  obj: The object to serialize.\n\nReturns:\n  The JSON-serialized object string or string."
            },
            "_schema_to_dict": {
              "type": "function",
              "signature": "(schema: 'types.Schema') -> 'dict'",
              "doc": "Recursively converts a types.Schema to a pure-python dict\nwith all enum values written as lower-case strings.\n\nArgs:\n  schema: The schema to convert.\n\nReturns:\n  The dictionary representation of the schema."
            },
            "_to_litellm_role": {
              "type": "function",
              "signature": "(role: 'Optional[str]') -> \"Literal['user', 'assistant']\"",
              "doc": "Converts a types.Content role to a litellm role.\n\nArgs:\n  role: The types.Content role.\n\nReturns:\n  The litellm role."
            }
          }
        },
        "llm_request": {
          "__members__": {
            "LlmRequest": {
              "type": "class",
              "signature": "(*, model: Optional[str] = None, contents: list[google.genai.types.Content] = <factory>, config: google.genai.types.GenerateContentConfig = <factory>, live_connect_config: google.genai.types.LiveConnectConfig = <factory>, tools_dict: dict[str, google.adk.tools.base_tool.BaseTool] = <factory>) -> None",
              "doc": "LLM request class that allows passing in tools, output schema and system\n\ninstructions to the model.\n\nAttributes:\n  model: The model name.\n  contents: The contents to send to the model.\n  config: Additional config for the generate content request.\n  tools_dict: The tools dictionary."
            }
          }
        },
        "llm_response": {
          "__members__": {
            "LlmResponse": {
              "type": "class",
              "signature": "(*, content: Optional[google.genai.types.Content] = None, groundingMetadata: Optional[google.genai.types.GroundingMetadata] = None, partial: Optional[bool] = None, turnComplete: Optional[bool] = None, errorCode: Optional[str] = None, errorMessage: Optional[str] = None, interrupted: Optional[bool] = None, customMetadata: Optional[dict[str, Any]] = None, usageMetadata: Optional[google.genai.types.GenerateContentResponseUsageMetadata] = None, liveSessionResumptionUpdate: Optional[google.genai.types.LiveServerSessionResumptionUpdate] = None) -> None",
              "doc": "LLM response class that provides the first candidate response from the\n\nmodel if available. Otherwise, returns error code and message.\n\nAttributes:\n  content: The content of the response.\n  grounding_metadata: The grounding metadata of the response.\n  partial: Indicates whether the text content is part of a unfinished text\n    stream. Only used for streaming mode and when the content is plain text.\n  turn_complete: Indicates whether the response from the model is complete.\n    Only used for streaming mode.\n  error_code: Error code if the response is an error. Code varies by model.\n  error_message: Error message if the response is an error.\n  interrupted: Flag indicating that LLM was interrupted when generating the\n    content. Usually it's due to user interruption during a bidi streaming.\n  custom_metadata: The custom metadata of the LlmResponse."
            }
          }
        },
        "registry": {
          "__members__": {
            "LLMRegistry": {
              "type": "class",
              "signature": "()",
              "doc": "Registry for LLMs."
            }
          }
        }
      },
      "planners": {
        "base_planner": {
          "__members__": {
            "BasePlanner": {
              "type": "class",
              "signature": "()",
              "doc": "Abstract base class for all planners.\n\nThe planner allows the agent to generate plans for the queries to guide its\naction."
            }
          }
        },
        "built_in_planner": {
          "__members__": {
            "BuiltInPlanner": {
              "type": "class",
              "signature": "(*, thinking_config: google.genai.types.ThinkingConfig)",
              "doc": "The built-in planner that uses model's built-in thinking features.\n\nAttributes:\n    thinking_config: Config for model built-in thinking features. An error\n      will be returned if this field is set for models that don't support\n      thinking."
            }
          }
        },
        "plan_re_act_planner": {
          "__members__": {
            "PlanReActPlanner": {
              "type": "class",
              "signature": "()",
              "doc": "Plan-Re-Act planner that constrains the LLM response to generate a plan before any action/observation.\n\nNote: this planner does not require the model to support built-in thinking\nfeatures or setting the thinking config."
            }
          }
        }
      },
      "platform": {
        "thread": {
          "__members__": {
            "create_thread": {
              "type": "function",
              "signature": "(target: 'Callable[..., None]', *args, **kwargs)",
              "doc": "Creates a thread."
            }
          }
        }
      },
      "plugins": {
        "base_plugin": {
          "__members__": {
            "BasePlugin": {
              "type": "class",
              "signature": "(name: 'str')",
              "doc": "Base class for creating plugins.\n\nPlugins provide a structured way to intercept and modify agent, tool, and\nLLM behaviors at critical execution points in a callback manner. While agent\ncallbacks apply to a particular agent, plugins applies globally to all\nagents added in the runner. Plugins are best used for adding custom behaviors\nlike logging, monitoring, caching, or modifying requests and responses at key\nstages.\n\nA plugin can implement one or more methods of callbacks, but should not\nimplement the same method of callback for multiple times.\n\nRelation with [Agent callbacks](https://google.github.io/adk-docs/callbacks/):\n\n**Execution Order**\nSimilar to Agent callbacks, Plugins are executed in the order they are\nregistered. However, Plugin and Agent Callbacks are executed sequentially,\nwith Plugins takes precedence over agent callbacks. When the callback in a\nplugin returns a value, it will short circuit all remaining plugins and\nagent callbacks, causing all remaining plugins and agent callbacks\nto be skipped.\n\n**Change Propagation**\nPlugins and agent callbacks can both modify the value of the input parameters,\nincluding agent input, tool input, and LLM request/response, etc. They work in\nthe exactly same way. The modifications will be visible and passed to the next\ncallback in the chain. For example, if a plugin modifies the tool input with\nbefore_tool_callback, the modified tool input will be passed to the\nbefore_tool_callback of the next plugin, and further passed to the agent\ncallbacks if not short circuited.\n\nTo use a plugin, implement the desired callback methods and pass an instance\nof your custom plugin class to the ADK Runner.\n\nExamples:\n    A simple plugin that logs every tool call.\n\n    >>> class ToolLoggerPlugin(BasePlugin):\n    ..   def __init__(self):\n    ..     super().__init__(name=\"tool_logger\")\n    ..\n    ..   async def before_tool_callback(\n    ..       self, *, tool: BaseTool, tool_args: dict[str, Any],\n    tool_context:\n    ToolContext\n    ..   ):\n    ..     print(f\"[{self.name}] Calling tool '{tool.name}' with args:\n    {tool_args}\")\n    ..\n    ..   async def after_tool_callback(\n    ..       self, *, tool: BaseTool, tool_args: dict, tool_context:\n    ToolContext, result: dict\n    ..   ):\n    ..     print(f\"[{self.name}] Tool '{tool.name}' finished with result:\n    {result}\")\n    ..\n    >>> # Add the plugin to ADK Runner\n    >>> # runner = Runner(\n    >>> #     ...\n    >>> #     plugins=[ToolLoggerPlugin(), AgentPolicyPlugin()],\n    >>> # )"
            }
          }
        },
        "logging_plugin": {
          "__members__": {
            "LoggingPlugin": {
              "type": "class",
              "signature": "(name: 'str' = 'logging_plugin')",
              "doc": "A plugin that logs important information at each callback point.\n\nThis plugin helps printing all critical events in the console. It is not a\nreplacement of existing logging in ADK. It rather helps terminal based\ndebugging by showing all logs in the console, and serves as a simple demo for\neveryone to leverage when developing new plugins.\n\nThis plugin helps users track the invocation status by logging:\n- User messages and invocation context\n- Agent execution flow\n- LLM requests and responses\n- Tool calls with arguments and results\n- Events and final responses\n- Errors during model and tool execution\n\nExample:\n    >>> logging_plugin = LoggingPlugin()\n    >>> runner = Runner(\n    ...     agents=[my_agent],\n    ...     # ...\n    ...     plugins=[logging_plugin],\n    ... )"
            }
          }
        },
        "plugin_manager": {
          "__members__": {
            "PluginManager": {
              "type": "class",
              "signature": "(plugins: 'Optional[List[BasePlugin]]' = None)",
              "doc": "Manages the registration and execution of plugins.\n\nThe PluginManager is an internal class that orchestrates the invocation of\nplugin callbacks at key points in the SDK's execution lifecycle. It maintains\na list of registered plugins and ensures they are called in the order they\nwere registered.\n\nThe core execution logic implements an \"early exit\" strategy: if any plugin\ncallback returns a non-`None` value, the execution of subsequent plugins for\nthat specific event is halted, and the returned value is propagated up the\ncall stack. This allows plugins to short-circuit operations like agent runs,\ntool calls, or model requests."
            }
          }
        }
      },
      "runners": {
        "__members__": {
          "InMemoryRunner": {
            "type": "class",
            "signature": "(agent: 'BaseAgent', *, app_name: 'str' = 'InMemoryRunner', plugins: 'Optional[list[BasePlugin]]' = None)",
            "doc": "An in-memory Runner for testing and development.\n\nThis runner uses in-memory implementations for artifact, session, and memory\nservices, providing a lightweight and self-contained environment for agent\nexecution.\n\nAttributes:\n    agent: The root agent to run.\n    app_name: The application name of the runner. Defaults to\n      'InMemoryRunner'.\n    _in_memory_session_service: Deprecated. Please don't use. The in-memory\n      session service for the runner."
          },
          "Runner": {
            "type": "class",
            "signature": "(*, app_name: 'str', agent: 'BaseAgent', plugins: 'Optional[List[BasePlugin]]' = None, artifact_service: 'Optional[BaseArtifactService]' = None, session_service: 'BaseSessionService', memory_service: 'Optional[BaseMemoryService]' = None, credential_service: 'Optional[BaseCredentialService]' = None)",
            "doc": "The Runner class is used to run agents.\n\nIt manages the execution of an agent within a session, handling message\nprocessing, event generation, and interaction with various services like\nartifact storage, session management, and memory.\n\nAttributes:\n    app_name: The application name of the runner.\n    agent: The root agent to run.\n    artifact_service: The artifact service for the runner.\n    plugin_manager: The plugin manager for the runner.\n    session_service: The session service for the runner.\n    memory_service: The memory service for the runner."
          }
        }
      },
      "sessions": {
        "_session_util": {
          "__members__": {
            "decode_content": {
              "type": "function",
              "signature": "(content: 'Optional[dict[str, Any]]') -> 'Optional[types.Content]'",
              "doc": "Decodes a content object from a JSON dictionary."
            },
            "decode_grounding_metadata": {
              "type": "function",
              "signature": "(grounding_metadata: 'Optional[dict[str, Any]]') -> 'Optional[types.GroundingMetadata]'",
              "doc": "Decodes a grounding metadata object from a JSON dictionary."
            }
          }
        },
        "base_session_service": {
          "__members__": {
            "BaseSessionService": {
              "type": "class",
              "signature": "()",
              "doc": "Base class for session services.\n\nThe service provides a set of methods for managing sessions and events."
            },
            "GetSessionConfig": {
              "type": "class",
              "signature": "(*, num_recent_events: Optional[int] = None, after_timestamp: Optional[float] = None) -> None",
              "doc": "The configuration of getting a session."
            },
            "ListSessionsResponse": {
              "type": "class",
              "signature": "(*, sessions: list[google.adk.sessions.session.Session] = <factory>) -> None",
              "doc": "The response of listing sessions.\n\nThe events and states are not set within each Session object."
            }
          }
        },
        "database_session_service": {
          "__members__": {
            "Base": {
              "type": "class",
              "signature": "(**kwargs: 'Any') -> 'None'",
              "doc": "Base class for database tables."
            },
            "DatabaseSessionService": {
              "type": "class",
              "signature": "(db_url: 'str', **kwargs: 'Any')",
              "doc": "A session service that uses a database for storage."
            },
            "DynamicJSON": {
              "type": "class",
              "signature": "(*args: 'Any', **kwargs: 'Any')",
              "doc": "A JSON-like type that uses JSONB on PostgreSQL and TEXT with JSON serialization for other databases."
            },
            "PreciseTimestamp": {
              "type": "class",
              "signature": "(*args: 'Any', **kwargs: 'Any')",
              "doc": "Represents a timestamp precise to the microsecond."
            },
            "StorageAppState": {
              "type": "class",
              "signature": "(**kwargs)",
              "doc": "Represents an app state stored in the database."
            },
            "StorageEvent": {
              "type": "class",
              "signature": "(**kwargs)",
              "doc": "Represents an event stored in the database."
            },
            "StorageSession": {
              "type": "class",
              "signature": "(**kwargs)",
              "doc": "Represents a session stored in the database."
            },
            "StorageUserState": {
              "type": "class",
              "signature": "(**kwargs)",
              "doc": "Represents a user state stored in the database."
            },
            "_extract_state_delta": {
              "type": "function",
              "signature": "(state: 'dict[str, Any]')",
              "doc": ""
            },
            "_merge_state": {
              "type": "function",
              "signature": "(app_state, user_state, session_state)",
              "doc": ""
            }
          }
        },
        "in_memory_session_service": {
          "__members__": {
            "InMemorySessionService": {
              "type": "class",
              "signature": "()",
              "doc": "An in-memory implementation of the session service.\n\nIt is not suitable for multi-threaded production environments. Use it for\ntesting and development only."
            }
          }
        },
        "session": {
          "__members__": {
            "Session": {
              "type": "class",
              "signature": "(*, id: str, appName: str, userId: str, state: dict[str, typing.Any] = <factory>, events: list[google.adk.events.event.Event] = <factory>, lastUpdateTime: float = 0.0) -> None",
              "doc": "Represents a series of interactions between a user and agents.\n\nAttributes:\n  id: The unique identifier of the session.\n  app_name: The name of the app.\n  user_id: The id of the user.\n  state: The state of the session.\n  events: The events of the session, e.g. user input, model response, function\n    call/response, etc.\n  last_update_time: The last update time of the session."
            }
          }
        },
        "state": {
          "__members__": {
            "State": {
              "type": "class",
              "signature": "(value: dict[str, typing.Any], delta: dict[str, typing.Any])",
              "doc": "A state dict that maintain the current value and the pending-commit delta."
            }
          }
        },
        "vertex_ai_session_service": {
          "__members__": {
            "VertexAiSessionService": {
              "type": "class",
              "signature": "(project: 'Optional[str]' = None, location: 'Optional[str]' = None, agent_engine_id: 'Optional[str]' = None)",
              "doc": "Connects to the Vertex AI Agent Engine Session Service using GenAI API client.\n\nhttps://cloud.google.com/vertex-ai/generative-ai/docs/agent-engine/sessions/overview"
            },
            "_convert_api_response": {
              "type": "function",
              "signature": "(api_response)",
              "doc": "Converts the API response to a JSON object based on the type."
            },
            "_convert_event_to_json": {
              "type": "function",
              "signature": "(event: 'Event') -> 'Dict[str, Any]'",
              "doc": ""
            },
            "_from_api_event": {
              "type": "function",
              "signature": "(api_event: 'Dict[str, Any]') -> 'Event'",
              "doc": ""
            },
            "_is_vertex_express_mode": {
              "type": "function",
              "signature": "(project: 'Optional[str]', location: 'Optional[str]') -> 'bool'",
              "doc": "Check if Vertex AI and API key are both enabled replacing project and location, meaning the user is using the Vertex Express Mode."
            }
          }
        }
      },
      "telemetry": {
        "__members__": {
          "_build_llm_request_for_trace": {
            "type": "function",
            "signature": "(llm_request: 'LlmRequest') -> 'dict[str, Any]'",
            "doc": "Builds a dictionary representation of the LLM request for tracing.\n\nThis function prepares a dictionary representation of the LlmRequest\nobject, suitable for inclusion in a trace. It excludes fields that cannot\nbe serialized (e.g., function pointers) and avoids sending bytes data.\n\nArgs:\n  llm_request: The LlmRequest object.\n\nReturns:\n  A dictionary representation of the LLM request."
          },
          "_safe_json_serialize": {
            "type": "function",
            "signature": "(obj) -> 'str'",
            "doc": "Convert any Python object to a JSON-serializable type or string.\n\nArgs:\n  obj: The object to serialize.\n\nReturns:\n  The JSON-serialized object string or <non-serializable> if the object cannot be serialized."
          },
          "trace_call_llm": {
            "type": "function",
            "signature": "(invocation_context: 'InvocationContext', event_id: 'str', llm_request: 'LlmRequest', llm_response: 'LlmResponse')",
            "doc": "Traces a call to the LLM.\n\nThis function records details about the LLM request and response as\nattributes on the current OpenTelemetry span.\n\nArgs:\n  invocation_context: The invocation context for the current agent run.\n  event_id: The ID of the event.\n  llm_request: The LLM request object.\n  llm_response: The LLM response object."
          },
          "trace_merged_tool_calls": {
            "type": "function",
            "signature": "(response_event_id: 'str', function_response_event: 'Event')",
            "doc": "Traces merged tool call events.\n\nCalling this function is not needed for telemetry purposes. This is provided\nfor preventing /debug/trace requests (typically sent by web UI).\n\nArgs:\n  response_event_id: The ID of the response event.\n  function_response_event: The merged response event."
          },
          "trace_send_data": {
            "type": "function",
            "signature": "(invocation_context: 'InvocationContext', event_id: 'str', data: 'list[types.Content]')",
            "doc": "Traces the sending of data to the agent.\n\nThis function records details about the data sent to the agent as\nattributes on the current OpenTelemetry span.\n\nArgs:\n  invocation_context: The invocation context for the current agent run.\n  event_id: The ID of the event.\n  data: A list of content objects."
          },
          "trace_tool_call": {
            "type": "function",
            "signature": "(tool: 'BaseTool', args: 'dict[str, Any]', function_response_event: 'Event')",
            "doc": "Traces tool call.\n\nArgs:\n  tool: The tool that was called.\n  args: The arguments to the tool call.\n  function_response_event: The event with the function response details."
          }
        }
      },
      "tools": {
        "_automatic_function_calling_util": {
          "__members__": {
            "_annotate_nullable_fields": {
              "type": "function",
              "signature": "(schema: 'Dict')",
              "doc": ""
            },
            "_annotate_required_fields": {
              "type": "function",
              "signature": "(schema: 'Dict')",
              "doc": ""
            },
            "_get_fields_dict": {
              "type": "function",
              "signature": "(func: 'Callable') -> 'Dict'",
              "doc": ""
            },
            "_get_pydantic_schema": {
              "type": "function",
              "signature": "(func: 'Callable') -> 'Dict'",
              "doc": ""
            },
            "_get_return_type": {
              "type": "function",
              "signature": "(func: 'Callable') -> 'Any'",
              "doc": ""
            },
            "_map_pydantic_type_to_property_schema": {
              "type": "function",
              "signature": "(property_schema: 'Dict')",
              "doc": ""
            },
            "_map_pydantic_type_to_schema_type": {
              "type": "function",
              "signature": "(schema: 'Dict')",
              "doc": ""
            },
            "_process_pydantic_schema": {
              "type": "function",
              "signature": "(vertexai: 'bool', schema: 'Dict') -> 'Dict'",
              "doc": ""
            },
            "_remove_any_of": {
              "type": "function",
              "signature": "(schema: 'Dict')",
              "doc": ""
            },
            "_remove_default": {
              "type": "function",
              "signature": "(schema: 'Dict')",
              "doc": ""
            },
            "_remove_nullable": {
              "type": "function",
              "signature": "(schema: 'Dict')",
              "doc": ""
            },
            "_remove_title": {
              "type": "function",
              "signature": "(schema: 'Dict')",
              "doc": ""
            },
            "build_function_declaration": {
              "type": "function",
              "signature": "(func: 'Union[Callable, BaseModel]', ignore_params: 'Optional[list[str]]' = None, variant: 'GoogleLLMVariant' = <GoogleLLMVariant.GEMINI_API: 'GEMINI_API'>) -> 'types.FunctionDeclaration'",
              "doc": ""
            },
            "build_function_declaration_for_langchain": {
              "type": "function",
              "signature": "(vertexai: 'bool', name, description, func, param_pydantic_schema) -> 'types.FunctionDeclaration'",
              "doc": ""
            },
            "build_function_declaration_for_params_for_crewai": {
              "type": "function",
              "signature": "(vertexai: 'bool', name, description, func, param_pydantic_schema) -> 'types.FunctionDeclaration'",
              "doc": ""
            },
            "build_function_declaration_util": {
              "type": "function",
              "signature": "(vertexai: 'bool', name, description, func, before_param_pydantic_schema) -> 'types.FunctionDeclaration'",
              "doc": ""
            },
            "from_function_with_options": {
              "type": "function",
              "signature": "(func: 'Callable', variant: 'GoogleLLMVariant' = <GoogleLLMVariant.GEMINI_API: 'GEMINI_API'>) -> \"'types.FunctionDeclaration'\"",
              "doc": ""
            }
          }
        },
        "_forwarding_artifact_service": {
          "__members__": {
            "ForwardingArtifactService": {
              "type": "class",
              "signature": "(tool_context: 'ToolContext')",
              "doc": "Artifact service that forwards to the parent tool context."
            }
          }
        },
        "_function_parameter_parse_util": {
          "__members__": {
            "_get_required_fields": {
              "type": "function",
              "signature": "(schema: 'types.Schema') -> 'list[str]'",
              "doc": ""
            },
            "_is_builtin_primitive_or_compound": {
              "type": "function",
              "signature": "(annotation: 'inspect.Parameter.annotation') -> 'bool'",
              "doc": ""
            },
            "_is_default_value_compatible": {
              "type": "function",
              "signature": "(default_value: 'Any', annotation: 'inspect.Parameter.annotation') -> 'bool'",
              "doc": ""
            },
            "_parse_schema_from_parameter": {
              "type": "function",
              "signature": "(variant: 'GoogleLLMVariant', param: 'inspect.Parameter', func_name: 'str') -> 'types.Schema'",
              "doc": "parse schema from parameter.\n\nfrom the simplest case to the most complex case."
            },
            "_raise_for_any_of_if_mldev": {
              "type": "function",
              "signature": "(schema: 'types.Schema')",
              "doc": ""
            },
            "_raise_if_schema_unsupported": {
              "type": "function",
              "signature": "(variant: 'GoogleLLMVariant', schema: 'types.Schema')",
              "doc": ""
            },
            "_update_for_default_if_mldev": {
              "type": "function",
              "signature": "(schema: 'types.Schema')",
              "doc": ""
            }
          }
        },
        "_gemini_schema_util": {
          "__members__": {
            "_ExtendedJSONSchema": {
              "type": "class",
              "signature": "(*, type: Union[google.genai.types.JSONSchemaType, list[google.genai.types.JSONSchemaType], NoneType] = None, format: Optional[str] = None, title: Optional[str] = None, description: Optional[str] = None, default: Optional[Any] = None, items: Optional[google.genai.types.JSONSchema] = None, min_items: Optional[int] = None, max_items: Optional[int] = None, enum: Optional[list[Any]] = None, properties: Optional[dict[str, google.genai.types.JSONSchema]] = None, required: Optional[list[str]] = None, min_properties: Optional[int] = None, max_properties: Optional[int] = None, minimum: Optional[float] = None, maximum: Optional[float] = None, min_length: Optional[int] = None, max_length: Optional[int] = None, pattern: Optional[str] = None, any_of: Optional[list[google.genai.types.JSONSchema]] = None, property_ordering: Optional[list[str]] = None) -> None",
              "doc": "A subset of JSON Schema according to 2020-12 JSON Schema draft.\n\nRepresents a subset of a JSON Schema object that is used by the Gemini model.\nThe difference between this class and the Schema class is that this class is\ncompatible with OpenAPI 3.1 schema objects. And the Schema class is used to\nmake API call to Gemini model."
            },
            "_sanitize_schema_formats_for_gemini": {
              "type": "function",
              "signature": "(schema: 'dict[str, Any]') -> 'dict[str, Any]'",
              "doc": "Filters the schema to only include fields that are supported by JSONSchema."
            },
            "_sanitize_schema_type": {
              "type": "function",
              "signature": "(schema: 'dict[str, Any]') -> 'dict[str, Any]'",
              "doc": ""
            },
            "_to_gemini_schema": {
              "type": "function",
              "signature": "(openapi_schema: 'dict[str, Any]') -> 'Schema'",
              "doc": "Converts an OpenAPI schema dictionary to a Gemini Schema object."
            },
            "_to_snake_case": {
              "type": "function",
              "signature": "(text: 'str') -> 'str'",
              "doc": "Converts a string into snake_case.\n\nHandles lowerCamelCase, UpperCamelCase, or space-separated case, acronyms\n(e.g., \"REST API\") and consecutive uppercase letters correctly.  Also handles\nmixed cases with and without spaces.\n\nExamples:\n```\nto_snake_case('camelCase') -> 'camel_case'\nto_snake_case('UpperCamelCase') -> 'upper_camel_case'\nto_snake_case('space separated') -> 'space_separated'\n```\n\nArgs:\n    text: The input string.\n\nReturns:\n    The snake_case version of the string."
            }
          }
        },
        "_memory_entry_utils": {
          "__members__": {
            "extract_text": {
              "type": "function",
              "signature": "(memory: 'MemoryEntry', splitter: 'str' = ' ') -> 'str'",
              "doc": "Extracts the text from the memory entry."
            }
          }
        },
        "agent_tool": {
          "__members__": {
            "AgentTool": {
              "type": "class",
              "signature": "(agent: 'BaseAgent', skip_summarization: 'bool' = False)",
              "doc": "A tool that wraps an agent.\n\nThis tool allows an agent to be called as a tool within a larger application.\nThe agent's input schema is used to define the tool's input parameters, and\nthe agent's output is returned as the tool's result.\n\nAttributes:\n  agent: The agent to wrap.\n  skip_summarization: Whether to skip summarization of the agent output."
            },
            "AgentToolConfig": {
              "type": "class",
              "signature": "(*, agent: google.adk.agents.common_configs.AgentRefConfig, skip_summarization: bool = False) -> None",
              "doc": "The config for the AgentTool."
            }
          }
        },
        "apihub_tool": {
          "apihub_toolset": {
            "__members__": {
              "APIHubToolset": {
                "type": "class",
                "signature": "(*, apihub_resource_name: 'str', access_token: 'Optional[str]' = None, service_account_json: 'Optional[str]' = None, name: 'str' = '', description: 'str' = '', lazy_load_spec=False, auth_scheme: 'Optional[AuthScheme]' = None, auth_credential: 'Optional[AuthCredential]' = None, apihub_client: 'Optional[APIHubClient]' = None, tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None)",
                "doc": "APIHubTool generates tools from a given API Hub resource.\n\nExamples::\n\n  apihub_toolset = APIHubToolset(\n      apihub_resource_name=\"projects/test-project/locations/us-central1/apis/test-api\",\n      service_account_json=\"...\",\n      tool_filter=lambda tool, ctx=None: tool.name in ('my_tool',\n      'my_other_tool')\n  )\n\n  # Get all available tools\n  agent = LlmAgent(tools=apihub_toolset)\n\n**apihub_resource_name** is the resource name from API Hub. It must include\nAPI name, and can optionally include API version and spec name.\n\n- If apihub_resource_name includes a spec resource name, the content of that\n  spec will be used for generating the tools.\n- If apihub_resource_name includes only an api or a version name, the\n  first spec of the first version of that API will be used."
              }
            }
          },
          "clients": {
            "apihub_client": {
              "__members__": {
                "APIHubClient": {
                  "type": "class",
                  "signature": "(*, access_token: 'Optional[str]' = None, service_account_json: 'Optional[str]' = None)",
                  "doc": "Client for interacting with the API Hub service."
                },
                "BaseAPIHubClient": {
                  "type": "class",
                  "signature": "()",
                  "doc": "Base class for API Hub clients."
                }
              }
            },
            "secret_client": {
              "__members__": {
                "SecretManagerClient": {
                  "type": "class",
                  "signature": "(service_account_json: 'Optional[str]' = None, auth_token: 'Optional[str]' = None)",
                  "doc": "A client for interacting with Google Cloud Secret Manager.\n\nThis class provides a simplified interface for retrieving secrets from\nSecret Manager, handling authentication using either a service account\nJSON keyfile (passed as a string) or a pre-existing authorization token.\n\nAttributes:\n    _credentials:  Google Cloud credentials object (ServiceAccountCredentials\n      or Credentials).\n    _client: Secret Manager client instance."
                }
              }
            }
          }
        },
        "application_integration_tool": {
          "application_integration_toolset": {
            "__members__": {
              "ApplicationIntegrationToolset": {
                "type": "class",
                "signature": "(project: 'str', location: 'str', integration: 'Optional[str]' = None, triggers: 'Optional[List[str]]' = None, connection: 'Optional[str]' = None, entity_operations: 'Optional[str]' = None, actions: 'Optional[list[str]]' = None, tool_name_prefix: 'Optional[str]' = '', tool_instructions: 'Optional[str]' = '', service_account_json: 'Optional[str]' = None, auth_scheme: 'Optional[AuthScheme]' = None, auth_credential: 'Optional[AuthCredential]' = None, tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None)",
                "doc": "ApplicationIntegrationToolset generates tools from a given Application\nIntegration or Integration Connector resource.\n\nExample Usage::\n\n  # Get all available tools for an integration with api trigger\n  application_integration_toolset = ApplicationIntegrationToolset(\n      project=\"test-project\",\n      location=\"us-central1\"\n      integration=\"test-integration\",\n      triggers=[\"api_trigger/test_trigger\"],\n      service_account_credentials={...},\n  )\n\n  # Get all available tools for a connection using entity operations and\n  # actions\n  # Note: Find the list of supported entity operations and actions for a\n  # connection using integration connector apis:\n  # https://cloud.google.com/integration-connectors/docs/reference/rest/v1/projects.locations.connections.connectionSchemaMetadata\n  application_integration_toolset = ApplicationIntegrationToolset(\n      project=\"test-project\",\n      location=\"us-central1\"\n      connection=\"test-connection\",\n      entity_operations=[\"EntityId1\": [\"LIST\",\"CREATE\"], \"EntityId2\": []],\n      #empty list for actions means all operations on the entity are supported\n      actions=[\"action1\"],\n      service_account_credentials={...},\n  )\n\n  # Feed the toolset to agent\n  agent = LlmAgent(tools=[\n      ...,\n      application_integration_toolset,\n  ])"
              }
            }
          },
          "integration_connector_tool": {
            "__members__": {
              "IntegrationConnectorTool": {
                "type": "class",
                "signature": "(name: 'str', description: 'str', connection_name: 'str', connection_host: 'str', connection_service_name: 'str', entity: 'str', operation: 'str', action: 'str', rest_api_tool: 'RestApiTool', auth_scheme: 'Optional[Union[AuthScheme, str]]' = None, auth_credential: 'Optional[Union[AuthCredential, str]]' = None)",
                "doc": "A tool that wraps a RestApiTool to interact with a specific Application Integration endpoint.\n\nThis tool adds Application Integration specific context like connection\ndetails, entity, operation, and action to the underlying REST API call\nhandled by RestApiTool. It prepares the arguments and then delegates the\nactual API call execution to the contained RestApiTool instance.\n\n* Generates request params and body\n* Attaches auth credentials to API call.\n\nExample::\n\n  # Each API operation in the spec will be turned into its own tool\n  # Name of the tool is the operationId of that operation, in snake case\n  operations = OperationGenerator().parse(openapi_spec_dict)\n  tool = [RestApiTool.from_parsed_operation(o) for o in operations]"
              }
            }
          }
        },
        "authenticated_function_tool": {
          "__members__": {
            "AuthenticatedFunctionTool": {
              "type": "class",
              "signature": "(*, func: 'Callable[..., Any]', auth_config: 'AuthConfig' = None, response_for_auth_required: 'Optional[Union[dict[str, Any], str]]' = None)",
              "doc": "A FunctionTool that handles authentication before the actual tool logic\ngets called. Functions can accept a special `credential` argument which is the\ncredential ready for use.(Experimental)"
            }
          }
        },
        "base_authenticated_tool": {
          "__members__": {
            "BaseAuthenticatedTool": {
              "type": "class",
              "signature": "(*, name, description, auth_config: 'AuthConfig' = None, response_for_auth_required: 'Optional[Union[dict[str, Any], str]]' = None)",
              "doc": "A base tool class that handles authentication before the actual tool logic\ngets called. Functions can accept a special `credential` argument which is the\ncredential ready for use.(Experimental)"
            }
          }
        },
        "base_tool": {
          "__members__": {
            "BaseTool": {
              "type": "class",
              "signature": "(*, name, description, is_long_running: 'bool' = False)",
              "doc": "The base class for all tools."
            },
            "BaseToolConfig": {
              "type": "class",
              "signature": "() -> None",
              "doc": "The base configurations for all the tools."
            },
            "ToolArgsConfig": {
              "type": "class",
              "signature": "(**extra_data: Any) -> None",
              "doc": "The configuration for tool arguments.\n\nThis config allows arbitrary key-value pairs as tool arguments."
            },
            "ToolConfig": {
              "type": "class",
              "signature": "(*, name: str, args: Optional[google.adk.tools.base_tool.ToolArgsConfig] = None) -> None",
              "doc": "The configuration for a tool.\n\nThe config supports these types of tools:\n1. ADK built-in tools\n2. User-defined tool instances\n3. User-defined tool classes\n4. User-defined functions that generate tool instances\n5. User-defined function tools\n\nFor examples:\n\n  1. For ADK built-in tool instances or classes in `google.adk.tools` package,\n  they can be referenced directly with the `name` and optionally with\n  `config`.\n\n  ```\n  tools:\n    - name: google_search\n    - name: AgentTool\n      config:\n        agent: ./another_agent.yaml\n        skip_summarization: true\n  ```\n\n  2. For user-defined tool instances, the `name` is the fully qualified path\n  to the tool instance.\n\n  ```\n  tools:\n    - name: my_package.my_module.my_tool\n  ```\n\n  3. For user-defined tool classes (custom tools), the `name` is the fully\n  qualified path to the tool class and `config` is the arguments for the tool.\n\n  ```\n  tools:\n    - name: my_package.my_module.my_tool_class\n      config:\n        my_tool_arg1: value1\n        my_tool_arg2: value2\n  ```\n\n  4. For user-defined functions that generate tool instances, the `name` is the\n  fully qualified path to the function and `config` is passed to the function\n  as arguments.\n\n  ```\n  tools:\n    - name: my_package.my_module.my_tool_function\n      config:\n        my_function_arg1: value1\n        my_function_arg2: value2\n  ```\n\n  The function must have the following signature:\n  ```\n  def my_function(config: ToolArgsConfig) -> BaseTool:\n    ...\n  ```\n\n  5. For user-defined function tools, the `name` is the fully qualified path\n  to the function.\n\n  ```\n  tools:\n    - name: my_package.my_module.my_function_tool\n  ```"
            },
            "_find_tool_with_function_declarations": {
              "type": "function",
              "signature": "(llm_request: 'LlmRequest') -> 'Optional[types.Tool]'",
              "doc": ""
            }
          }
        },
        "base_toolset": {
          "__members__": {
            "BaseToolset": {
              "type": "class",
              "signature": "(*, tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None)",
              "doc": "Base class for toolset.\n\nA toolset is a collection of tools that can be used by an agent."
            },
            "ToolPredicate": {
              "type": "class",
              "signature": "(*args, **kwargs)",
              "doc": "Base class for a predicate that defines the interface to decide whether a\n\ntool should be exposed to LLM. Toolset implementer could consider whether to\naccept such instance in the toolset's constructor and apply the predicate in\nget_tools method."
            }
          }
        },
        "bigquery": {
          "bigquery_credentials": {
            "__members__": {
              "BigQueryCredentialsConfig": {
                "type": "class",
                "signature": "(*, credentials: Optional[google.auth.credentials.Credentials] = None, client_id: Optional[str] = None, client_secret: Optional[str] = None, scopes: Optional[List[str]] = None) -> None",
                "doc": "Configuration for Google API tools (Experimental).\n\nPlease do not use this in production, as it may be deprecated later."
              },
              "BigQueryCredentialsManager": {
                "type": "class",
                "signature": "(credentials_config: 'BigQueryCredentialsConfig')",
                "doc": "Manages Google API credentials with automatic refresh and OAuth flow handling.\n\nThis class centralizes credential management so multiple tools can share\nthe same authenticated session without duplicating OAuth logic."
              }
            }
          },
          "bigquery_tool": {
            "__members__": {
              "BigQueryTool": {
                "type": "class",
                "signature": "(func: 'Callable[..., Any]', *, credentials_config: 'Optional[BigQueryCredentialsConfig]' = None, bigquery_tool_config: 'Optional[BigQueryToolConfig]' = None)",
                "doc": "GoogleApiTool class for tools that call Google APIs.\n\nThis class is for developers to handcraft customized Google API tools rather\nthan auto generate Google API tools based on API specs.\n\nThis class handles all the OAuth complexity, credential management,\nand common Google API patterns so subclasses can focus on their\nspecific functionality."
              }
            }
          },
          "bigquery_toolset": {
            "__members__": {
              "BigQueryToolset": {
                "type": "class",
                "signature": "(*, tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None, credentials_config: 'Optional[BigQueryCredentialsConfig]' = None, bigquery_tool_config: 'Optional[BigQueryToolConfig]' = None)",
                "doc": "BigQuery Toolset contains tools for interacting with BigQuery data and metadata."
              }
            }
          },
          "client": {
            "__members__": {
              "get_bigquery_client": {
                "type": "function",
                "signature": "(*, project: 'Optional[str]', credentials: 'Credentials') -> 'bigquery.Client'",
                "doc": "Get a BigQuery client."
              }
            }
          },
          "config": {
            "__members__": {
              "BigQueryToolConfig": {
                "type": "class",
                "signature": "(*, write_mode: google.adk.tools.bigquery.config.WriteMode = <WriteMode.BLOCKED: 'blocked'>, max_query_result_rows: int = 50) -> None",
                "doc": "Configuration for BigQuery tools."
              },
              "WriteMode": {
                "type": "class",
                "signature": "(*values)",
                "doc": "Write mode indicating what levels of write operations are allowed in BigQuery."
              }
            }
          },
          "data_insights_tool": {
            "__members__": {
              "_append_message": {
                "type": "function",
                "signature": "(messages: List[Dict[str, Any]], new_message: Dict[str, Any])",
                "doc": ""
              },
              "_format_bq_table_ref": {
                "type": "function",
                "signature": "(table_ref: Dict[str, str]) -> str",
                "doc": "Formats a BigQuery table reference dictionary into a string."
              },
              "_format_datasource_as_dict": {
                "type": "function",
                "signature": "(datasource: Dict[str, Any]) -> Dict[str, Any]",
                "doc": "Formats a full datasource object into a dictionary with its name and schema."
              },
              "_format_schema_as_dict": {
                "type": "function",
                "signature": "(data: Dict[str, Any]) -> Dict[str, List[Any]]",
                "doc": "Extracts schema fields into a dictionary."
              },
              "_get_property": {
                "type": "function",
                "signature": "(data: Dict[str, Any], field_name: str, default: Any = '') -> Any",
                "doc": "Safely gets a property from a dictionary."
              },
              "_get_stream": {
                "type": "function",
                "signature": "(url: str, ca_payload: Dict[str, Any], headers: Dict[str, str], max_query_result_rows: int) -> List[Dict[str, Any]]",
                "doc": "Sends a JSON request to a streaming API and returns a list of messages."
              },
              "_handle_data_response": {
                "type": "function",
                "signature": "(resp: Dict[str, Any], max_query_result_rows: int) -> Dict[str, Any]",
                "doc": "Formats a data response into a dictionary."
              },
              "_handle_error": {
                "type": "function",
                "signature": "(resp: Dict[str, Any]) -> Dict[str, Dict[str, Any]]",
                "doc": "Formats an error response into a dictionary."
              },
              "_handle_schema_response": {
                "type": "function",
                "signature": "(resp: Dict[str, Any]) -> Dict[str, Any]",
                "doc": "Formats a schema response into a dictionary."
              },
              "_handle_text_response": {
                "type": "function",
                "signature": "(resp: Dict[str, Any]) -> Dict[str, str]",
                "doc": "Formats a text response into a dictionary."
              },
              "_is_json": {
                "type": "function",
                "signature": "(s: str) -> bool",
                "doc": "Checks if a string is a valid JSON object."
              },
              "ask_data_insights": {
                "type": "function",
                "signature": "(project_id: str, user_query_with_context: str, table_references: List[Dict[str, str]], credentials: google.auth.credentials.Credentials, config: google.adk.tools.bigquery.config.BigQueryToolConfig) -> Dict[str, Any]",
                "doc": "Answers questions about structured data in BigQuery tables using natural language.\n\nThis function takes auser's question (which can include conversational\nhistory for context) andreferences to specific BigQuery tables, and sends\nthem to a stateless conversational API.\n\nThe API uses a GenAI agent to understand the question, generate and execute\nSQL queries and Python code, and formulate an answer. This function returns a\ndetailed, sequential log of this entire process, which includes any generated\nSQL or Python code, the data retrieved, and the final text answer.\n\nUse this tool to perform data analysis, get insights, or answer complex\nquestions about the contents of specific BigQuery tables.\n\nArgs:\n    project_id (str): The project that the inquiry is performed in.\n    user_query_with_context (str): The user's question, potentially including\n      conversation history and system instructions for context.\n    table_references (List[Dict[str, str]]): A list of dictionaries, each\n      specifying a BigQuery table to be used as context for the question.\n    credentials (Credentials): The credentials to use for the request.\n    config (BigQueryToolConfig): The configuration for the tool.\n\nReturns:\n    A dictionary with two keys:\n    - 'status': A string indicating the final status (e.g., \"SUCCESS\").\n    - 'response': A list of dictionaries, where each dictionary\n      represents a step in the API's execution process (e.g., SQL\n      generation, data retrieval, final answer).\n\nExample:\n    A query joining multiple tables, showing the full return structure.\n    >>> ask_data_insights(\n    ...     project_id=\"some-project-id\",\n    ...     user_query_with_context=\"Which customer from New York spent the\n    most last month? \"\n    ...                           \"Context: The 'customers' table joins with\n    the 'orders' table \"\n    ...                           \"on the 'customer_id' column.\",\n    ...     table_references=[\n    ...         {\n    ...             \"projectId\": \"my-gcp-project\",\n    ...             \"datasetId\": \"sales_data\",\n    ...             \"tableId\": \"customers\"\n    ...         },\n    ...         {\n    ...             \"projectId\": \"my-gcp-project\",\n    ...             \"datasetId\": \"sales_data\",\n    ...             \"tableId\": \"orders\"\n    ...         }\n    ...     ]\n    ... )\n    {\n      \"status\": \"SUCCESS\",\n      \"response\": [\n        {\n          \"SQL Generated\": \"SELECT t1.customer_name, SUM(t2.order_total) ... \"\n        },\n        {\n          \"Data Retrieved\": {\n            \"headers\": [\"customer_name\", \"total_spent\"],\n            \"rows\": [[\"Jane Doe\", 1234.56]],\n            \"summary\": \"Showing all 1 rows.\"\n          }\n        },\n        {\n          \"Answer\": \"The customer who spent the most was Jane Doe.\"\n        }\n      ]\n    }"
              }
            }
          },
          "metadata_tool": {
            "__members__": {
              "get_dataset_info": {
                "type": "function",
                "signature": "(project_id: 'str', dataset_id: 'str', credentials: 'Credentials') -> 'dict'",
                "doc": "Get metadata information about a BigQuery dataset.\n\nArgs:\n    project_id (str): The Google Cloud project id containing the dataset.\n    dataset_id (str): The BigQuery dataset id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    dict: Dictionary representing the properties of the dataset.\n\nExamples:\n    >>> get_dataset_info(\"bigquery-public-data\", \"cdc_places\")\n    {\n      \"kind\": \"bigquery#dataset\",\n      \"etag\": \"fz9BaiXKgbGi53EpI2rJug==\",\n      \"id\": \"bigquery-public-data:cdc_places\",\n      \"selfLink\": \"https://content-bigquery.googleapis.com/bigquery/v2/projects/bigquery-public-data/datasets/cdc_places\",\n      \"datasetReference\": {\n        \"datasetId\": \"cdc_places\",\n        \"projectId\": \"bigquery-public-data\"\n      },\n      \"description\": \"Local Data for Better Health, County Data\",\n      \"access\": [\n        {\n          \"role\": \"WRITER\",\n          \"specialGroup\": \"projectWriters\"\n        },\n        {\n          \"role\": \"OWNER\",\n          \"specialGroup\": \"projectOwners\"\n        },\n        {\n          \"role\": \"OWNER\",\n          \"userByEmail\": \"some-redacted-email@bigquery-public-data.iam.gserviceaccount.com\"\n        },\n        {\n          \"role\": \"READER\",\n          \"specialGroup\": \"projectReaders\"\n        }\n      ],\n      \"creationTime\": \"1640891845643\",\n      \"lastModifiedTime\": \"1640891845643\",\n      \"location\": \"US\",\n      \"type\": \"DEFAULT\",\n      \"maxTimeTravelHours\": \"168\"\n    }"
              },
              "get_table_info": {
                "type": "function",
                "signature": "(project_id: 'str', dataset_id: 'str', table_id: 'str', credentials: 'Credentials') -> 'dict'",
                "doc": "Get metadata information about a BigQuery table.\n\nArgs:\n    project_id (str): The Google Cloud project id containing the dataset.\n    dataset_id (str): The BigQuery dataset id containing the table.\n    table_id (str): The BigQuery table id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    dict: Dictionary representing the properties of the table.\n\nExamples:\n    >>> get_table_info(\"bigquery-public-data\", \"cdc_places\", \"local_data_for_better_health_county_data\")\n    {\n      \"kind\": \"bigquery#table\",\n      \"etag\": \"wx23aDqmgc39oUSiNuYTAA==\",\n      \"id\": \"bigquery-public-data:cdc_places.local_data_for_better_health_county_data\",\n      \"selfLink\": \"https://content-bigquery.googleapis.com/bigquery/v2/projects/bigquery-public-data/datasets/cdc_places/tables/local_data_for_better_health_county_data\",\n      \"tableReference\": {\n        \"projectId\": \"bigquery-public-data\",\n        \"datasetId\": \"cdc_places\",\n        \"tableId\": \"local_data_for_better_health_county_data\"\n      },\n      \"description\": \"Local Data for Better Health, County Data\",\n      \"schema\": {\n        \"fields\": [\n          {\n            \"name\": \"year\",\n            \"type\": \"INTEGER\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"stateabbr\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"statedesc\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"locationname\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"datasource\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"category\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"measure\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"data_value_unit\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"data_value_type\",\n            \"type\": \"STRING\",\n            \"mode\": \"NULLABLE\"\n          },\n          {\n            \"name\": \"data_value\",\n            \"type\": \"FLOAT\",\n            \"mode\": \"NULLABLE\"\n          }\n        ]\n      },\n      \"numBytes\": \"234849\",\n      \"numLongTermBytes\": \"0\",\n      \"numRows\": \"1000\",\n      \"creationTime\": \"1640891846119\",\n      \"lastModifiedTime\": \"1749427268137\",\n      \"type\": \"TABLE\",\n      \"location\": \"US\",\n      \"numTimeTravelPhysicalBytes\": \"285737\",\n      \"numTotalLogicalBytes\": \"234849\",\n      \"numActiveLogicalBytes\": \"234849\",\n      \"numLongTermLogicalBytes\": \"0\",\n      \"numTotalPhysicalBytes\": \"326557\",\n      \"numActivePhysicalBytes\": \"326557\",\n      \"numLongTermPhysicalBytes\": \"0\",\n      \"numCurrentPhysicalBytes\": \"40820\"\n    }"
              },
              "list_dataset_ids": {
                "type": "function",
                "signature": "(project_id: 'str', credentials: 'Credentials') -> 'list[str]'",
                "doc": "List BigQuery dataset ids in a Google Cloud project.\n\nArgs:\n    project_id (str): The Google Cloud project id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    list[str]: List of the BigQuery dataset ids present in the project.\n\nExamples:\n    >>> list_dataset_ids(\"bigquery-public-data\")\n    ['america_health_rankings',\n     'american_community_survey',\n     'aml_ai_input_dataset',\n     'austin_311',\n     'austin_bikeshare',\n     'austin_crime',\n     'austin_incidents',\n     'austin_waste',\n     'baseball',\n     'bbc_news']"
              },
              "list_table_ids": {
                "type": "function",
                "signature": "(project_id: 'str', dataset_id: 'str', credentials: 'Credentials') -> 'list[str]'",
                "doc": "List table ids in a BigQuery dataset.\n\nArgs:\n    project_id (str): The Google Cloud project id containing the dataset.\n    dataset_id (str): The BigQuery dataset id.\n    credentials (Credentials): The credentials to use for the request.\n\nReturns:\n    list[str]: List of the tables ids present in the dataset.\n\nExamples:\n    >>> list_table_ids(\"bigquery-public-data\", \"cdc_places\")\n    ['chronic_disease_indicators',\n     'local_data_for_better_health_county_data']"
              }
            }
          },
          "query_tool": {
            "__members__": {
              "execute_sql": {
                "type": "function",
                "signature": "(project_id: 'str', query: 'str', credentials: 'Credentials', config: 'BigQueryToolConfig', tool_context: 'ToolContext') -> 'dict'",
                "doc": "Run a BigQuery or BigQuery ML SQL query in the project and return the result.\n\nArgs:\n    project_id (str): The GCP project id in which the query should be\n      executed.\n    query (str): The BigQuery SQL query to be executed.\n    credentials (Credentials): The credentials to use for the request.\n    config (BigQueryToolConfig): The configuration for the tool.\n    tool_context (ToolContext): The context for the tool.\n\nReturns:\n    dict: Dictionary representing the result of the query.\n          If the result contains the key \"result_is_likely_truncated\" with\n          value True, it means that there may be additional rows matching the\n          query not returned in the result.\n\nExamples:\n    Fetch data or insights from a table:\n\n        >>> execute_sql(\"my_project\",\n        ... \"SELECT island, COUNT(*) AS population \"\n        ... \"FROM bigquery-public-data.ml_datasets.penguins GROUP BY island\")\n        {\n          \"status\": \"SUCCESS\",\n          \"rows\": [\n              {\n                  \"island\": \"Dream\",\n                  \"population\": 124\n              },\n              {\n                  \"island\": \"Biscoe\",\n                  \"population\": 168\n              },\n              {\n                  \"island\": \"Torgersen\",\n                  \"population\": 52\n              }\n          ]\n        }"
              },
              "get_execute_sql": {
                "type": "function",
                "signature": "(config: 'BigQueryToolConfig') -> 'Callable[..., dict]'",
                "doc": "Get the execute_sql tool customized as per the given tool config.\n\nArgs:\n    config: BigQuery tool configuration indicating the behavior of the\n      execute_sql tool.\n\nReturns:\n    callable[..., dict]: A version of the execute_sql tool respecting the tool\n    config."
              }
            }
          }
        },
        "computer_use": {
          "base_computer": {
            "__members__": {
              "BaseComputer": {
                "type": "class",
                "signature": "()",
                "doc": "async defines an interface for computer environments.\n\nThis abstract base class async defines the standard interface for controlling\ncomputer environments, including web browsers and other interactive systems."
              },
              "ComputerEnvironment": {
                "type": "class",
                "signature": "(*values)",
                "doc": "Case insensitive enum for computer environments."
              },
              "ComputerState": {
                "type": "class",
                "signature": "(*, screenshot: bytes = None, url: Optional[str] = None) -> None",
                "doc": "Represents the current state of the computer environment.\n\nAttributes:\n  screenshot: The screenshot in PNG format as bytes.\n  url: The current URL of the webpage being displayed."
              }
            }
          },
          "computer_use_tool": {
            "__members__": {
              "ComputerUseTool": {
                "type": "class",
                "signature": "(*, func: 'Callable[..., Any]', screen_size: 'tuple[int, int]', virtual_screen_size: 'tuple[int, int]' = (1000, 1000))",
                "doc": "A tool that wraps computer control functions for use with LLMs.\n\nThis tool automatically normalizes coordinates from a virtual coordinate space\n(by default 1000x1000) to the actual screen size. This allows LLMs to work\nwith a consistent coordinate system regardless of the actual screen dimensions,\nmaking their output more predictable and easier to handle."
              }
            }
          },
          "computer_use_toolset": {
            "__members__": {
              "ComputerUseToolset": {
                "type": "class",
                "signature": "(*, computer: 'BaseComputer')",
                "doc": "Base class for toolset.\n\nA toolset is a collection of tools that can be used by an agent."
              }
            }
          }
        },
        "enterprise_search_tool": {
          "__members__": {
            "EnterpriseWebSearchTool": {
              "type": "class",
              "signature": "()",
              "doc": "A Gemini 2+ built-in tool using web grounding for Enterprise compliance.\n\nSee the documentation for more details:\nhttps://cloud.google.com/vertex-ai/generative-ai/docs/grounding/web-grounding-enterprise."
            }
          }
        },
        "example_tool": {
          "__members__": {
            "ExampleTool": {
              "type": "class",
              "signature": "(examples: 'Union[list[Example], BaseExampleProvider]')",
              "doc": "A tool that adds (few-shot) examples to the LLM request.\n\nAttributes:\n  examples: The examples to add to the LLM request."
            }
          }
        },
        "exit_loop_tool": {
          "__members__": {
            "exit_loop": {
              "type": "function",
              "signature": "(tool_context: google.adk.tools.tool_context.ToolContext)",
              "doc": "Exits the loop.\n\nCall this function only when you are instructed to do so."
            }
          }
        },
        "function_tool": {
          "__members__": {
            "FunctionTool": {
              "type": "class",
              "signature": "(func: 'Callable[..., Any]')",
              "doc": "A tool that wraps a user-defined Python function.\n\nAttributes:\n  func: The function to wrap."
            }
          }
        },
        "get_user_choice_tool": {
          "__members__": {
            "get_user_choice": {
              "type": "function",
              "signature": "(options: list[str], tool_context: google.adk.tools.tool_context.ToolContext) -> Optional[str]",
              "doc": "Provides the options to the user and asks them to choose one."
            }
          }
        },
        "google_api_tool": {
          "google_api_tool": {
            "__members__": {
              "GoogleApiTool": {
                "type": "class",
                "signature": "(rest_api_tool: 'RestApiTool', client_id: 'Optional[str]' = None, client_secret: 'Optional[str]' = None, service_account: 'Optional[ServiceAccount]' = None)",
                "doc": "The base class for all tools."
              }
            }
          },
          "google_api_toolset": {
            "__members__": {
              "GoogleApiToolset": {
                "type": "class",
                "signature": "(api_name: 'str', api_version: 'str', client_id: 'Optional[str]' = None, client_secret: 'Optional[str]' = None, tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None, service_account: 'Optional[ServiceAccount]' = None)",
                "doc": "Google API Toolset contains tools for interacting with Google APIs.\n\nUsually one toolsets will contains tools only related to one Google API, e.g.\nGoogle Bigquery API toolset will contains tools only related to Google\nBigquery API, like list dataset tool, list table tool etc."
              }
            }
          },
          "google_api_toolsets": {
            "__members__": {
              "BigQueryToolset": {
                "type": "class",
                "signature": "(client_id: 'Optional[str]' = None, client_secret: 'Optional[str]' = None, tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None, service_account: 'Optional[ServiceAccount]' = None)",
                "doc": "Auto-generated Bigquery toolset based on Google BigQuery API v2 spec exposed by Google API discovery API"
              },
              "CalendarToolset": {
                "type": "class",
                "signature": "(client_id: 'Optional[str]' = None, client_secret: 'Optional[str]' = None, tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None, service_account: 'Optional[ServiceAccount]' = None)",
                "doc": "Auto-generated Calendar toolset based on Google Calendar API v3 spec exposed by Google API discovery API"
              },
              "DocsToolset": {
                "type": "class",
                "signature": "(client_id: 'Optional[str]' = None, client_secret: 'Optional[str]' = None, tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None, service_account: 'Optional[ServiceAccount]' = None)",
                "doc": "Auto-generated Docs toolset based on Google Docs API v1 spec exposed by Google API discovery API"
              },
              "GmailToolset": {
                "type": "class",
                "signature": "(client_id: 'Optional[str]' = None, client_secret: 'Optional[str]' = None, tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None, service_account: 'Optional[ServiceAccount]' = None)",
                "doc": "Auto-generated Gmail toolset based on Google Gmail API v1 spec exposed by Google API discovery API"
              },
              "SheetsToolset": {
                "type": "class",
                "signature": "(client_id: 'Optional[str]' = None, client_secret: 'Optional[str]' = None, tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None, service_account: 'Optional[ServiceAccount]' = None)",
                "doc": "Auto-generated Sheets toolset based on Google Sheets API v4 spec exposed by Google API discovery API"
              },
              "SlidesToolset": {
                "type": "class",
                "signature": "(client_id: 'Optional[str]' = None, client_secret: 'Optional[str]' = None, tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None, service_account: 'Optional[ServiceAccount]' = None)",
                "doc": "Auto-generated Slides toolset based on Google Slides API v1 spec exposed by Google API discovery API"
              },
              "YoutubeToolset": {
                "type": "class",
                "signature": "(client_id: 'Optional[str]' = None, client_secret: 'Optional[str]' = None, tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None, service_account: 'Optional[ServiceAccount]' = None)",
                "doc": "Auto-generated Youtube toolset based on Youtube API v3 spec exposed by Google API discovery API"
              }
            }
          },
          "googleapi_to_openapi_converter": {
            "__members__": {
              "GoogleApiToOpenApiConverter": {
                "type": "class",
                "signature": "(api_name: 'str', api_version: 'str')",
                "doc": "Converts Google API Discovery documents to OpenAPI v3 format."
              },
              "main": {
                "type": "function",
                "signature": "()",
                "doc": "Command line interface for the converter."
              }
            }
          }
        },
        "google_search_tool": {
          "__members__": {
            "GoogleSearchTool": {
              "type": "class",
              "signature": "()",
              "doc": "A built-in tool that is automatically invoked by Gemini 2 models to retrieve search results from Google Search.\n\nThis tool operates internally within the model and does not require or perform\nlocal code execution."
            }
          }
        },
        "load_artifacts_tool": {
          "__members__": {
            "LoadArtifactsTool": {
              "type": "class",
              "signature": "()",
              "doc": "A tool that loads the artifacts and adds them to the session."
            }
          }
        },
        "load_memory_tool": {
          "__members__": {
            "LoadMemoryResponse": {
              "type": "class",
              "signature": "(*, memories: list[google.adk.memory.memory_entry.MemoryEntry] = <factory>) -> None",
              "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
            },
            "LoadMemoryTool": {
              "type": "class",
              "signature": "()",
              "doc": "A tool that loads the memory for the current user.\n\nNOTE: Currently this tool only uses text part from the memory."
            },
            "load_memory": {
              "type": "function",
              "signature": "(query: 'str', tool_context: 'ToolContext') -> 'LoadMemoryResponse'",
              "doc": "Loads the memory for the current user.\n\nArgs:\n  query: The query to load the memory for.\n\nReturns:\n  A list of memory results."
            }
          }
        },
        "load_web_page": {
          "__members__": {
            "load_web_page": {
              "type": "function",
              "signature": "(url: str) -> str",
              "doc": "Fetches the content in the url and returns the text in it.\n\nArgs:\n    url (str): The url to browse.\n\nReturns:\n    str: The text content of the url."
            }
          }
        },
        "long_running_tool": {
          "__members__": {
            "LongRunningFunctionTool": {
              "type": "class",
              "signature": "(func: 'Callable')",
              "doc": "A function tool that returns the result asynchronously.\n\nThis tool is used for long-running operations that may take a significant\namount of time to complete. The framework will call the function. Once the\nfunction returns, the response will be returned asynchronously to the\nframework which is identified by the function_call_id.\n\nExample:\n```python\ntool = LongRunningFunctionTool(a_long_running_function)\n```\n\nAttributes:\n  is_long_running: Whether the tool is a long running operation."
            }
          }
        },
        "mcp_tool": {
          "conversion_utils": {
            "__members__": {
              "adk_to_mcp_tool_type": {
                "type": "function",
                "signature": "(tool: 'BaseTool') -> 'mcp_types.Tool'",
                "doc": "Convert a Tool in ADK into MCP tool type.\n\nThis function transforms an ADK tool definition into its equivalent\nrepresentation in the MCP (Model Context Protocol) system.\n\nArgs:\n    tool: The ADK tool to convert. It should be an instance of a class derived\n      from `BaseTool`.\n\nReturns:\n    An object of MCP Tool type, representing the converted tool.\n\nExamples:\n    # Assuming 'my_tool' is an instance of a BaseTool derived class\n    mcp_tool = adk_to_mcp_tool_type(my_tool)\n    print(mcp_tool)"
              },
              "gemini_to_json_schema": {
                "type": "function",
                "signature": "(gemini_schema: 'Schema') -> 'Dict[str, Any]'",
                "doc": "Converts a Gemini Schema object into a JSON Schema dictionary.\n\nArgs:\n    gemini_schema: An instance of the Gemini Schema class.\n\nReturns:\n    A dictionary representing the equivalent JSON Schema.\n\nRaises:\n    TypeError: If the input is not an instance of the expected Schema class.\n    ValueError: If an invalid Gemini Type enum value is encountered."
              }
            }
          },
          "mcp_session_manager": {
            "__members__": {
              "MCPSessionManager": {
                "type": "class",
                "signature": "(connection_params: 'Union[StdioServerParameters, StdioConnectionParams, SseConnectionParams, StreamableHTTPConnectionParams]', errlog: 'TextIO' = <_io.TextIOWrapper name='<stderr>' mode='w' encoding='utf-8'>)",
                "doc": "Manages MCP client sessions.\n\nThis class provides methods for creating and initializing MCP client sessions,\nhandling different connection parameters (Stdio and SSE) and supporting\nsession pooling based on authentication headers."
              },
              "SseConnectionParams": {
                "type": "class",
                "signature": "(*, url: str, headers: dict[str, typing.Any] | None = None, timeout: float = 5.0, sse_read_timeout: float = 300.0) -> None",
                "doc": "Parameters for the MCP SSE connection.\n\nSee MCP SSE Client documentation for more details.\nhttps://github.com/modelcontextprotocol/python-sdk/blob/main/src/mcp/client/sse.py\n\nAttributes:\n    url: URL for the MCP SSE server.\n    headers: Headers for the MCP SSE connection.\n    timeout: Timeout in seconds for establishing the connection to the MCP SSE\n      server.\n    sse_read_timeout: Timeout in seconds for reading data from the MCP SSE\n      server."
              },
              "SseServerParams": {
                "type": "class",
                "signature": "(*, url: str, headers: dict[str, typing.Any] | None = None, timeout: float = 5.0, sse_read_timeout: float = 300.0) -> None",
                "doc": "Parameters for the MCP SSE connection.\n\nSee MCP SSE Client documentation for more details.\nhttps://github.com/modelcontextprotocol/python-sdk/blob/main/src/mcp/client/sse.py\n\nAttributes:\n    url: URL for the MCP SSE server.\n    headers: Headers for the MCP SSE connection.\n    timeout: Timeout in seconds for establishing the connection to the MCP SSE\n      server.\n    sse_read_timeout: Timeout in seconds for reading data from the MCP SSE\n      server."
              },
              "StdioConnectionParams": {
                "type": "class",
                "signature": "(*, server_params: mcp.client.stdio.StdioServerParameters, timeout: float = 5.0) -> None",
                "doc": "Parameters for the MCP Stdio connection.\n\nAttributes:\n    server_params: Parameters for the MCP Stdio server.\n    timeout: Timeout in seconds for establishing the connection to the MCP\n      stdio server."
              },
              "StreamableHTTPConnectionParams": {
                "type": "class",
                "signature": "(*, url: str, headers: dict[str, typing.Any] | None = None, timeout: float = 5.0, sse_read_timeout: float = 300.0, terminate_on_close: bool = True) -> None",
                "doc": "Parameters for the MCP SSE connection.\n\nSee MCP SSE Client documentation for more details.\nhttps://github.com/modelcontextprotocol/python-sdk/blob/main/src/mcp/client/streamable_http.py\n\nAttributes:\n    url: URL for the MCP Streamable HTTP server.\n    headers: Headers for the MCP Streamable HTTP connection.\n    timeout: Timeout in seconds for establishing the connection to the MCP\n      Streamable HTTP server.\n    sse_read_timeout: Timeout in seconds for reading data from the MCP\n      Streamable HTTP server.\n    terminate_on_close: Whether to terminate the MCP Streamable HTTP server\n      when the connection is closed."
              },
              "StreamableHTTPServerParams": {
                "type": "class",
                "signature": "(*, url: str, headers: dict[str, typing.Any] | None = None, timeout: float = 5.0, sse_read_timeout: float = 300.0, terminate_on_close: bool = True) -> None",
                "doc": "Parameters for the MCP SSE connection.\n\nSee MCP SSE Client documentation for more details.\nhttps://github.com/modelcontextprotocol/python-sdk/blob/main/src/mcp/client/streamable_http.py\n\nAttributes:\n    url: URL for the MCP Streamable HTTP server.\n    headers: Headers for the MCP Streamable HTTP connection.\n    timeout: Timeout in seconds for establishing the connection to the MCP\n      Streamable HTTP server.\n    sse_read_timeout: Timeout in seconds for reading data from the MCP\n      Streamable HTTP server.\n    terminate_on_close: Whether to terminate the MCP Streamable HTTP server\n      when the connection is closed."
              },
              "retry_on_closed_resource": {
                "type": "function",
                "signature": "(func)",
                "doc": "Decorator to automatically retry action when MCP session is closed.\n\nWhen MCP session was closed, the decorator will automatically retry the\naction once. The create_session method will handle creating a new session\nif the old one was disconnected.\n\nArgs:\n    func: The function to decorate.\n\nReturns:\n    The decorated function."
              }
            }
          },
          "mcp_tool": {
            "__members__": {
              "MCPTool": {
                "type": "class",
                "signature": "(*, mcp_tool: 'McpBaseTool', mcp_session_manager: 'MCPSessionManager', auth_scheme: 'Optional[AuthScheme]' = None, auth_credential: 'Optional[AuthCredential]' = None)",
                "doc": "Turns an MCP Tool into an ADK Tool.\n\nInternally, the tool initializes from a MCP Tool, and uses the MCP Session to\ncall the tool.\n\nNote: For API key authentication, only header-based API keys are supported.\nQuery and cookie-based API keys will result in authentication errors."
              }
            }
          },
          "mcp_toolset": {
            "__members__": {
              "MCPToolset": {
                "type": "class",
                "signature": "(*, connection_params: 'Union[StdioServerParameters, StdioConnectionParams, SseConnectionParams, StreamableHTTPConnectionParams]', tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None, errlog: 'TextIO' = <_io.TextIOWrapper name='<stderr>' mode='w' encoding='utf-8'>, auth_scheme: 'Optional[AuthScheme]' = None, auth_credential: 'Optional[AuthCredential]' = None)",
                "doc": "Connects to a MCP Server, and retrieves MCP Tools into ADK Tools.\n\nThis toolset manages the connection to an MCP server and provides tools\nthat can be used by an agent. It properly implements the BaseToolset\ninterface for easy integration with the agent framework.\n\nUsage::\n\n  toolset = MCPToolset(\n      connection_params=StdioServerParameters(\n          command='npx',\n          args=[\"-y\", \"@modelcontextprotocol/server-filesystem\"],\n      ),\n      tool_filter=['read_file', 'list_directory']  # Optional: filter specific tools\n  )\n\n  # Use in an agent\n  agent = LlmAgent(\n      model='gemini-2.0-flash',\n      name='enterprise_assistant',\n      instruction='Help user accessing their file systems',\n      tools=[toolset],\n  )\n\n  # Cleanup is handled automatically by the agent framework\n  # But you can also manually close if needed:\n  # await toolset.close()"
              }
            }
          }
        },
        "openapi_tool": {
          "auth": {
            "auth_helpers": {
              "__members__": {
                "OpenIdConfig": {
                  "type": "class",
                  "signature": "(*, client_id: str, auth_uri: str, token_uri: str, client_secret: str, redirect_uri: Optional[str]) -> None",
                  "doc": "Represents OpenID Connect configuration.\n\nAttributes:\n    client_id: The client ID.\n    auth_uri: The authorization URI.\n    token_uri: The token URI.\n    client_secret: The client secret.\n\nExample:\n    config = OpenIdConfig(\n        client_id=\"your_client_id\",\n        auth_uri=\"https://accounts.google.com/o/oauth2/auth\",\n        token_uri=\"https://oauth2.googleapis.com/token\",\n        client_secret=\"your_client_secret\",\n        redirect\n    )"
                },
                "credential_to_param": {
                  "type": "function",
                  "signature": "(auth_scheme: Union[fastapi.openapi.models.APIKey, fastapi.openapi.models.HTTPBase, fastapi.openapi.models.OAuth2, fastapi.openapi.models.OpenIdConnect, fastapi.openapi.models.HTTPBearer, google.adk.auth.auth_schemes.OpenIdConnectWithConfig], auth_credential: google.adk.auth.auth_credential.AuthCredential) -> Tuple[Optional[google.adk.tools.openapi_tool.common.common.ApiParameter], Optional[Dict[str, Any]]]",
                  "doc": "Converts AuthCredential and AuthScheme to a Parameter and a dictionary for additional kwargs.\n\nThis function now supports all credential types returned by the exchangers:\n- API Key\n- HTTP Bearer (for Bearer tokens, OAuth2, Service Account, OpenID Connect)\n- OAuth2 and OpenID Connect (returns None, None, as the token is now a Bearer\ntoken)\n- Service Account (returns None, None, as the token is now a Bearer token)\n\nArgs:\n    auth_scheme: The AuthScheme object.\n    auth_credential: The AuthCredential object.\n\nReturns:\n    Tuple: (ApiParameter, Dict[str, Any])"
                },
                "dict_to_auth_scheme": {
                  "type": "function",
                  "signature": "(data: Dict[str, Any]) -> Union[fastapi.openapi.models.APIKey, fastapi.openapi.models.HTTPBase, fastapi.openapi.models.OAuth2, fastapi.openapi.models.OpenIdConnect, fastapi.openapi.models.HTTPBearer, google.adk.auth.auth_schemes.OpenIdConnectWithConfig]",
                  "doc": "Converts a dictionary to a FastAPI AuthScheme object.\n\nArgs:\n    data: The dictionary representing the security scheme.\n\nReturns:\n    A AuthScheme object (APIKey, HTTPBase, OAuth2, OpenIdConnect, or\n    HTTPBearer).\n\nRaises:\n    ValueError: If the 'type' field is missing or invalid, or if the\n        dictionary cannot be converted to the corresponding Pydantic model.\n\nExample:\n```python\napi_key_data = {\n    \"type\": \"apiKey\",\n    \"in\": \"header\",\n    \"name\": \"X-API-Key\",\n}\napi_key_scheme = dict_to_auth_scheme(api_key_data)\n\nbearer_data = {\n    \"type\": \"http\",\n    \"scheme\": \"bearer\",\n    \"bearerFormat\": \"JWT\",\n}\nbearer_scheme = dict_to_auth_scheme(bearer_data)\n\n\noauth2_data = {\n    \"type\": \"oauth2\",\n    \"flows\": {\n        \"authorizationCode\": {\n            \"authorizationUrl\": \"https://example.com/auth\",\n            \"tokenUrl\": \"https://example.com/token\",\n        }\n    }\n}\noauth2_scheme = dict_to_auth_scheme(oauth2_data)\n\nopenid_data = {\n    \"type\": \"openIdConnect\",\n    \"openIdConnectUrl\": \"https://example.com/.well-known/openid-configuration\"\n}\nopenid_scheme = dict_to_auth_scheme(openid_data)\n\n\n```"
                },
                "openid_dict_to_scheme_credential": {
                  "type": "function",
                  "signature": "(config_dict: Dict[str, Any], scopes: List[str], credential_dict: Dict[str, Any]) -> Tuple[google.adk.auth.auth_schemes.OpenIdConnectWithConfig, google.adk.auth.auth_credential.AuthCredential]",
                  "doc": "Constructs OpenID scheme and credential from configuration and credential dictionaries.\n\nArgs:\n    config_dict: Dictionary containing OpenID Connect configuration,  must\n      include at least 'authorization_endpoint' and 'token_endpoint'.\n    scopes: List of scopes to be used.\n    credential_dict: Dictionary containing credential information, must\n      include 'client_id', 'client_secret', and 'scopes'.  May optionally\n      include 'redirect_uri'.\n\nReturns:\n    Tuple: (OpenIdConnectWithConfig, AuthCredential)\n\nRaises:\n    ValueError: If required fields are missing in the input dictionaries."
                },
                "openid_url_to_scheme_credential": {
                  "type": "function",
                  "signature": "(openid_url: str, scopes: List[str], credential_dict: Dict[str, Any]) -> Tuple[google.adk.auth.auth_schemes.OpenIdConnectWithConfig, google.adk.auth.auth_credential.AuthCredential]",
                  "doc": "Constructs OpenID scheme and credential from OpenID URL, scopes, and credential dictionary.\n\nFetches OpenID configuration from the provided URL.\n\nArgs:\n    openid_url: The OpenID Connect discovery URL.\n    scopes: List of scopes to be used.\n    credential_dict: Dictionary containing credential information, must\n      include at least \"client_id\" and \"client_secret\", may optionally include\n      \"redirect_uri\" and \"scope\"\n\nReturns:\n    Tuple: (AuthScheme, AuthCredential)\n\nRaises:\n    ValueError: If the OpenID URL is invalid, fetching fails, or required\n      fields are missing.\n    requests.exceptions.RequestException:  If there's an error during the\n        HTTP request."
                },
                "service_account_dict_to_scheme_credential": {
                  "type": "function",
                  "signature": "(config: Dict[str, Any], scopes: List[str]) -> Tuple[Union[fastapi.openapi.models.APIKey, fastapi.openapi.models.HTTPBase, fastapi.openapi.models.OAuth2, fastapi.openapi.models.OpenIdConnect, fastapi.openapi.models.HTTPBearer, google.adk.auth.auth_schemes.OpenIdConnectWithConfig], google.adk.auth.auth_credential.AuthCredential]",
                  "doc": "Creates AuthScheme and AuthCredential for Google Service Account.\n\nReturns a bearer token scheme, and a service account credential.\n\nArgs:\n    config: A ServiceAccount object containing the Google Service Account\n      configuration.\n    scopes: A list of scopes to be used.\n\nReturns:\n    Tuple: (AuthScheme, AuthCredential)"
                },
                "service_account_scheme_credential": {
                  "type": "function",
                  "signature": "(config: google.adk.auth.auth_credential.ServiceAccount) -> Tuple[Union[fastapi.openapi.models.APIKey, fastapi.openapi.models.HTTPBase, fastapi.openapi.models.OAuth2, fastapi.openapi.models.OpenIdConnect, fastapi.openapi.models.HTTPBearer, google.adk.auth.auth_schemes.OpenIdConnectWithConfig], google.adk.auth.auth_credential.AuthCredential]",
                  "doc": "Creates AuthScheme and AuthCredential for Google Service Account.\n\nReturns a bearer token scheme, and a service account credential.\n\nArgs:\n    config: A ServiceAccount object containing the Google Service Account\n      configuration.\n\nReturns:\n    Tuple: (AuthScheme, AuthCredential)"
                },
                "token_to_scheme_credential": {
                  "type": "function",
                  "signature": "(token_type: Literal['apikey', 'oauth2Token'], location: Optional[Literal['header', 'query', 'cookie']] = None, name: Optional[str] = None, credential_value: Optional[str] = None) -> Tuple[Union[fastapi.openapi.models.APIKey, fastapi.openapi.models.HTTPBase, fastapi.openapi.models.OAuth2, fastapi.openapi.models.OpenIdConnect, fastapi.openapi.models.HTTPBearer, google.adk.auth.auth_schemes.OpenIdConnectWithConfig], google.adk.auth.auth_credential.AuthCredential]",
                  "doc": "Creates a AuthScheme and AuthCredential for API key or bearer token.\n\nExamples:\n```\n# API Key in header\nauth_scheme, auth_credential = token_to_scheme_credential(\"apikey\", \"header\",\n\"X-API-Key\", \"your_api_key_value\")\n\n# API Key in query parameter\nauth_scheme, auth_credential = token_to_scheme_credential(\"apikey\", \"query\",\n\"api_key\", \"your_api_key_value\")\n\n# OAuth2 Bearer Token in Authorization header\nauth_scheme, auth_credential = token_to_scheme_credential(\"oauth2Token\",\n\"header\", \"Authorization\", \"your_bearer_token_value\")\n```\n\nArgs:\n    type: 'apikey' or 'oauth2Token'.\n    location: 'header', 'query', or 'cookie' (only 'header' for oauth2Token).\n    name: The name of the header, query parameter, or cookie.\n    credential_value:  The value of the API Key/ Token.\n\nReturns:\n    Tuple: (AuthScheme, AuthCredential)\n\nRaises:\n    ValueError: For invalid type or location."
                }
              }
            },
            "credential_exchangers": {
              "auto_auth_credential_exchanger": {
                "__members__": {
                  "AutoAuthCredentialExchanger": {
                    "type": "class",
                    "signature": "(custom_exchangers: Optional[Dict[str, Type[google.adk.tools.openapi_tool.auth.credential_exchangers.base_credential_exchanger.BaseAuthCredentialExchanger]]] = None)",
                    "doc": "Automatically selects the appropriate credential exchanger based on the auth scheme.\n\nOptionally, an override can be provided to use a specific exchanger for a\ngiven auth scheme.\n\nExample (common case):\n```\nexchanger = AutoAuthCredentialExchanger()\nauth_credential = exchanger.exchange_credential(\n    auth_scheme=service_account_scheme,\n    auth_credential=service_account_credential,\n)\n# Returns an oauth token in the form of a bearer token.\n```\n\nExample (use CustomAuthExchanger for OAuth2):\n```\nexchanger = AutoAuthCredentialExchanger(\n    custom_exchangers={\n        AuthScheme.OAUTH2: CustomAuthExchanger,\n    }\n)\n```\n\nAttributes:\n  exchangers: A dictionary mapping auth scheme to credential exchanger class."
                  }
                }
              },
              "base_credential_exchanger": {
                "__members__": {
                  "AuthCredentialMissingError": {
                    "type": "class",
                    "signature": "(message: str)",
                    "doc": "Exception raised when required authentication credentials are missing."
                  },
                  "BaseAuthCredentialExchanger": {
                    "type": "class",
                    "signature": "()",
                    "doc": "Base class for authentication credential exchangers."
                  }
                }
              },
              "oauth2_exchanger": {
                "__members__": {
                  "OAuth2CredentialExchanger": {
                    "type": "class",
                    "signature": "()",
                    "doc": "Fetches credentials for OAuth2 and OpenID Connect."
                  }
                }
              },
              "service_account_exchanger": {
                "__members__": {
                  "ServiceAccountCredentialExchanger": {
                    "type": "class",
                    "signature": "()",
                    "doc": "Fetches credentials for Google Service Account.\n\nUses the default service credential if `use_default_credential = True`.\nOtherwise, uses the service account credential provided in the auth\ncredential."
                  }
                }
              }
            }
          },
          "common": {
            "common": {
              "__members__": {
                "ApiParameter": {
                  "type": "class",
                  "signature": "(*, original_name: str, param_location: str, param_schema: Union[str, fastapi.openapi.models.Schema], description: Optional[str] = '', py_name: Optional[str] = '', type_value: type[typing.Any] = None, type_hint: str = None, required: bool = False) -> None",
                  "doc": "Data class representing a function parameter."
                },
                "PydocHelper": {
                  "type": "class",
                  "signature": "()",
                  "doc": "Helper class for generating PyDoc strings."
                },
                "TypeHintHelper": {
                  "type": "class",
                  "signature": "()",
                  "doc": "Helper class for generating type hints."
                },
                "rename_python_keywords": {
                  "type": "function",
                  "signature": "(s: 'str', prefix: 'str' = 'param_') -> 'str'",
                  "doc": "Renames Python keywords by adding a prefix.\n\nExample:\n```\nrename_python_keywords('if') -> 'param_if'\nrename_python_keywords('for') -> 'param_for'\n```\n\nArgs:\n    s: The input string.\n    prefix: The prefix to add to the keyword.\n\nReturns:\n    The renamed string."
                }
              }
            }
          },
          "openapi_spec_parser": {
            "openapi_spec_parser": {
              "__members__": {
                "OpenApiSpecParser": {
                  "type": "class",
                  "signature": "()",
                  "doc": "Generates Python code, JSON schema, and callables for an OpenAPI operation.\n\nThis class takes an OpenApiOperation object and provides methods to generate:\n1. A string representation of a Python function that handles the operation.\n2. A JSON schema representing the input parameters of the operation.\n3. A callable Python object (a function) that can execute the operation."
                },
                "OperationEndpoint": {
                  "type": "class",
                  "signature": "(*, base_url: str, path: str, method: str) -> None",
                  "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
                },
                "ParsedOperation": {
                  "type": "class",
                  "signature": "(*, name: str, description: str, endpoint: google.adk.tools.openapi_tool.openapi_spec_parser.openapi_spec_parser.OperationEndpoint, operation: fastapi.openapi.models.Operation, parameters: List[google.adk.tools.openapi_tool.common.common.ApiParameter], return_value: google.adk.tools.openapi_tool.common.common.ApiParameter, auth_scheme: Union[fastapi.openapi.models.APIKey, fastapi.openapi.models.HTTPBase, fastapi.openapi.models.OAuth2, fastapi.openapi.models.OpenIdConnect, fastapi.openapi.models.HTTPBearer, google.adk.auth.auth_schemes.OpenIdConnectWithConfig, NoneType] = None, auth_credential: Optional[google.adk.auth.auth_credential.AuthCredential] = None, additional_context: Optional[Any] = None) -> None",
                  "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."
                }
              }
            },
            "openapi_toolset": {
              "__members__": {
                "OpenAPIToolset": {
                  "type": "class",
                  "signature": "(*, spec_dict: 'Optional[Dict[str, Any]]' = None, spec_str: 'Optional[str]' = None, spec_str_type: \"Literal['json', 'yaml']\" = 'json', auth_scheme: 'Optional[AuthScheme]' = None, auth_credential: 'Optional[AuthCredential]' = None, tool_filter: 'Optional[Union[ToolPredicate, List[str]]]' = None)",
                  "doc": "Class for parsing OpenAPI spec into a list of RestApiTool.\n\nUsage::\n\n  # Initialize OpenAPI toolset from a spec string.\n  openapi_toolset = OpenAPIToolset(spec_str=openapi_spec_str,\n    spec_str_type=\"json\")\n  # Or, initialize OpenAPI toolset from a spec dictionary.\n  openapi_toolset = OpenAPIToolset(spec_dict=openapi_spec_dict)\n\n  # Add all tools to an agent.\n  agent = Agent(\n    tools=[*openapi_toolset.get_tools()]\n  )\n  # Or, add a single tool to an agent.\n  agent = Agent(\n    tools=[openapi_toolset.get_tool('tool_name')]\n  )"
                }
              }
            },
            "operation_parser": {
              "__members__": {
                "OperationParser": {
                  "type": "class",
                  "signature": "(operation: 'Union[Operation, Dict[str, Any], str]', should_parse=True)",
                  "doc": "Generates parameters for Python functions from an OpenAPI operation.\n\nThis class processes an OpenApiOperation object and provides helper methods\nto extract information needed to generate Python function declarations,\ndocstrings, signatures, and JSON schemas.  It handles parameter processing,\nname deduplication, and type hint generation."
                }
              }
            },
            "rest_api_tool": {
              "__members__": {
                "RestApiTool": {
                  "type": "class",
                  "signature": "(name: 'str', description: 'str', endpoint: 'Union[OperationEndpoint, str]', operation: 'Union[Operation, str]', auth_scheme: 'Optional[Union[AuthScheme, str]]' = None, auth_credential: 'Optional[Union[AuthCredential, str]]' = None, should_parse_operation=True)",
                  "doc": "A generic tool that interacts with a REST API.\n\n* Generates request params and body\n* Attaches auth credentials to API call.\n\nExample::\n\n  # Each API operation in the spec will be turned into its own tool\n  # Name of the tool is the operationId of that operation, in snake case\n  operations = OperationGenerator().parse(openapi_spec_dict)\n  tool = [RestApiTool.from_parsed_operation(o) for o in operations]"
                },
                "snake_to_lower_camel": {
                  "type": "function",
                  "signature": "(snake_case_string: 'str')",
                  "doc": "Converts a snake_case string to a lower_camel_case string.\n\nArgs:\n    snake_case_string: The input snake_case string.\n\nReturns:\n    The lower_camel_case string."
                }
              }
            },
            "tool_auth_handler": {
              "__members__": {
                "AuthPreparationResult": {
                  "type": "class",
                  "signature": "(*, state: Literal['pending', 'done'], auth_scheme: Union[fastapi.openapi.models.APIKey, fastapi.openapi.models.HTTPBase, fastapi.openapi.models.OAuth2, fastapi.openapi.models.OpenIdConnect, fastapi.openapi.models.HTTPBearer, google.adk.auth.auth_schemes.OpenIdConnectWithConfig, NoneType] = None, auth_credential: Optional[google.adk.auth.auth_credential.AuthCredential] = None) -> None",
                  "doc": "Result of the credential preparation process."
                },
                "ToolAuthHandler": {
                  "type": "class",
                  "signature": "(tool_context: 'ToolContext', auth_scheme: 'Optional[AuthScheme]', auth_credential: 'Optional[AuthCredential]', credential_exchanger: 'Optional[BaseAuthCredentialExchanger]' = None, credential_store: \"Optional['ToolContextCredentialStore']\" = None)",
                  "doc": "Handles the preparation and exchange of authentication credentials for tools."
                },
                "ToolContextCredentialStore": {
                  "type": "class",
                  "signature": "(tool_context: 'ToolContext')",
                  "doc": "Handles storage and retrieval of credentials within a ToolContext."
                }
              }
            }
          }
        },
        "preload_memory_tool": {
          "__members__": {
            "PreloadMemoryTool": {
              "type": "class",
              "signature": "()",
              "doc": "A tool that preloads the memory for the current user.\n\nNOTE: Currently this tool only uses text part from the memory."
            }
          }
        },
        "tool_context": {
          "__members__": {
            "ToolContext": {
              "type": "class",
              "signature": "(invocation_context: 'InvocationContext', *, function_call_id: 'Optional[str]' = None, event_actions: 'Optional[EventActions]' = None)",
              "doc": "The context of the tool.\n\nThis class provides the context for a tool invocation, including access to\nthe invocation context, function call ID, event actions, and authentication\nresponse. It also provides methods for requesting credentials, retrieving\nauthentication responses, listing artifacts, and searching memory.\n\nAttributes:\n  invocation_context: The invocation context of the tool.\n  function_call_id: The function call id of the current tool call. This id was\n    returned in the function call event from LLM to identify a function call.\n    If LLM didn't return this id, ADK will assign one to it. This id is used\n    to map function call response to the original function call.\n  event_actions: The event actions of the current tool call."
            }
          }
        },
        "transfer_to_agent_tool": {
          "__members__": {
            "transfer_to_agent": {
              "type": "function",
              "signature": "(agent_name: 'str', tool_context: 'ToolContext') -> 'None'",
              "doc": "Transfer the question to another agent.\n\nThis tool hands off control to another agent when it's more suitable to\nanswer the user's question according to the agent's description.\n\nArgs:\n  agent_name: the agent name to transfer to."
            }
          }
        },
        "url_context_tool": {
          "__members__": {
            "UrlContextTool": {
              "type": "class",
              "signature": "()",
              "doc": "A built-in tool that is automatically invoked by Gemini 2 models to retrieve content from the URLs and use that content to inform and shape its response.\n\nThis tool operates internally within the model and does not require or perform\nlocal code execution."
            }
          }
        },
        "vertex_ai_search_tool": {
          "__members__": {
            "VertexAiSearchTool": {
              "type": "class",
              "signature": "(*, data_store_id: 'Optional[str]' = None, data_store_specs: 'Optional[list[types.VertexAISearchDataStoreSpec]]' = None, search_engine_id: 'Optional[str]' = None, filter: 'Optional[str]' = None, max_results: 'Optional[int]' = None)",
              "doc": "A built-in tool using Vertex AI Search.\n\nAttributes:\n  data_store_id: The Vertex AI search data store resource ID.\n  search_engine_id: The Vertex AI search engine resource ID."
            }
          }
        }
      },
      "utils": {
        "feature_decorator": {
          "__members__": {
            "_create_decorator": {
              "type": "function",
              "signature": "(message: 'str', label: 'str', block_usage: 'bool', bypass_env_var: 'Optional[str]') -> 'Callable[[T], T]'",
              "doc": ""
            },
            "_make_feature_decorator": {
              "type": "function",
              "signature": "(*, label: 'str', default_message: 'str', block_usage: 'bool' = False, bypass_env_var: 'Optional[str]' = None) -> 'Callable'",
              "doc": ""
            },
            "experimental": {
              "type": "function",
              "signature": "(message_or_obj=None)",
              "doc": ""
            },
            "working_in_progress": {
              "type": "function",
              "signature": "(message_or_obj=None)",
              "doc": ""
            }
          }
        },
        "instructions_utils": {
          "__members__": {
            "_is_valid_state_name": {
              "type": "function",
              "signature": "(var_name)",
              "doc": "Checks if the variable name is a valid state name.\n\nValid state is either:\n  - Valid identifier\n  - <Valid prefix>:<Valid identifier>\nAll the others will just return as it is.\n\nArgs:\n  var_name: The variable name to check.\n\nReturns:\n  True if the variable name is a valid state name, False otherwise."
            },
            "inject_session_state": {
              "type": "function",
              "signature": "(template: 'str', readonly_context: 'ReadonlyContext') -> 'str'",
              "doc": "Populates values in the instruction template, e.g. state, artifact, etc.\n\nThis method is intended to be used in InstructionProvider based instruction\nand global_instruction which are called with readonly_context.\n\ne.g.\n```\n...\nfrom google.adk.utils.instructions_utils import inject_session_state\n\nasync def build_instruction(\n    readonly_context: ReadonlyContext,\n) -> str:\n  return await inject_session_state(\n      'You can inject a state variable like {var_name} or an artifact '\n      '{artifact.file_name} into the instruction template.',\n      readonly_context,\n  )\n\nagent = Agent(\n    model=\"gemini-2.0-flash\",\n    name=\"agent\",\n    instruction=build_instruction,\n)\n```\n\nArgs:\n  template: The instruction template.\n  readonly_context: The read-only context\n\nReturns:\n  The instruction template with values populated."
            }
          }
        },
        "model_name_utils": {
          "__members__": {
            "extract_model_name": {
              "type": "function",
              "signature": "(model_string: 'str') -> 'str'",
              "doc": "Extract the actual model name from either simple or path-based format.\n\nArgs:\n  model_string: Either a simple model name like \"gemini-2.5-pro\" or\n                a path-based model name like \"projects/.../models/gemini-2.0-flash-001\"\n\nReturns:\n  The extracted model name (e.g., \"gemini-2.5-pro\")"
            },
            "is_gemini_1_model": {
              "type": "function",
              "signature": "(model_string: 'Optional[str]') -> 'bool'",
              "doc": "Check if the model is a Gemini 1.x model using regex patterns.\n\nArgs:\n  model_string: Either a simple model name or path-based model name\n\nReturns:\n  True if it's a Gemini 1.x model, False otherwise"
            },
            "is_gemini_2_model": {
              "type": "function",
              "signature": "(model_string: 'Optional[str]') -> 'bool'",
              "doc": "Check if the model is a Gemini 2.x model using regex patterns.\n\nArgs:\n  model_string: Either a simple model name or path-based model name\n\nReturns:\n  True if it's a Gemini 2.x model, False otherwise"
            },
            "is_gemini_model": {
              "type": "function",
              "signature": "(model_string: 'Optional[str]') -> 'bool'",
              "doc": "Check if the model is a Gemini model using regex patterns.\n\nArgs:\n  model_string: Either a simple model name or path-based model name\n\nReturns:\n  True if it's a Gemini model, False otherwise"
            }
          }
        },
        "variant_utils": {
          "__members__": {
            "GoogleLLMVariant": {
              "type": "class",
              "signature": "(*values)",
              "doc": "The Google LLM variant to use.\nsee https://google.github.io/adk-docs/get-started/quickstart/#set-up-the-model"
            },
            "get_google_llm_variant": {
              "type": "function",
              "signature": "() -> 'str'",
              "doc": ""
            }
          }
        }
      }
    }
  }
}