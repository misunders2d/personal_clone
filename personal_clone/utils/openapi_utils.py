"""This file houses the core Python functions for handling OpenAPI specifications."""

import asyncio
import os
import uuid
import requests

from google.adk.agents import LlmAgent
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
from google.adk.tools.openapi_tool import OpenAPIToolset
from google.genai import types

from .github_utils import create_or_update_file


def fetch_spec_from_url(url: str) -> str:
    """Fetches the content of an OpenAPI specification from a URL using requests."""
    try:
        response = requests.get(url)
        response.raise_for_status()  # Raise an exception for bad status codes (4xx or 5xx)
        return response.text
    except requests.exceptions.RequestException as e:
        return f"Error: Failed to fetch content from URL {url}. Details: {e}"


def create_persistent_openapi_tool(
    tool_name: str, spec_string: str, branch_name: str
) -> str:
    """
    Generates the code for a persistent OpenAPI tool and saves it to a GitHub branch.

    Args:
        tool_name: A short, descriptive name for the tool (e.g., 'Stripe').
        spec_string: The OpenAPI specification as a string.
        branch_name: The name of the GitHub feature branch to commit the new tool to.

    Returns:
        A message indicating success or failure.
    """
    tool_name_lower = tool_name.lower().replace(" ", "_")
    dir_path = os.path.join("personal_clone", "utils", "generated_tools")
    file_path = os.path.join(dir_path, f"{tool_name_lower}_toolset.py")

    # Ensure the local directory exists before trying to write to it (for local testing if any)
    os.makedirs(dir_path, exist_ok=True)

    # Correctly escape single quotes and backticks for the f-string
    escaped_spec_string = spec_string.replace("'", "'").replace("`", "\`")

    code_template = f"""
# Auto-generated by the personal_clone agent.
# This file defines a persistent toolset for the {tool_name} API.

from google.adk.tools.openapi_tool import OpenAPIToolset

# --- OpenAPI Specification ---
spec_string = '''{escaped_spec_string}'''

# --- Toolset Definition ---
{tool_name_lower}_toolset = OpenAPIToolset(
    spec_str=spec_string,
    spec_str_type='json', # Assuming json for now, can be parameterized
)
"""

    commit_message = f"feat: Add persistent toolset for {tool_name}"

    result = create_or_update_file(
        file_path=file_path,
        content=code_template,
        commit_message=commit_message,
        branch=branch_name,
    )
    return result


async def run_temporary_openapi_tool(spec_string: str, query: str) -> str:
    """
    Creates a temporary agent to handle a specific query using a provided OpenAPI spec.

    Args:
        spec_string: The OpenAPI specification as a string.
        query: The user's query to be executed by the temporary agent.

    Returns:
        The final text response from the agent.
    """
    app_name = f"temp_app_{uuid.uuid4().hex}"
    user_id = f"temp_user_{uuid.uuid4().hex}"
    session_id = f"temp_session_{uuid.uuid4().hex}"
    agent_name = f"temp_agent_{uuid.uuid4().hex}"
    spec_type = "yaml" if spec_string.strip().startswith("openapi:") else "json"

    try:
        temp_toolset = OpenAPIToolset(
            spec_str=spec_string,
            spec_str_type=spec_type,
        )
        tools = await temp_toolset.get_tools()
        if not tools:
            return "Agent Error: The provided OpenAPI spec did not result in any usable tools."
    except Exception as e:
        return f"Agent Error: Failed to parse the OpenAPI specification. Details: {e}"

    temp_agent = LlmAgent(
        name=agent_name,
        model=os.environ.get("MODEL_NAME", "gemini-1.5-flash-latest"),
        tools=[temp_toolset],
        instruction=f"""
You are a specialized assistant.
Your purpose is to execute a single task using the provided tools.
The user wants to: {query}.
Use the available tools to fulfill this request.
Provide a clear, concise answer based on the tool's output.""",
    )

    session_service = InMemorySessionService()
    await session_service.create_session(
        app_name=app_name, user_id=user_id, session_id=session_id
    )
    runner = Runner(
        agent=temp_agent, app_name=app_name, session_service=session_service
    )

    content = types.Content(role="user", parts=[types.Part(text=query)])
    final_response_text = "Agent did not provide a final text response."

    try:
        async for event in runner.run_async(
            user_id=user_id, session_id=session_id, new_message=content
        ):
            if (
                event.is_final_response()
                and event.content
                and event.content.parts
                and event.content.parts[0].text
            ):
                final_response_text = event.content.parts[0].text.strip()
    except Exception as e:
        final_response_text = f"Agent Error: An exception occurred - {e}"

    return final_response_text
