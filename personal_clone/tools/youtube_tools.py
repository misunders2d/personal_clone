import os
import time
import tempfile
import yt_dlp
from google import genai
from google.adk.models import Gemini
from google.genai import types
from typing import Any

from .. import config

client = genai.Client(api_key=config.GEMINI_API_KEY, vertexai=False)


async def youtube_summary(url: str, query: str):
    """
    Answer questions about a specific YouTube video, focusing on specific query
    """
    model = (
        config.GOOGLE_FLASH_MODEL.model
        if isinstance(config.GOOGLE_FLASH_MODEL, Gemini)
        else config.GOOGLE_FLASH_MODEL
    )

    upload_file = None
    temp_path = None

    try:
        with yt_dlp.YoutubeDL({"quiet": True}) as ydl:
            info = ydl.extract_info(url, download=False)
            duration = info.get("duration", 0)

        if not duration:
            return {"status": "failed", "message": "Could not retrieve video duration."}
        elif duration > 1800:
            with tempfile.NamedTemporaryFile(suffix=".m4a", delete=False) as tmp:
                temp_path = tmp.name

            ydl_opts: Any = {
                "format": "bestaudio[ext=m4a]/bestaudio",
                "outtmpl": temp_path,
                "quiet": True,
                "overwrites": True,
            }

            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                ydl.download([url])

            upload_file = client.files.upload(file=temp_path)

            while (
                upload_file.state
                and upload_file.state.name
                and upload_file.name == "PROCESSING"
            ):
                time.sleep(1)
                upload_file = client.files.get(name=upload_file.name)

            if upload_file.state and upload_file.state.name == "FAILED":
                return {
                    "status": "failed",
                    "message": "File processing failed on Gemini side.",
                }


            contents = [
                types.Part(
                    file_data=types.FileData(
                        file_uri=upload_file.uri, mime_type=upload_file.mime_type
                    )
                ),
                types.Part(text=query),
            ]

        else:
            contents = [
                types.Part(
                    file_data=types.FileData(file_uri=url, mime_type="video/mp4"),
                ),
                types.Part(text=query),
            ]

        response = client.models.generate_content(
            model=model,
            contents=contents,
        )


        response_text = ""
        if (
            response
            and response.candidates
            and response.candidates[0]
            and response.candidates[0].content
            and response.candidates[0].content.parts
        ):
            parts = response.candidates[0].content.parts
            for part in parts:
                if part.text:
                    response_text += part.text
            return {"status": "success", "message": response_text}
        else:
            return {
                "status": "failed",
                "message": "No response was generated by the model",
            }

    except Exception as e:
        return {"status": "error", "message": e}

    finally:
        if temp_path and os.path.exists(temp_path):
            os.remove(temp_path)

        if upload_file and upload_file.name:
            try:
                client.files.delete(name=upload_file.name)
            except Exception:
                pass
